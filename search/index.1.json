[{"authors":[],"categories":[],"content":"基于配置表（转移表 / 状态表）的通用状态机框架\n一、状态和事件枚举 1typedef enum { 2 STATE_IDLE, 3 STATE_PROCESSING, 4 STATE_ACTION, 5 STATE_ERROR, 6 STATE_MAX 7} fsm_state_t; 8 9typedef enum { 10 EVENT_NONE, 11 EVENT_START, 12 EVENT_DONE, 13 EVENT_FAIL, 14 EVENT_MAX 15} fsm_event_t; 二、动作函数类型 1typedef void (*fsm_action_t)(void);示例动作函数：\n1void action_init(void) { /* 初始化逻辑 */ } 2void action_process(void) { /* 核心处理逻辑 */ } 3void action_post(void) { /* 执行动作 */ } 4void action_error(void) { /* 错误处理 */ } 三、状态机表定义 1typedef struct { 2 fsm_state_t current_state; // 当前状态 3 fsm_event_t event; // 触发事件 4 fsm_action_t action; // 执行动作 5 fsm_state_t next_state; // 下一个状态 6} fsm_table_entry_t;配置表示例：\n1fsm_table_entry_t fsm_table[] = { 2 {STATE_IDLE, EVENT_START, action_init, STATE_PROCESSING}, 3 {STATE_PROCESSING, EVENT_DONE, action_process, STATE_ACTION}, 4 {STATE_PROCESSING, EVENT_FAIL, action_error, STATE_ERROR}, 5 {STATE_ACTION, EVENT_NONE, action_post, STATE_IDLE}, 6 {STATE_ERROR, EVENT_NONE, action_error, STATE_IDLE} 7}; 四、状态机执行函数 1void fsm_handle_event(fsm_state_t *state, fsm_event_t event) { 2 for(int i = 0; i \u0026lt; sizeof(fsm_table)/sizeof(fsm_table[0]); i++) { 3 if(fsm_table[i].current_state == *state \u0026amp;\u0026amp; fsm_table[i].event == event) { 4 if(fsm_table[i].action) 5 fsm_table[i].action(); 6 *state = fsm_table[i].next_state; 7 break; 8 } 9 } 10} 五、使用示例 1fsm_state_t current_state = STATE_IDLE; 2 3// 触发事件 4fsm_handle_event(\u0026amp;current_state, EVENT_START); // Idle -\u0026gt; Processing 5fsm_handle_event(\u0026amp;current_state, EVENT_DONE); // Processing -\u0026gt; Action 6fsm_handle_event(\u0026amp;current_state, EVENT_NONE); // Action -\u0026gt; Idle ✅ 优点 可扩展性强：新增状态或事件只需在表里添加一行，无需修改核心代码。 可维护性高：状态逻辑全部集中在表格中，清晰直观。 动作自由组合：不同状态+事件可执行不同动作，支持函数指针调用。 类 DCM 风格：符合 AUTOSAR 状态机/诊断模块逻辑设计。 ","date":"2025年11月10日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/state_machine/","series":[],"smallImg":"","tags":[],"timestamp":1762775586,"title":"State_machine"},{"authors":[],"categories":[],"content":"teslamate\n项目介绍 teslamate\nDocker install\ndocker 安装建议使用 docker compose 管理\n认证登录 4000 端口登录\ntesla_auth How to generate your own tokens Auth app for Tesla 3000 端口登录，默认账户 admin/admin\ngrafana 数据路径修改 需要修改路径权限，否则grafana运行是出错的\n1sudo chown -R 472:472 ./teslamate-grafana-data 2sudo chmod -R 755 ./teslamate-grafana-data 3docker compose up -d grafana docker 语法参考 docker compose\n","date":"2025年11月8日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/misc/teslamate/","series":[],"smallImg":"","tags":[],"timestamp":1762608782,"title":"Teslamate"},{"authors":[],"categories":[],"content":"旗芯微\nFC7300 芯片介绍\nHigh Performance\nThree Cortex M7 running at 300MHz (3.23 Dhrystone MIPS per MHz) with extra two checker core 8kB Cache Large memory\nUp to 2MB P-Flash + 256K D-Flash Up to 256K SRAM Key Peripherals\n1 Gbit Ethernet with TSN 10 FlexCAN (with CAN-FD support) Enhanced FIFO 18 UART (with LIN support), 8xSPI, 2xI2C 4xADC, 12-bit, up to 32-ch per module 2x Micro Second Channel (MSC) modules 2x 4ch Sent Edge Nibble Transmit (SENT) modules 12xFTU (Flexible Timer Unit), 16-bit Safety \u0026amp; Security\nISO 26262 ASIL-D HSM with AES/SM4/SHA/SM3/RSA/ECC/SM2/SM9, RNGM EVITA full, Key Management, Secure boot AEC-Q100 Grade 1\nSupply Voltage: 3.0~5.5V\nPackage: 176LQFP-EP, BGA320\n问题 连接脚本分区配置 设置大小填充，防止 hex 分区，解析出错 define block ISR_VECTOR with alignment = 1024, size = 0x400 软重启配置sram区域数据保持 STCU base address : 4007_F000h 50h STCU_SRAM_INI_SEL (SRAM Initialization Select Register) reboot mcu reset boot \u0026ndash;\u0026gt; app 访问异常地址直接重启？ ","date":"2025年10月24日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/flagchip/flagchip/","series":[],"smallImg":"","tags":[],"timestamp":1761275770,"title":"Flagchip"},{"authors":[],"categories":[],"content":"HEX 文件是一种 ASCII 文本格式，常用于存储 微控制器或EPROM 的机器码。 它以十六进制形式表示二进制数据，常见扩展名为：.hex / .ihx\n基本格式 每一行（称为一条“记录 record”）的通用格式为：\n:llaaaatt[dd\u0026hellip;]cc\n字段 长度（字节） 说明 : 1 每行的起始标志 ll 1 数据字节数（该行数据的长度） aaaa 2 起始地址（偏移地址） tt 1 记录类型 dd... ll 实际数据内容 cc 1 校验和 记录类型（tt） 类型值 含义 00 数据记录（最常见） 01 文件结束记录（EOF） 02 扩展段地址记录（16位段地址） 04 扩展线性地址记录（高16位地址，用于32位地址） 05 启动地址记录（执行起始地址） 校验和计算规则 校验和（checksum）用于验证每行数据的正确性。\n计算方法：\nSum = (ll + aaaa高字节 + aaaa低字节 + tt + 所有数据字节) 取低8位 Checksum = (0x100 - Sum) \u0026 0xFF 验证时： 每行所有字节（包括校验和）之和的低8位应为 0。\n示例解析 示例行：\n:10010000214601360121470136007EFE09D2190140\n逐项解析：\n部分 含义 : 起始符 10 数据长度 = 16字节 0100 起始地址 = 0x0100 00 记录类型 = 数据记录 214601360121470136007EFE09D21901 数据内容（16字节） 40 校验和 验证校验和：\nSum = 0x10 + 0x01 + 0x00 + 0x00 + (16个数据字节) Sum = 0xC0 Checksum = (0x100 - 0xC0) \u0026 0xFF = 0x40 ✅ 文件结束行示例 :00000001FF\n长度 = 0\n地址 = 0000\n类型 = 01 (文件结束)\n校验和 = FF\n扩展地址记录示例 扩展线性地址记录（用于 32 位地址）\n:020000040001F9\n长度 = 2\n地址 = 0000\n类型 = 04\n数据 = 0001（高 16 位）\n校验和 = F9\n→ 之后的数据记录地址应加上 (0x0001 \u0026laquo; 16) = 0x00010000\npython 解析脚本 1 2# :llaaaatt[dd...]cc 3 4# :\t1\t每行的起始标志 5# ll\t1\t数据字节数（该行数据的长度） 6# aaaa\t2\t起始地址（偏移地址） 7# tt\t1\t记录类型 8# dd...\tll\t实际数据内容 9# cc\t1\t校验和 10 11# 00\t数据记录（最常见） 12# 01\t文件结束记录（EOF） 13# 02\t扩展段地址记录（16位段地址） 14# 04\t扩展线性地址记录（高16位地址，用于32位地址） 15# 05\t启动地址记录（执行起始地址） 16 17import sys 18import io 19 20# 强制设置 stdout 编码为 UTF-8 21sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding=\u0026#39;utf-8\u0026#39;) 22 23def parse_hex_fragments(hex_file_path): 24 \u0026#34;\u0026#34;\u0026#34; 25 解析HEX文件，返回所有独立数据块及起始地址，严格保留地址不连续性。 26 27 返回值: 28 - data_blocks: 列表，每个元素为字典，包含 \u0026#39;address\u0026#39; 和 \u0026#39;data\u0026#39; 29 - start_address: 首个数据块的地址（若文件无数据，返回None） 30 \u0026#34;\u0026#34;\u0026#34; 31 with open(hex_file_path, \u0026#39;r\u0026#39;) as f: 32 lines = f.readlines() 33 34 data_blocks = [] # 存储所有数据块 [{address: int, data: bytes}, ...] 35 upper_address = 0x0000 # 扩展线性地址（类型04） 36 current_segment = 0x0000 # 扩展段地址（类型02） 37 start_address = None 38 39 for line in lines: 40 line = line.strip() 41 if not line.startswith(\u0026#39;:\u0026#39;): 42 continue 43 44 # 解析字段 45 byte_count = int(line[1:3], 16) # 1-2 46 address = int(line[3:7], 16) 47 record_type = int(line[7:9], 16) 48 data_bytes = bytes.fromhex(line[9:-2]) 49 checksum = int(line[-2:], 16) 50 51 # 校验和验证 52 computed_sum = sum(bytes.fromhex(line[1:-2])) \u0026amp; 0xFF # Sum = (ll + aaaa高字节 + aaaa低字节 + tt + 所有数据字节) 53 computed_checksum = (0x100 - computed_sum) \u0026amp; 0xFF # Checksum = (0x100 - Sum) \u0026amp; 0xFF 54 if checksum != computed_checksum: 55 raise ValueError(f\u0026#34;校验和错误: {line}\u0026#34;) 56 57 # 处理记录类型 58 if record_type == 0x00: # 数据记录 59 # 计算完整地址（支持段地址和线性地址） 60 if upper_address != 0x0000: 61 full_address = (upper_address \u0026lt;\u0026lt; 16) + address 62 else: 63 full_address = (current_segment \u0026lt;\u0026lt; 4) + address 64 65 # 记录数据块（即使地址不连续也独立存储） 66 data_blocks.append({ 67 \u0026#39;address\u0026#39;: full_address, 68 \u0026#39;data\u0026#39;: data_bytes 69 }) 70 71 # 更新起始地址（仅首个数据块） 72 if start_address is None: 73 start_address = full_address 74 75 elif record_type == 0x02: # 扩展段地址 76 current_segment = int.from_bytes(data_bytes, byteorder=\u0026#39;big\u0026#39;) 77 78 elif record_type == 0x04: # 扩展线性地址 79 upper_address = int.from_bytes(data_bytes, byteorder=\u0026#39;big\u0026#39;) 80 81 # 05 启动地址记录（执行起始地址） 82 elif record_type == 0x01: # 文件结束 83 break 84 85 return data_blocks, start_address 86 87if __name__ == \u0026#39;__main__\u0026#39;: 88 # 示例用法 89 filename=r\u0026#39;AppDemo.hex\u0026#39; 90 data_blocks, start_addr = parse_hex_fragments(filename) 91 92 # 打印输出 93 if start_addr is not None: 94 print(f\u0026#34;文件起始地址: 0x{start_addr:08X}\u0026#34;) 95 for idx, block in enumerate(data_blocks): 96 print(f\u0026#34;数据块 {idx + 1}:\u0026#34;) 97 print(f\u0026#34; 起始地址: 0x{block[\u0026#39;address\u0026#39;]:08X}\u0026#34;) 98 print(f\u0026#34; 数据长度: {len(block[\u0026#39;data\u0026#39;])} 字节\u0026#34;) 99 print(f\u0026#34; 数据内容: {block[\u0026#39;data\u0026#39;].hex().upper()}\u0026#34;) 100 else: 101 print(\u0026#34;HEX文件中未找到有效数据记录！\u0026#34;)","date":"2025年10月24日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/hex/","series":[],"smallImg":"","tags":[],"timestamp":1761274129,"title":"Hex"},{"authors":[],"categories":[],"content":"AURIX™ Development Studio\n利用ads和miniwiggler直接调试elf文件\n任意项目并设置active，最好是相同调试器的工程，后面设置就简单 新建debug配置\n参考：Tasking IDE debugging with DAP 机器翻译版本\n","date":"2025年10月10日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/tricore/ads/","series":[],"smallImg":"","tags":[],"timestamp":1760091143,"title":"Ads"},{"authors":[],"categories":[],"content":"Distributed System Interface\nDSI3 Bus Standard\nDSI3 DSI3 是第三代卫星接口总线，主要用于中央主接口与多个卫星节点之间的安全关键通信（一主多从）\n从节点\n- 简单状态机\n- 微处理器\n- DSP控制器\n- raw / preprocessed data sources\n- single / multiple data sources\n- output / control 功能\nDiscovery Mode\n- 识别slave位置\n- 分配unique 物理地址\nfail silent philosophy\nBackground Diagnostic Mode\n- 诊断\n- 功能安全\n主要目标应用领域是汽车安全气囊系统，但预计新功能允许用在其他的领域\n基本特性 Bandwidth Improvements t Time-Division-Multiple-Access (TDMA) EMC Improvements Data Integrity Improvements Cost Controls 总线拓扑，功能 point-to-point daisy-chain parallel Signal Function Class 周期性数据采集 Power Function Class 功率输出 Signal：Command and Response Signal：Periodic Data Collection Mode Signal：Background Diagnostic Mode Power：Background Diagnostic Mode 物理层编码 Forward Channel Data Bit Encoding - Master Perspective Reverse Communication Channel Data Bit Encoding 一个symbol \u0026lt;\u0026ndash;\u0026gt; 3个chip \u0026lt;\u0026ndash;\u0026gt; 12byte\n三种电流有27种组合，但是0开始(和Iq一样)去掉，去掉全相同的两个，即剩下16个，对应4byte\nMulti-Level Source Coded TDMA Response Frame\nLink Layer Signal Function Class Command and Response Mode Packet Formats Command and Response Mode - Command Format\nPhysical Address Command Extended Data Register Data CRC MSB LSB PA[3:0] CMD[3:0] ED[7:0] RD[7:0] CRC[7:0] Command and Response Mode - Response Format\nPhysical Address Status Extended Data Register Data CRC MSB LSB PA[3:0] S[3:0] ED[7:0] RD[7:0] CRC[7:0] Command and Response Mode - Field Definitions\nField Command Packet Length\n(Bits) Field Response Packet Length\n(Bits) PA[3:0] Physical Address 4 PA[3:0] Physical Address 4 CMD[3:0] Command 4 S[3:0] Status 4 ED[7:0] Extended Data 8 ED[7:0] Extended Data 8 RD[7:0] Register Data 8 RD[7:0] Register Data 8 CRC[7:0] 8 CRC[7:0] 8 Command and Response Mode - Supported Commands\nCommand Command Description Extended Data ED[7:0] 0 Register Read Register Address RA[7:0] 2 – 7 Device / System Specific Device / System Specific 8 Register Write Register Address RA[7:0] 9 - 15 Device / System Specific Device / System Specific Command and Response Mode - Status Definitions\nPeriodic Data Collection Mode Packet Formats Background Diagnostic Mode Packet Formats Power Function Class Transactions 基本和Command and Response Mode Packet Formats的命令一致\nslave address DSI3 使用 物理地址 + 可选源标识地址（source identification addresses） 每个物理从机必须有唯一 4-bit 物理地址 地址 0 为 全局地址（global address），用于全局命令，无需响应 PA3 PA2 PA1 PA0 Slave Number 0 0 0 0 All Slaves 0 0 1 0 Slave 2 0 0 1 1 Slave 3 0 1 0 0 Slave 4 0 1 0 1 Slave 5 0 1 1 0 Slave 6 0 1 1 1 Slave 7 1 0 0 0 Slave 8 1 0 0 1 Slave 9 1 0 1 0 Slave 10 1 0 1 1 Slave 11 1 1 0 0 Slave 12 1 1 0 1 Slave 13 1 1 1 0 Slave 14 1 1 1 1 Slave 15 自动分配地址\n","date":"2025年8月21日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/bus/dsi3/","series":[],"smallImg":"","tags":[{"title":"DSI3","url":"/tags/dsi3/"},{"title":"USS","url":"/tags/uss/"}],"timestamp":1755745640,"title":"Dsi3"},{"authors":[],"categories":[],"content":"tc39x SOTA\nMemory Maps (MEMMAP) segment function 0,2 reserved 1,3-7 PSDR,DSPR,PCACHE,DCACHE 8 cached PFlash and BROM 9 cached LMU and EMEM 10 non-cached PFlash,DFlash and BROM 11 non-cached LMU and EMEM 12-14 reserved 15 lower 128M SPB, upper 128M SRI 如下图，相同的flash区域，通过在不同的segment的map实现不同的功能 SOTA MAP PFlash 分为 A/B 大小相同的bank tc397的PF0-5共计16M，但是tc397的PF4-5大小的限制，导致的升级的ota大小支持最大3M+3M+1M=7M 通过DMU（Data Memory Unit）操作Flash时，需要操作Pflash映射的物理地址空间。 即：Active Banks擦除Inactive Banks时，需要按照Inactive Banks映射的地址空间擦/写。 eg：A-Banks（Active Banks）的起始地址0xA0000000，B-Banks（Inactive Banks）的起始地址0xA0600000， A-Banks操作Flash Driver擦/写B-Banks时，操作的起始地址为0xA0600000。\nSWAP配置及注意事项 调整Linker文件（链接文件） App程序开发，生成可执行文件（.bin、.Hex等） 可执行文件烧录到PFlash中 配置SWAP，包括：A/B选择配置，SWAP使能 调整Linker文件 这里给出一个Linker文件调整的示意（不带HSM(Hardware Security Module)） 对于TC397，A/B均可以分配7M空间，之后根据调整的链接文件，分别编译Project A和Project B，即：Project A对应A-Banks的Linker A，Project B对应B-Banks的Linker B，一般处理时，Linker A和Linker B共用同一个链接文件。 本文关注的核心点：Configuring SWAP。\n如果是两个link的话，如何管控 ??\n如果是一个link的话，如何知道升级的a or b？\nswap配置 配置SWAP，需要配置UCB23（ORIG）和UCB31（COPY），选择映射地址。UCB位于DFlash0区域，UCB23（ORIG）和UCB31（COPY）的地址空间范围如下所示： UCB23的格式固定如下： swap的激活配置，索引在寄存器SCU_STMEM1中设置\nSCU_STMEM1.SWAP_CFG: SWAP configuration SCU_STMEM1.SWAP_TARGET: UCB_SWAP used for configuration flag (ORIG/COPY) SCU_STMEM1.SWAP_DW_INDEX: Offset from UCB_SWAP_ORIG/COPY begin swap 初始化 ① 用烧写器把APP烧写进PFlash的组A地址处\n② 向MARKERL0写入0x00000055\n③ 向MARKERH0写入MARKERL0的系统地址\n④ 向CONFERMATIONL0写入0x57B5327F\n⑤ 向CONFERMATIONH0写入CONFERMATIONL0的系统地址\n⑥ 将UCB_OTP0中SWAPEN标志位置为Enable\n⑦ 重启MCU\n进行APP更新的步骤：\n① 将新的APP写入PFlash中未激活的部分，即上文提到的Inactive Bank，并进行准确性校验\n② 如果新的APP被写入组B，则向MARKERLx.SWAP写入0x000000AA，启用Alternate地址映射模式；如果新的APP被写入组A，则向MARKERLx.SWAP写入0x00000055，启用标准地址映射模式。（x是0-15的值，从0开始向上递增，由上文可知UCB_SWAP最多能存储16组标志值，存满后再擦除重新写入。）\n③ MARKERHx.ADDR、CONFIRMATIONLx.CODE和CONFIRMATIONHx.ADDR配置同上文\n④ 向CONFIRMATIONL(x-1).CODE再次写入0xFFFFFFFF，来使上一组UCB_SWAP值失效。向PFlash再次写入全1的值不会导致PFlash操作错误\n寄存器 HF_PROCONTP (DMU 0xFFC00000 + 0x0084) (UCB 0xAF404000 + 0x41E8)\nTuning Protection Configuration\nField Bits Type Description TP 1 rh Tuning Protection BML [9:8] rh Boot Mode Lock\n0: c启动评估 HWCFG 引脚 SWAPEN [17:16] rh Enable SOTA mode CPUxDDIS\n(x=0-5) x+18 rh Disable direct LPB(Local PFlash Bank) access UCB [31:24]\n[15:10]\n[7:1] rh Reserved for UCB SCU_STMEM1 (SCU 0xF0036000 + 0x0184)\nTuning Protection Configuration\nField Bits Type Description 1 0 r Reserved BMI_VALID 1 r BMI valid flag BOOT_PIN 2 r Configuration from HWCFG pins flag BMHD_COPY 3 r Valid BMHD Copy flag ( ORIG / COPY ) BMHD_INDEX [5:4] r Index of the valid BMHD(0-3) BOOT_CFG [8:6] r Start-up mode effectively taken by SSW (Flash/BSL/ASC/Can BSL) SCRDIS 9 r SCR disabled flag BOOTMODE_CONFIGURED 10 r Boot Mode Configured flag\n(BMHDx/pins by the last SSW execution) RES [13:11] r Reserved HARREQ 14 r Halt-After-Reset REQuest flag RES 15 r Reserved SWAP_CFG [17:16] r SWAP configuration SWAP_TARGET 18 r UCB_SWAP used for configuration flag (ORIG or COPY) SWAP_DW_INDEX [23:19] r Offset from UCB_SWAP_ORIG/COPY begin RES [31:24] r Reserved HF_CONFIRM0 Flash Confirm Status Register 0\nPROINBMHDxO (0-3)\nPROINBMHDxC (0-3)\nPROINSSW\nPROINUSER\nPROINTEST\nPROINSRT\nHF_CONFIRM1 Flash Confirm Status Register 1\nHF_CONFIRM2 Flash Confirm Status Register 2\nPROINOTPxC (0-7)\nPROINOTPxO (0-7)\nUCB (User Configuration Block) 0xAF40000 - 0xAF405FFF 24 Kbyte\nTC3xx芯片在启动时会运行固化在芯片内部的名为SSW的软件 SSW软件在运行时可以读取用户的配置信息来进行特定化的启动操作，比如 SSW运行完后跳转到客户应用程序的起始地址 RAM是否需要进行初始化等 是否需要进行LBIST操作等。 而这些可以让用户自定义的配置就是UCB的配置内容 运行时可以对系统行为进行调整或保护 Register Address Space\nModule Base Address End Address Note UCB AF400000H AF405FFFH 24kB in Data Flash 0 UCB(DF0) UCB Confirmation State Value Description UNLOCKED 0x43211234 Delivery State CONFIRMED 0x57B5327F Operational State ERASED 0x00000000 Erased State ERRORED Others Errored State UCB_BMHD0_ORIN/COPY功能详细分析 UCB_BMHD0_ORIN和UCB_BMHD0_COPY用来配置Boot Mode Headers (BMHD)，SSW程序在启动时会读取UCB_BMHD0_ORIN和UCB_BMHD0_COPY配置信息进行评估，然后执行对应的操作 UCB00 Boot Mode Header(BMHD): 4块 PINDIS: 是否可以通过HWCFG pins外部配置Start-up mode HWCFG：程序的Start-up mode选择，比如配置为111B则SSW介绍后直接跳转到Checker Software LSENAx: 配置是否使能CPUx的Lockstep monitoring LBISTENA: 配置是否在SSW执行LBIST CHSWENA:配置SSW程序结束后是否执行CHSW STAD:如果是ABM启动，则为Alternate Boot Mode Header的起始地址；如果为Internal 启动，则为用户程序的起始地址 CRCBMHD: 是BMI + BMHDID +STAD值的CRC32校验值 CRCBMHD_N: 是BMI + BMHDID +STAD反向值的CRC32校验值 PW0-PW7: 给UCB_BMHD0_ORIN和UCB_BMHD0_COPY安装（Install）密码（Password），如果我们在运行时想要修改UCB_BMHD0_ORIN和UCB_BMHD0_COPY的内容，需要通过Disable Protection指令传入Password进行match后才能修改。 1ST 553CH, UC 2ST.W 553CH, PW0 3ST.W 553CH, PW1 4ST.W 553CH, PW2 5ST.W 553CH, PW3 6ST.W 553CH, PW4 7ST.W 553CH, PW5 8ST.W 553CH, PW6 9ST.W 553CH, PW7 往Confirmation位域中写入特定的值就能让Confirmation处于：UNLOCKED, CONFIRMATION,ERASED,ERRORED四种状态之一 UCB_PFLASH_ORIG/COPY UCB16 PFLASH p Sector x Locked for Write Protection HP_PROCONPi0 (i=0-5) SxL (x=0-31) HP_PROCONPi1 (i=0-5) SxL (x=32-63) HP_PROCONPi5 (i=0-5) SxL (x=160-191)\nUCB_OTPy_ORIG/COPY (y = 0 - 7) The layout of UCB33 to UCB47 is identical to UCB32 but on different offset addresses (see Table 216) and therefore not shown here.\nUCB32 PFLASH p Sector x Locked for Forever HP_PROCONOTPi0 (i=0-5) SxROM (x=0-31) HP_PROCONOTPi1 (i=0-5) SxROM (x=32-63) HP_PROCONOTPi5 (i=0-5) SxROM (x=160-191)\nHF_PROCONTP 0xAF40 0000 + 0x41E8\nField Bits Type Description TP [0] rh Tuning Protection UCB 7:1,\n15:10,\n31:24 rh Reserved for UCB BML [9:8] rw Boot Mode Lock SWAPEN [17:16] rh Enable SOTA mode CPUxDDIS(x=0-5) [x+18] rh Disable direct LPB access UCB_SWAP_ORIG/COPY (UCB ORIG 0xAF400000 + 0x2E00) (UCB COPY 0xAF400000 + 0x3E00)\nUCB23 (x=0-15) MARKERLx SWAP [31:0]\n0x00000000, ERASED, Erased state 0x00000055, Selects standard address map 0x000000AA, Selects alternate address map MARKERHx ADDR [31:0]\nAddress of corresponding MARKERLx.SWAP entry as confirmation or erased CONFIRMATIONLx CODE [31:0]\n0x00000000, ERASED, Erased state 0x57B5327F, CONFIRMED, Confirmed code CONFIRMATIONHx ADDR [31:0]\nAddress of corresponding CONFIRMATIONLx.CODE entry as confirmation or erased 缩略词 缩写 全称 SOTA Software Updates Over The Air SPB System Peripheral Bus SRI Shared Resource Interconnect BBB Back Bone Bus PSPR Program Scratch-Pad SRAM DSPR Data Scratch-Pad SRAM BROM Boot ROM SSW Startup Software BMHD Boot Mode Headers CHSW Check Software LBIST Logic Built-in-Self-Test ABM Alternate Boot Modes SCU System Control Units BSL Bootstrap Loaders LPB local Pflash BanK 参考 基于Aurix TC3xx SWAP机制（A/B分区）的SOTA实现\ndemo-Aurix-TC387-SWAP\nAURIX-TC3xx基于以太网的OTA研究与实现\nAB SWAP on Aurix TriCore platform for OTA\n","date":"2025年8月13日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/tricore/sota/","series":[],"smallImg":"","tags":[{"title":"Tricore","url":"/tags/tricore/"}],"timestamp":1755062212,"title":"Ota"},{"authors":[],"categories":[],"content":"系统安装相关的记录\n工具 Ventoy: 一个制作可启动U盘的开源工具\n一个非常方便使用的工具，放入不同镜像，直接可以启动，不再有重复制作启动盘的烦恼\nu盘安装后续支持升级，不会破坏U盘内部iso文件\n微PE工具箱\nHotPE 工具箱: 一个制作可启动U盘的开源工具, 可上网，可配置插件\n运行装载为ISO文件\n启动盘 使用Ventoy省去多次制作u盘的繁琐，直接拷贝多个iso，如win10，微pe，HotPe等\nboot启动 Legacy 引导模式 WIN8之前常见的引导模式 MBR磁盘格式,系统只能安装在MBR格式磁盘 最多4个主分区 不支持2TB以上的硬盘 UEFI 引导模式 相较于Legacy，编程性更好，可扩展性更好，性能更高，安全性更高 GPT磁盘格式,系统只能安装在GPT格式磁盘 最多128个分区 GPT突破2TB限制，支持最高18EB win10镜像下载 Media Creation Tool https://www.microsoft.com/zh-cn/software-download/windows10 立即下载工具 打开exe， 为另一台电脑创建安装介质（U盘，DVD或ISO文件） 语言，版本以及体系结构 介质选择ISO文件 获取镜像ISO直接下载链接 https://www.microsoft.com/zh-cn/software-download/windows10 修改浏览器的UA为非win系统，如iphone se，刷新 选择版本 win10，中文，64bit下载 MSDN我告诉你 https://msdn.itellyou.cn/\nUUP专制ISO https://uup.rg-adguard.net/index.php, 没有用过\n联想 nec8 装机 开机F12，bios U盘启动 进入微pe 无损分区助手 快速硬盘分区，GPT+3分区 打开win10 iso 执行setup安装系统 硬件设备 准系统 i3-8100 90w电源 intel 9260AC usb蓝牙 32G+2T ","date":"2025年8月10日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/misc/bootable_usb/","series":[],"smallImg":"","tags":[],"timestamp":1754832411,"title":"系统安装"},{"authors":[],"categories":[],"content":"网络相关的配置，操作等\n常用命令 ifdown wan; ifup wan\ncat /proc/net/nf_conntrack 查看链接\niptable filter nat mangle raw security\niptables -t nat -L input_rule -n -v \u0026ndash;line-numbers\niptables -D input_rule 2\niptables -F input_rule\niptables -t nat -A POSTROUTING -s 172.22.22.0/24 -d 192.168.1.0/24 -j MASQUERADE\niptables -I FORWARD 1 -s 192.168.1.100 -p udp \u0026ndash;sport 30000:40000 -j DROP\nwireguard install\nwindows-client\nquickstart\n1sudo apt install wireguard 2sudo sed -i \u0026#39;s/.*net\\.ipv4\\.ip_forward.*/net.ipv4.ip_forward = 1/\u0026#39; /etc/sysctl.conf 3sysctl -p 4cd /etc/wireguard 5wg genkey | tee server_privatekey | wg pubkey \u0026gt; server_publickey 6wg genkey | tee client_privatekey | wg pubkey \u0026gt; client_publickey 7 8echo \u0026#34; 9[Interface] 10PrivateKey = $(cat server_privatekey) 11Address = 10.0.8.1/24 12PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 13PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -D FORWARD -o wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE 14ListenPort = port 15# DNS = 1.1.1.1 16[Peer] 17PublicKey = $(cat client_publickey) 18AllowedIPs = 10.0.8.100/32 \u0026#34; \u0026gt; wg0.conf 19\u0026gt; eth0 根据情况适配，一定是当前使用的网卡的，否则无法访问局域网内的其他设备 20\u0026gt; 如有线、无线切换的时候注意更改 21\u0026gt; NAT port1 -\u0026gt; port2 22 23sudo systemctl enable wg-quick@wg0 24# 启动WireGuard 25wg-quick up wg0 26# 停止WireGuard 27wg-quick down wg0 28# 查看wireguard服务端运行状态 29wg 30 31echo \u0026#34; 32[Interface] 33 PrivateKey = $(cat client_privatekey) 34 Address = 10.0.8.100/32 35 DNS = 1.1.1.1 36[Peer] 37 PublicKey = $(cat server_publickey) 38 Endpoint = ip:port 39 AllowedIPs = 10.0.8.0/24, 172.22.22.0/24 40 PersistentKeepalive = 25 \u0026#34; \u0026gt; client.conf 41 42 43sudo ufw allow port/udp 44sudo ufw allow ssh 45sudo ufw enable 46sudo ufw status 47 48# 测试端口 49nc -u IP port 50 51grep \u0026#34;Failed password\u0026#34; /var/log/auth.log openwrt 1opkg install wireguard-tools kmod-wireguard luci-proto-wireguard luci-app-wireguard 2 3cat /etc/config/network 4config interface \u0026#39;wg0\u0026#39; 5 option proto \u0026#39;wireguard\u0026#39; 6 option private_key \u0026#39;xxx\u0026#39; 7 list addresses \u0026#39;10.0.0.2/32\u0026#39; 8 list dns \u0026#39;1.1.1.1\u0026#39; 9 10config wireguard_wg0 11 option description \u0026#39;导入对端配置\u0026#39; 12 option public_key \u0026#39;xxx\u0026#39; 13 list allowed_ips \u0026#39;10.0.0.0/24\u0026#39; 14 list allowed_ips \u0026#39;10.1.0.0/24\u0026#39; 15 option persistent_keepalive \u0026#39;25\u0026#39; 16 option endpoint_host \u0026#39;domain.com\u0026#39; 17 option endpoint_port \u0026#39;port\u0026#39; 18 option route_allowed_ips \u0026#39;1\u0026#39; 19 20cat /etc/config/firewall 21config zone 22 option name \u0026#39;lan\u0026#39; 23 option input \u0026#39;ACCEPT\u0026#39; 24 option output \u0026#39;ACCEPT\u0026#39; 25 option forward \u0026#39;ACCEPT\u0026#39; 26 list network \u0026#39;lan\u0026#39; 27 list network \u0026#39;wg0\u0026#39; 28 29# 防火墙配置all局域网设备通过 wg 30config zone 31 option name \u0026#39;wg\u0026#39; 32 option input \u0026#39;ACCEPT\u0026#39; 33 option output \u0026#39;ACCEPT\u0026#39; 34 option forward \u0026#39;REJECT\u0026#39; 35 option masq \u0026#39;1\u0026#39; 36 option mtu_fix \u0026#39;1\u0026#39; 37 list network \u0026#39;wg0\u0026#39; 38 39config forwarding 40 option src \u0026#39;lan\u0026#39; 41 option dest \u0026#39;wg\u0026#39; 42 43# 防火墙配置部分设备通过 wg 44# https://openwrt.org/docs/guide-user/firewall/firewall_configuration 45 46config zone 47 option name \u0026#39;wg\u0026#39; 48 option input \u0026#39;ACCEPT\u0026#39; 49 option output \u0026#39;ACCEPT\u0026#39; 50 option forward \u0026#39;REJECT\u0026#39; 51 option masq \u0026#39;1\u0026#39; 52 option mtu_fix \u0026#39;1\u0026#39; 53 list network \u0026#39;wg0\u0026#39; 54 55#config forwarding 56# option src \u0026#39;lan\u0026#39; 57# option dest \u0026#39;wg\u0026#39; 58 59config rule 60 option name \u0026#39;allow_192_168_0_200/201_to_vpn\u0026#39; 61 option src \u0026#39;lan\u0026#39; 62 option src_ip \u0026#39;192.168.0.200/31\u0026#39; 63 option dest \u0026#39;wg\u0026#39; 64 option target \u0026#39;ACCEPT\u0026#39; NanoPi 2 cat /sys/devices/platform/board/info\n板子信息查看 内核代码编译\nwireguard-linux-compat\n低版本内核准备的兼容实现 交叉编译工具： gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf\n编译内核 make ARCH=arm nanopi2_linux_defconfig\n编译 wireguard.ko\n主要注意问题：insmode wireguard 如果有错误， dmesg 分析一下\n依赖另外两个 ip6_udp_tunnel.ko udp_tunnel.ko 如果不想编译的话，可以 find /usr/lib/modules/$(uname -r) 下是否有ko ddns ddns-cf-v4.sh\nconfig.json\n1{ 2 \u0026#34;CFKEY\u0026#34;:\u0026#34;xxxxxx\u0026#34;, 3 \u0026#34;CFUSER\u0026#34;:\u0026#34;xxx@xxx.com\u0026#34;, 4 \u0026#34;CFDOMAIN\u0026#34;:[ 5 \u0026#34;xxx.yyy\u0026#34; 6 ] 7} ShellCrash https://github.com/juewuy/ShellCrash\n在线安装：只是引用的文件源不同\n0 3 * * 3 /etc/ShellCrash/task/task.sh 104 在每周3的3点整更新订阅并重启服务\n0 3 * * 5 /etc/ShellCrash/task/task.sh 113 在每周5的3点整自动更新数据库文件\nmeta内核 2-1 : 查看当前的内核 2-1-3 : Tproxy模式 2-1-7 : 3 劫持局域网+本机流量 2-2 : 1 fake-ip 3 mix混合模式 2-2-4 : 7 禁用DNS劫持，自定义dns服务器 2-9 : Fake-ip过滤列表 /etc/ShellCrash/configs/fake_ip_filter 4-1 : 允许ShellCrash开机启动 5-7 : 自动保存面板配置 周3的3点整更新订阅 自动同步ntp时间 6-1 : 订阅相关 6-1-4 : 配置规则 6-6-2 : 自定义规则 /etc/ShellCrash/yamls/rules.yaml 9-4-2 : 面板 https://github.com/MetaCubeX/metacubexd ui面板 8-2 : 切换内核singbox config configs/ShellCrash.cfg\n1#ShellCrash配置文件，不明勿动！ 2versionsh_l=1.9.2beta4 3firewall_mod=iptables 4update_url=https://fastly.jsdelivr.net/gh/juewuy/ShellCrash@master 5userguide=1 6redir_mod=混合模式 7cn_ip_route=已开启 8dns_nameserver=\u0026#39;https://223.5.5.5/dns-query, https://doh.pub/dns-query, tls://dns.rubyfish.cn:853\u0026#39; 9dns_fallback=\u0026#39;https://223.5.5.5/dns-query, https://doh.pub/dns-query, tls://dns.rubyfish.cn:853\u0026#39; 10Https= 11Url=\u0026#39;https://|https://\u0026#39; 12cpucore=armv7 13crashcore=meta 14core_v=v1.19.11 15geosite_v=20250707 16mrs_geosite_cn_v=20250707 17china_ip_list_v=20250707 18china_ipv6_list_v=20250707 19Country_v= 20cn_mini_v=20250707 21hostdir=\u0026#39;:9999/ui\u0026#39; 22# exclude=\u0026#39;免费|计费\u0026#39; url 编码 23exclude=\u0026#39;%E8%AE%A1%E8%B4%B9%7C%E5%85%8D%E8%B4%B9\u0026#39; 24# 6-1-5 选取在线生成服务器 25server_link=1 26# 6-1-4 选取在线配置规则模版 27rule_link=1 fakeip configs/fake_ip_filter\n1snapdrop.net 2canyouseeme.org 3*.*.gov.cn yamls yamls/rules.yaml\n1- DOMAIN,snapdrop.net,DIRECT 2- DOMAIN,stun.l.google.com,DIRECT 3- DOMAIN-SUFFIX,canyouseeme.org,DIRECT 4- DOMAIN-KEYWORD,spaceship,DIRECT 5- DOMAIN-KEYWORD,chatgpt,AiGpt 6- DOMAIN-KEYWORD,grok.com,AiGpt 7- DOMAIN-KEYWORD,reddit.com,AiGpt yamls/proxy-groups.yaml\n1 - name: AiGpt 2 type: fallback 3 url: \u0026#39;https://chatgpt.com/favicon.ico\u0026#39; # 根据情况修改 4 interval: 300 5 proxies: 6 - 新加坡A02 7 - 新加坡A03 | IEPL | x2 clashverge https://www.clashverge.dev/friendship.html\n去广告仓库\nax1800 pro 刷机 https://github.com/lgs2007m/Actions-OpenWrt.git\nJDCloud-AX1800-Pro_AX6600-Athena.md\n雅典娜需要T10梅花内六角带孔\n拆机，上部螺丝，底部2层螺丝\n拆散热片，拆天线\n短接两点和地上电，输入com口，两次重连电脑之后(等3-5s), 回车继续，红灯亮起立马按reset，然后绿灯亮松开 是打开的ram中的uboot http://192.168.1.1/ ，先刷入2181降级获取ssh，刷uboot，后续可以自主更新固件\n重新进入uboot，先按住reset然后上电，红色闪 变绿 http://192.168.1.1/ ，wan，lan口都可\nhttp://192.168.1.1/uboot.html 是可以直接刷入uboot的 上传之前的旧固件（2181）即可开启老固件ssh功能\n可直接刷第三方固件\nhttps://dl.openwrt.ai/packages-23.05/aarch64_cortex-a53/ https://fw.koolcenter.com/Lean/JDC_AX1800_Pro/ 关led灯 echo 0 | tee /sys/class/leds/led_g1/brightness\n恢复跑分\n先op、startos安装sgdisk然后 最后一个分区有的话删除 fdisk d sgdisk -e -n 0:0:0 -c 0:storage -t 0:1B1720DA-A8BB-4B6F-92D2-0A93AB9609CA -p /dev/mmcblk0 新建分区，重启reboot 上传之后的备份文件24-26，刷回即可 刷原厂 存储设置内置存储为本地网盘，然后直接恢复出厂，智能加速服务 1dd if=/dev/zero of=$(blkid -t PARTLABEL=0:ETHPHYFW -o device) conv=fsync 2dd if=/mnt/mmcblk0p27/mmcblk0p24_plugin.bin of=$(blkid -t PARTLABEL=plugin -o device) conv=fsync 3dd if=/mnt/mmcblk0p27/mmcblk0p25_log.bin of=$(blkid -t PARTLABEL=log -o device) conv=fsync 4swapoff $(blkid -t PARTLABEL=swap -o device) 5dd if=/mnt/mmcblk0p27/mmcblk0p26_swap.bin of=$(blkid -t PARTLABEL=swap -o device) conv=fsync 6swapon $(blkid -t PARTLABEL=swap -o device) 优化 /sbin/jd_online_upgrade.sh，disable upgrade jd-firmware 权限 0 /etc/dropbear/authorized_keys， 600， ssh-rsa iptables -L MINIUPNPD -v -n \u0026ndash;line-numbers -t nat /etc/config/upnpd 配置黑名单没生效，/tmp/upnp.leases /opt/1.5.80.r2262 \u0026ndash;\u0026gt; jd_h.sh ax1800 ramips mt7621\n拆机，底部三个螺丝 串口在有三颗螺丝的铝块散热器下面 波特率115200 串口 U-Boot SPL 2018.09 (Sep 06 2022 - 22:06:27 +0800) Trying to boot from NOR U-Boot 2018.09 (Sep 06 2022 - 22:06:27 +0800) CPU: MediaTek MT7621AT ver 1, eco 3 Clocks: CPU: 880MHz, DDR: 1200MHz, Bus: 220MHz, XTAL: 40MHz Model: MediaTek MT7621 reference board DRAM: 448 MiB MMC: mmc@1e130000: 0 Loading Environment from SPI Flash... SF: Detected whxx25q128 with page size 256 Bytes, erase size 64 KiB, total 16 MiB OK In: uartlite0@1e000c00 Out: uartlite0@1e000c00 Err: uartlite0@1e000c00 Net: Warning: eth@1e100000 (eth0) using random MAC address - 5e:69:c8:f8:cf:5b eth0: eth@1e100000 Saving Environment to SPI Flash... SF: Detected whxx25q128 with page size 256 Bytes, erase size 64 KiB, total 16 MiB Erasing SPI flash...Writing to SPI flash...done OK disabled console and autoboot in 0 seconds ++++++++++++++upgradeFlag= rest gpio value=0 (Low Level effective) clock is disabled (0Hz) selecting mode MMC legacy (freq : 0 MHz) clock is enabled (49019Hz) selecting mode MMC legacy (freq : 25 MHz) mmc: widths [8, 4, 1] modes [MMC legacy, MMC High Speed (26MHz), SD High Speed (50MHz), MMC High Speed (52MHz), MMC DDR52 (52MHz), HS200 (200MHz)] host: widths [4, 1] modes [MMC legacy, SD Legacy, MMC High Speed (26MHz), SD High Speed (50MHz)] clock is enabled (25000000Hz) trying mode MMC High Speed (26MHz) width 4 (at 26 MHz) selecting mode MMC High Speed (26MHz) (freq : 26 MHz) clock is enabled (25000000Hz) filename=backup.img ** Unable to read file backup.img ** fs_read backup.img failed copy_form_sd failed jdboot - goto jd boot Usage: jdboot =\u003e printenv baudrate=115200 bootcmd=jdboot bootcount=1 bootdelay=2 bootlimit=3 ipaddr=192.168.68.1 netmask=255.255.255.0 serverip=192.168.68.10 stderr=uartlite0@1e000c00 stdin=uartlite0@1e000c00 stdout=uartlite0@1e000c00 Environment size: 209/65532 bytes 连接ttl之后串口如上，无法输入命令，但是呢无法输入不代表不能进入uboot，按下reset之后上电即可在串口中输入命令, 完整操作过程如下：\n降级解锁ssh 1=\u0026gt; mtkupgrade 2 3Available parts to be upgraded: 4 0 - Bootloader 5 1 - Bootloader (Advanced) 6 2 - Firmware 7 8Select a part: 2 9 10*** Upgrading Firmware *** 11 12Available load methods: 13 0 - TFTP client (Default) 14 1 - Xmodem 15 2 - Ymodem 16 3 - Kermit 17 4 - S-Record 18 19Select (enter for default): 0 20 21Input U-Boot\u0026#39;s IP address: 192.168.68.1 22Input TFTP server\u0026#39;s IP address: 192.168.68.10 23Input IP netmask: 255.255.255.0 24Input file name: JDCOS.bin 25 26Using eth@1e100000 device 27TFTP from server 192.168.68.10; our IP address is 192.168.68.1 28Filename \u0026#39;JDCOS.bin\u0026#39;. 29Load address: 0x80010000 30Loading: T ################################################################# 31 ################################################################# 32 ################################################################# 33 ################################################################# 34 ################################################################# 35 ################################################################# 36 ################################################################# 37 ################################################################# 38 ################################################################# 39 ################################################################# 40 ################################################################# 41 ################################################################# 42 ################################################################# 43 ################################################################# 44 ################################################################# 45 ####################################### 46 1.6 MiB/s 47done 48Bytes transferred = 14877400 (e302d8 hex) 49 50*** Loaded 14877400 (0xe302d8) bytes at 0x80010000 *** 51 52SF: Detected whxx25q128 with page size 256 Bytes, erase size 64 KiB, total 16 MiB 53 54Erasing from 0x90000 to 0xecffff, size 0xe40000 ... OK 55Writting from 0x80010000 to 0x90000, size 0xe302d8 ... OK 56 57*** Firmware upgrade completed! *** 先升级 JDCOS.bin(JDC03-3.1.1.r1911), 此版本网页登录解锁ssh，然后备份分区，刷写uboot u-boot-mt7621-68.bin\n备份分区，刷uboot $.ajax({ url: 'http://' + $.cookie(\"HostAddrIP\") + '/jdcapi', async: false, data: JSON.stringify({ jsonrpc: \"2.0\", id: 1, method: \"call\", params: [ $.cookie(\"sessionid\"), \"service\", \"set\", { \"name\": \"dropbear\", \"instances\": {\"instance1\": {\"command\": [\"/usr/sbin/dropbear\"]}} } ] }), dataType: 'json', type: 'POST' }) root@JDBoxV3:/tmp/123# cat /proc/mtd dev: size erasesize name mtd0: 00040000 00010000 \u0026ldquo;Bootloader\u0026rdquo; mtd1: 00010000 00010000 \u0026ldquo;Config\u0026rdquo; mtd2: 00040000 00010000 \u0026ldquo;Factory\u0026rdquo; mtd3: 00f70000 00010000 \u0026ldquo;firmware\u0026rdquo; mtd4: 003c0000 00010000 \u0026ldquo;kernel\u0026rdquo; mtd5: 00bb0000 00010000 \u0026ldquo;rootfs\u0026rdquo; mtd6: 00140000 00010000 \u0026ldquo;rootfs_data\u0026rdquo;\ndd if=/dev/mtd0 of=/tmp/123/mtd0_bk.bin dd if=/dev/mtd1 of=/tmp/123/mtd1_bk.bin dd if=/dev/mtd2 of=/tmp/123/mtd2_bk.bin dd if=/dev/mtd3 of=/tmp/123/mtd3_bk.bin dd if=/dev/mtd4 of=/tmp/123/mtd4_bk.bin dd if=/dev/mtd5 of=/tmp/123/mtd5_bk.bin dd if=/dev/mtd6 of=/tmp/123/mtd6_bk.bin\nroot@JDBoxV3:/tmp/123# mtd write u-boot-mt7621-68.bin /dev/mtd0 Unlocking /dev/mtd0 \u0026hellip;\nWriting from u-boot-mt7621-68.bin to /dev/mtd0 \u0026hellip; root@JDBoxV3:/tmp/123# root@JDBoxV3:/tmp/123#reboot 刷openwrt 重新进入uboot，按键joy上电，进入uboot，网线直连lan口，打开192.168.68.1 然后选择sysupgrade.bin文件刷openwrt\n刷原厂固件 直接进入uboot升级原厂固件,如JDC03-3.1.1.r1911 把之前备份的分区文件重新刷回 ipk下载 1# 版本架构 2uname -a 3opkg print-architecture 4cat /proc/cpuinfo 5 6# 根据需要修改版本架构等 7https://downloads.openwrt.org/releases/packages-23.05/mipsel_24kc/sha256sums 8 9https://downloads.openwrt.org/releases/17.01.1/targets/ramips/mt7621/packages/kmod-wireguard_4.4.61+0.0.20170115-1_mipsel_24kc.ipk 10https://downloads.openwrt.org/releases/17.01.1/packages/mipsel_24kc/base/iperf3_3.1.4-1_mipsel_24kc.ipk 11 12https://downloads.openwrt.org/snapshots/targets/ 13 14https://dl.openwrt.ai/packages-23.05/mipsel_24kc/packages/ 定制固件 immortalwrt, 如型号：re-cp-02，版本：23.05.6\nimmortalwrt-23.05.6-bf550ba2533a-ramips-mt7621-jdcloud_re-cp-02-squashfs-sysupgrade.bin\n/etc/distfeeds.conf src/gz immortalwrt_core https://mirrors.vsean.net/openwrt/releases/23.05.6/targets/ramips/mt7621/packages src/gz immortalwrt_base https://mirrors.vsean.net/openwrt/releases/23.05.6/packages/mipsel_24kc/base src/gz immortalwrt_kmods https://mirrors.vsean.net/openwrt/releases/23.05.6/targets/ramips/mt7621/kmods/5.15.189-1-d57570949c8e4ee79b82936a52c330d9 src/gz immortalwrt_luci https://mirrors.vsean.net/openwrt/releases/23.05.6/packages/mipsel_24kc/luci src/gz immortalwrt_packages https://mirrors.vsean.net/openwrt/releases/23.05.6/packages/mipsel_24kc/packages src/gz immortalwrt_routing https://mirrors.vsean.net/openwrt/releases/23.05.6/packages/mipsel_24kc/routing src/gz immortalwrt_telephony https://mirrors.vsean.net/openwrt/releases/23.05.6/packages/mipsel_24kc/telephony 校验关闭 /etc/opkg.conf 文件中删除 option check_signature\nkernel依赖问题，可以通过升级kernel解决，但是lsmod可能还是找不到\nFAQ 数据转发异常 分析配置port的流量，转发的ip是否正确，以及iptable的配置，数据流向是否正确\ntcpdump -i any udp port 12345 tcpdump -i eth2 host 172.22.22.12 -w test.pcap conntrack -L | grep 12345 # 连接查看 conntrack -D -p udp --sport 12345 conntrack -D -p udp --dport 12345 iptables-save \u003e iptables-backup.txt iptables -t filter -L -n \u003e filter.txt iptables -t nat -L -n \u003e nat.txt iptables -t mangle -L -n \u003e mangle.txt iptables -t raw -L -n \u003e raw.txt iptables -t security -L -n \u003e security.txt DNS /etc/systemd/resolved.conf\n[Resolve] DNS=1.1.1.1 FallbackDNS=8.8.8.8 DNSStubListener=no sudo systemctl restart systemd-resolved\n","date":"2025年8月2日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/misc/router/","series":[{"title":"Router","url":"/series/router/"}],"smallImg":"","tags":[],"timestamp":1754106870,"title":"Router"},{"authors":[],"categories":[{"title":"网络通信","url":"/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"content":" 理想的开源代码 mvbs\nhttps://gitee.com/haloos/vbslite_mvbs\n代码仓库简介 MVBS，全称为 Micro Vehicle Bus Service，是VBSLite工程的核心组件之一 面向MCU领域设计的通信中间件，实现资源受限环境下的高效业务互联互通 主要采用以数据为中心的发布-订阅（DCSP, Data-Centric Publish Subscribe）通信模型 并通过RTPS协议进行数据传输，提供低时延、高可靠的数据通信，同时支持若干必要的QoS策略 提供RPC（Remote Function Call）功能，支持请求-调用通信模型，构建支持多种通信模式的统一通信平台 MVBS特性\n实现RTPS标准最小子集 MVBS符合协议规范但仅实现RTPS标准中最小子集 精简行为部分实现协议中的stateless与stateful两种参考分别可以为best-effort和reliable两种通信可靠性提供协议支持 精简的实体：participant、writer、reader 精简的QoS（8种规范QoS+1种自定义QoS） 支持自定义子消息 实现对E2E报文的支持 互操作性 MVBS协议可以和外部RTPS Entity进行相互操作 容错恢复 单点故障不影响网络通信 重启后可以重新加入通讯网络，继续通信 支持Reliability QoS进行可靠传输 较低的资源消耗 支持动态和静态发现 支持RPC通信模式 代码目录 vbslite_mvbs 源代码在 haloosspace/vbs/vbslite/mvbs 目录下，目录结构如下图所示：\nmvbs ├── README.md # 这个是MVBS仓库的readme ├── build.mk # 用于构建的makefile文件 ├── CMakeLists.txt # cmake编译脚本 ├── posix_aux # 为linux和windows平台提供扩展支持库 ├── include │ ├── mcdr # 序列化接口 │ ├── mvbs # MVBS头文件集合 │ │ ├── adapter # 适配层头文件 │ │ ├── core # MVBS内部核心的实体定义和操作 │ │ ├── diag # 诊断相关的头文件 │ │ ├── rte # RTE接口文件 │ │ ├── rtps # RTPS协议元素定义文件 │ │ ├── sections # 用于支持内存layout │ │ └── utils # 常用的工具文件 │ └── rpc # RPC头文件 └── src ├── adapter # 适配层实现 │ ├── auto # 基于VCOS 适配层的参考实现 │ └── posix # 基于POSIX提供的适配层实现 ├── core │ ├── diag # 诊断工具的实现 │ ├── discovery # 实体发现协议的实现 │ ├── entities # MVBS内部实体的实现 │ ├── include # 提供给MVBS内部的头文件 │ ├── messages # 报文组装的实现 │ ├── mvbs # MVBS内部接口层的实现 │ ├── netio # 网络接口的封装实现 │ ├── qos # E2E和WLP的实现 │ ├── storages # CacheChange和History的实现 │ ├── transport # Transport的实现 │ └── utils # 常用工具的实现 ├── mcdr # 序列化库的实现 ├── rpc # RPC的实现 └── rte # RTE接口的实现 仓库使用入门 参考 VBS开发者手册 —— 快速入门\nmvbs搭建 https://gitee.com/haloos/manifests 通过repo的方式管理多个仓库\n注：window根据上述文档配置，安装msys2， 安装windows平台编译工具，安装python的依赖库\n1├── build 2├── docs 3├── examples 4├── Makefile 5├── mvbs 6├── tools 7└── vbs 编译命令 进入顶层目录之后执行如下命令：\n1source build/envsetup.sh 2lunch MINGW 3mma -j8 vscode debug msys64终端安装gdb\npacman -S mingw-w64-x86_64-gdb\n安装 C/C++ 扩展\nvscode 中配置 launch.json\n1{ 2 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, 3 \u0026#34;configurations\u0026#34;: [ 4 { 5 \u0026#34;name\u0026#34;: \u0026#34;msys\u0026#34;, 6 \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, 7 \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, 8 \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}\\\\vbslitespace\\\\out\\\\MINGW\\\\objs\\\\udp_test_sub\\\\udp_test_sub.exe\u0026#34;, // 根据你的路径修改，需要调试的程序的路径 9 \u0026#34;args\u0026#34;: [], 10 \u0026#34;stopAtEntry\u0026#34;: false, 11 \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, 12 \u0026#34;environment\u0026#34;: [], 13 \u0026#34;externalConsole\u0026#34;: false, 14 \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, 15 \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;D:\\\\App\\\\msys64\\\\mingw64\\\\bin\\\\gdb.exe\u0026#34;, // 根据你的路径修改 16 \u0026#34;setupCommands\u0026#34;: [ 17 { 18 \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, 19 \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, 20 \u0026#34;ignoreFailures\u0026#34;: true 21 }, 22 { \u0026#34;text\u0026#34;: \u0026#34;set output-radix 16\u0026#34; } // 16进制显示变量 23 ] 24 } 25 ] 26} 源代码 SPDP ptcp_spdp_writer_send_pdp\n启动发送广播自己上线 周期广播自己在线 回复其他participate自己存在 1// 启动广播 2main 3 app_init 4 Rte_Dds_Init 5 ptcp_enable 6 ptcp_discovery_start 7 ptcp_dpde_discovery_start 8 ptcp_spdp_announce_online 9 ptcp_spdp_writer_send_pdp liveliness_lost ptcp_proxy_liveliness_lost writer_remove_proxy writer_remove_proxies_with_ptcp\nSEDP 1main 2 Rte_Dds_Ptcp_Recv_Handler 3 ptcp_recv_handler 4 udp_trans_recv_handle 5 msg_recv_process 6 msg_recv_process_submsg (收到 ACKNACK 报文) 7 msg_recv_process_submsg_acknack 8 ptcp_dpde_on_acknack 9 sub_writer_on_acknack （填充endpoint信息） 10 udp_trans_sendto 11 udp_trans_send 12 mvbs_udp_socket_sendto 13 mvbs_udp_send 数据接收 接收回调\nmvbs_net_rx_indication (根据配置进入tcp/udp接收处理函数) udp_trans_recv_indication udp_rx_buffer_put_pkg (数据放入buf缓冲区) 1main 2 Rte_Dds_Ptcp_Recv_Handler 3 ptcp_recv_handler 4 udp_trans_recv_handle (buf缓冲区取数据) 5 ptcp_recv_cb 6 ptcp_process_new_message 7 msg_recv_process 8 msg_recv_process_submsg 消息分类 9 msg_recv_process_submsg_data (DATA) 10 ptcp_dpde_on_data 11 ptcp_pdp_reader_on_data 12 ptcp_proxy_parse 13 cdr_deserialize_ptcp_proxy (返回值判断是否new ptcp) 14 ptcp_pdp_reader_data_process （上面返回ok，才会继续） 15 ptcp_spdp_create_ptcp_proxy (Add new ptcp) 数据发送 1Rte_Dds_TxData 2 writer_submit_sample 3 writer_submit_instance_sample 4 writer_new_change 5 writer_send_data 6 writer_send_wcc （没有对ptcp_send_buffer_to返回值处理，上层失败返回也是ok） 给出的示例代码中，如果有测试发送大于1500的需求时，需要改动 MVBS_UDP_TXBUFSIZE / MVBS_UDP_RXBUFSIZE 的大小\n数据缓存处理 fifo buf：生成配置文件中 udp_ringbuff 数据接收之后：data之前加上一个管理头 struct udp_pack_info\n抓包实例 udp_test_sub_pub.pcapng\napp1: meta多播端口: 7400 meta单播端口: 7410 数据单播端口: 7411 app2: meta多播端口: 7400 // 同一个domain 所以相同 meta单播端口: 7412 数据单播端口: 7413 APP1: 7411 \u0026ndash;\u0026gt; APP2 : 7412，此报文和app1发送的发现组播报文(Frame:43)除了目的ip和端口外其他都是相同的数据\nAPP2: 7413 \u0026ndash;\u0026gt; APP1 : 7410 同样发送单播发现报文\nAPP1 -\u0026gt; APP2 通过 SEDP 协议发送广播的主题，Qos，deadline， liveliness等信息\nAPP2 -\u0026gt; APP1 通过 SEDP 协议发送订阅的主题\nAPP1 -\u0026gt; APP2 发送数据\n上位机 环境搭建 windows需要安装msys2，可从 www.msys2.org 下载最新版本的 msys2 安装包进行安装，需在msys2环境中进行编译\n1pacman -Syu 2pacman -S libevent 3pacman -S mingw-w64-x86_64-toolchain 4pacman -S mingw-w64-ucrt-x86_64-python mingw-w64-ucrt-x86_64-python-pip 5pacman -S make mingw-w64-ucrt-x86_64-make 1# 安装python依赖 2 3crcmod==1.7 4pcpp==1.30 5Jinja2==3.1.2 6antlr4-python3-runtime==4.13.0 7xmltodict==0.13.0 8ply==3.11 获取代码 1mvbs_app 2├── lib 3│ ├── libmvbs.a 4│ └── libmvbs_aux.a 5├── Makefile 6├── mvbs # 头文件 7├── src # 此文件夹中的 idl 和 xml 有且只有一个 8│ ├── HelloWorld.idl # 数据配置idl文件 9│ ├── pub_config.xml # mvbs的配置文件 10│ └── pub_test.c # 用户测试代码 11└── tools # 工具目录后续测试，只需要调整src下面的文件，执行编译即可\n运行 执行 make 编译，然后执行，下载 test_sub 进行测试\nmvbs_app [2025-09-01 17:34:03.243] [MVBS/I] [mvbs_mm_init:596] memory initialization succeeded. [2025-09-01 17:34:03.247] [MVBS/I] [mvbs_timer_init:449] Timer resolution: 5 000us [2025-09-01 17:34:03.250] [MVBS/I] [set_multicast:194] Send multicast packag e by: ip[127.0.0.1]. socket:652 [2025-09-01 17:34:03.255] [MVBS/I] [set_multicast:208] Recv multicast packag e by: ip[127.0.0.1]. socket:652 [2025-09-01 17:34:03.260] [MVBS/I] [ptcp_guid_prefix_generate:1023] ptcp gui d_prefix: [7F 00 00 01] [00 00 00 00] [00 00 00 00] [2025-09-01 17:34:03.263] [MVBS/I] [ptcp_discovery_init:46] participant [app 1_127.0.0.1] DPDE inited successfully. [2025-09-01 17:34:03.266] [MVBS/I] [ptcp_local_comm_enable:814] Participant [app1_127.0.0.1] hasn't local communication. [2025-09-01 17:34:03.272] [MVBS/I] [ptcp_discovery_start:81] participant [ap p1_127.0.0.1] DPDE start successfully. [2025-09-01 17:34:03.276] [MVBS/I] [app_init:104] Rte_Dds_Init OK!. [2025-09-01 17:34:05.495] [MVBS/I] [ptcp_spdp_create_ptcp_proxy:204] Add new ptcp: app2_127.0.0.1 [2025-09-01 17:34:05.776] [MVBS/I] [on_event:60] \u0026mdash;\u0026mdash;\u0026ndash;tx count:1\u0026mdash;\u0026mdash;-,\n[2025-09-01 17:34:06.276] [MVBS/I] [on_event:60] \u0026mdash;\u0026mdash;\u0026ndash;tx count:2\u0026mdash;\u0026mdash;-,\n[2025-09-01 17:34:06.777] [MVBS/I] [on_event:60] \u0026mdash;\u0026mdash;\u0026ndash;tx count:3\u0026mdash;\u0026mdash;-,\ntest_sub [2025-09-01 17:34:05.361] [MVBS/I] [mvbs_mm_init:596] memory initialization succeeded. [2025-09-01 17:34:05.374] [MVBS/I] [mvbs_timer_init:449] Timer resolution: 5 000us [2025-09-01 17:34:05.389] [MVBS/I] [set_multicast:194] Send multicast packag e by: ip[127.0.0.1]. socket:712 [2025-09-01 17:34:05.404] [MVBS/I] [set_multicast:208] Recv multicast packag e by: ip[127.0.0.1]. socket:712 [2025-09-01 17:34:05.420] [MVBS/I] [mvbs_udp_bind:115] port[7410] No error [2025-09-01 17:34:05.432] [MVBS/I] [udp_trans_init_socket:284] socket bind p ort[7410] no success! [2025-09-01 17:34:05.446] [MVBS/I] [ptcp_guid_prefix_generate:1023] ptcp gui d_prefix: [7F 00 00 01] [10 10 F8 F8] [01 00 00 00] [2025-09-01 17:34:05.463] [MVBS/I] [ptcp_discovery_init:46] participant [app 2_127.0.0.1] DPDE inited successfully. [2025-09-01 17:34:05.478] [MVBS/I] [ptcp_local_comm_enable:814] Participant [app2_127.0.0.1] hasn't local communication. [2025-09-01 17:34:05.495] [MVBS/I] [ptcp_discovery_start:81] participant [ap p2_127.0.0.1] DPDE start successfully. [2025-09-01 17:34:05.511] [MVBS/I] [app_init:104] Rte_Dds_Init OK!. [2025-09-01 17:34:05.522] [MVBS/I] [ptcp_spdp_create_ptcp_proxy:204] Add new ptcp: app1_127.0.0.1 [2025-09-01 17:34:06.026] [MVBS/I] [on_event:61] \u0026mdash;\u0026mdash;\u0026ndash;rx msg[1] : sample msg = msg (0) from node1_w1\n[2025-09-01 17:34:06.536] [MVBS/I] [on_event:61] \u0026mdash;\u0026mdash;\u0026ndash;rx msg[2] : sample msg = msg (1) from node1_w1\n[2025-09-01 17:34:07.041] [MVBS/I] [on_event:61] \u0026mdash;\u0026mdash;\u0026ndash;rx msg[3] : sample msg = msg (2) from node1_w1\n","date":"2025年7月26日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/dds/mvbs/","series":[{"title":"DDS 学习系列","url":"/series/dds-%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"}],"smallImg":"","tags":[{"title":"Mvbs","url":"/tags/mvbs/"}],"timestamp":1753543244,"title":"Mvbs"},{"authors":[],"categories":[],"content":" hugo主题修改，调试等\nhugo调试技巧 hugo函数api\nHugo 官方 Markdown 指南\nShortcodes 文档\n常用调试变量/对象清单 变量/对象 说明 用法示例 .Page 当前页面对象，几乎所有页面相关信息都在这里 {{ .Page.Title }} .Params 当前页面 front matter 中的参数 {{ .Params.author }} .File 当前内容文件信息，如路径、目录、扩展名 {{ .File.Path }} .Site 站点全局信息，如站点配置、语言、菜单等 {{ .Site.Title }} .Site.Params 站点全局配置文件 config.toml 中的 [params] {{ .Site.Params.logo }} .IsHome 布尔值，是否首页 {{ if .IsHome }}首页{{ end }} .IsPage 是否为单页（单篇内容） {{ if .IsPage }}单页{{ end }} .IsSection 是否为某个内容区块（Section） {{ if .IsSection }}区块页{{ end }} .IsNode 是否为节点页面（Section 或列表页） {{ if .IsNode }}节点页{{ end }} .IsTaxonomy 是否为分类或标签列表页 {{ if .IsTaxonomy }}分类页{{ end }} .IsTaxonomyTerm 是否为分类或标签汇总页 {{ if .IsTaxonomyTerm }}汇总页{{ end }} .Title 当前页面标题 {{ .Title }} .Content 页面正文 HTML 内容 {{ .Content }} .RawContent 页面原始 Markdown 内容 {{ .RawContent }} .Date 页面发布日期 {{ .Date.Format \u0026quot;2006-01-02\u0026quot; }} .PublishDate 发布日期（如果设置） {{ .PublishDate }} .Params.images 如果 front matter 有图片列表参数 {{ range .Params.images }}{{ . }}{{ end }} .Resources 页面关联的资源，如 Page Bundle 中的图片 {{ range .Resources }}{{ .RelPermalink }}{{ end }} .Site.Menus 站点菜单配置 {{ range .Site.Menus.main }}{{ .Name }}{{ end }} 调试信息 启动调试 1nmp install 2hugo server --bind 0.0.0.0 控制台打印调试信息 1{{ warnf \u0026#34;调试信息：变量 a 的值是 %v\u0026#34; $a }} 2{{ $c := printf \u0026#34;%s%s\u0026#34; $.File.Dir $img | absURL }} 网页上直接显示变量 — printf + HTML 标签 1\u0026lt;p\u0026gt;变量 a 的值是：{{ printf \u0026#34;%v\u0026#34; $a }}\u0026lt;/p\u0026gt; 2\u0026lt;p\u0026gt;变量 a 的值是：{{ $a }}\u0026lt;/p\u0026gt; 网页上格式化复杂对象 1\u0026lt;pre\u0026gt;{{ .Params | jsonify }}\u0026lt;/pre\u0026gt; Hugo 模板如果被多次调用，定位问题 1{{- $uid := now.UnixNano -}} 2{{ warnf \u0026#34;===== uid =====: [%d] \u0026#34; $uid }} githug page —\u003e cloudfare 配置dns解析🔗 github page Enforce HTTPS 在 Cloudflare 的 DNS 设置中把 Proxy status 全部设置为 DNS Only 状态，即灰色的云朵 设置成功之后，再开启代理\ncloudfare SSL/TLS 设置 概述：Full (strict) 边缘证书：勾选始终使用 HTTPS 源服务器：勾选经过身份验证的源服务器拉取 plantuml 添加文件：layouts/_default/_markup/render-codeblock.html 1{{- $language := .Type | default \u0026#34;text\u0026#34; -}} 2{{- if eq $language \u0026#34;plantuml\u0026#34; -}} 3 \u0026lt;pre\u0026gt;\u0026lt;code class=\u0026#34;language-plantuml\u0026#34;\u0026gt;{{ .Inner | safeHTML }}\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; 4{{- else -}} 5 {{ highlight .Inner $language \u0026#34;\u0026#34; }} 6{{- end -}} 添加文件：static/js/plantuml-init.js 1const loadScript = (url, onloadFunction) =\u0026gt; { 2 var newScript = document.createElement(\u0026#34;script\u0026#34;); 3 newScript.onerror = (oError) =\u0026gt; { 4 throw new URIError(\u0026#34;The script \u0026#34; + oError.target.src + \u0026#34; didn\u0026#39;t load correctly.\u0026#34;); 5 }; 6 if (onloadFunction) { newScript.onload = onloadFunction; } 7 document.head.insertAdjacentElement(\u0026#39;beforeend\u0026#39;, newScript); 8 newScript.src = url; 9} 10 11const loadPlantUMLOnNeed = () =\u0026gt; { 12 let plantumlPrefix = \u0026#34;language-plantuml\u0026#34;; 13 14 if (document.querySelectorAll(\u0026#34;[class^=\u0026#34; + plantumlPrefix + \u0026#34;]\u0026#34;).length \u0026gt; 0) { 15 loadScript(\u0026#39;https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js\u0026#39;, () =\u0026gt; { 16 (function(){ 17 Array.prototype.forEach.call(document.querySelectorAll(\u0026#34;[class^=\u0026#34; + plantumlPrefix + \u0026#34;]\u0026#34;), function(code){ 18 let image = document.createElement(\u0026#34;IMG\u0026#34;); 19 image.loading = \u0026#39;lazy\u0026#39;; 20 image.src = \u0026#39;http://www.plantuml.com/plantuml/svg/~1\u0026#39; + plantumlEncoder.encode(code.innerText); 21 code.parentNode.insertBefore(image, code); 22 code.style.display = \u0026#39;none\u0026#39;; 23 }); 24 })(); 25 26 console.log(\u0026#34;PlantUML init done\u0026#34;); 27 }) 28 } 29} 30 31window.addEventListener(\u0026#39;load\u0026#39;, function(event) { 32 loadPlantUMLOnNeed(); 33}); 尾部添加 themes/hugo-theme-bootstrap/layouts/partials/footer.html 1\u0026lt;script src=\u0026#34;/js/plantuml-init.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 删除未引用的图片 根据路径调整line：9的位置\n1import os 2import re 3import sys 4 5referenced_images = set() 6all_image_files = set() 7 8# 遍历所有 .md 文件 9for root, _, files in os.walk(os.path.join(os.path.dirname(os.path.abspath(__file__)), \u0026#39;../content/docs\u0026#39;)): 10 for file in files: 11 if file.endswith(\u0026#39;.md\u0026#39;): 12 md_path = os.path.join(root, file) 13 md_dir = os.path.dirname(md_path) 14 15 # 图片目录为 md 文件同目录下的 images/ 16 image_folder = os.path.join(md_dir, \u0026#39;images\u0026#39;) 17 18 # 只处理存在的 images 目录 19 if not os.path.isdir(image_folder): 20 continue 21 22 # 正则匹配: ![](images/xxx.png) 23 pattern = re.compile(r\u0026#39;!\\[.*?\\]\\((images/.*?\\.\\w+)\\)\u0026#39;) 24 25 # 读取 md 文件 26 with open(md_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: 27 content = f.read() 28 29 # 提取引用图片路径，并转换为绝对路径 30 matches = pattern.findall(content) 31 for match in matches: 32 referenced_path = os.path.normpath(os.path.join(md_dir, match)) 33 referenced_images.add(referenced_path) 34 35 # 收集该目录下实际存在的 .png 图片 36 md_img_dir = os.path.splitext(os.path.join(image_folder, file))[0] 37 if os.path.isdir(md_img_dir): 38 for img_file in os.listdir(md_img_dir): 39 full_img_path = os.path.normpath(os.path.join(md_img_dir, img_file)) 40 all_image_files.add(full_img_path) 41 42# 找出未引用的图片并删除 43unused_images = [img for img in all_image_files if img not in referenced_images] 44 45for img in unused_images: 46 try: 47 if len(sys.argv) == 2: 48 os.remove(img) 49 print(f\u0026#34;🗑️ Deleted unused image: {img}\u0026#34;) 50 except Exception as e: 51 print(f\u0026#34;❌ Error deleting {img}: {e}\u0026#34;) 52 53print(f\u0026#34;\\n✅ Done. {len(unused_images)} unused image(s) deleted.\u0026#34;) 参考 hugo-theme-bootstrap-skeleton: ec447c05d7891b9fafa7457607db55763123ef1a\nhugo-theme-bootstrap: 8ede3af8cab8d261847edb763db8fcda60540401\n","date":"2025年7月19日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/misc/hugo/","series":[],"smallImg":"","tags":[],"timestamp":1752936465,"title":"Hugo"},{"authors":[],"categories":[],"content":" 基于armv7的设备，在qemu下启动，裸机运行\n文档资料 imx6ull 官方资料链接 Arm官方文档：\nARM Architecture Reference Manual ARMv7-A and ARMv7-R edition\nARM Cortex-A Series Programmer\u0026rsquo;s Guide for ARMv7-A\nArm A-profile Architecture Registers\nArm A-profile A32/T32 Instruction Set Architecture\nArm A-profile A64 Instruction Set Architecture\narm_compiler_user_guide_100748_6.22_00_en\nArm Architecture Reference Manual for A-profile architecture : (AArch64)\ngcc-arm-10.3-2021.07-x86_64-arm-none-eabi.tar.xz https://developer.arm.com/downloads/-/gnu-a\ngcc-arm-none-eabi-10.3-2021.10-x86_64-linux.tar.bz2 https://developer.arm.com/downloads/-/gnu-rm\nqemu环境搭建 qemu源码下载 100ask修改版qemu源码下载 100ask 6ullqemu 1# 本文运行方式，使用官方的qemu也能正常运行，只使用imx6ull的功能 2 git clone https://e.coding.net/weidongshan/ubuntu-18.04_imx6ul_qemu_system.git 6ull裸机开发资料 1 git clone https://e.coding.net/weidongshan/01_all_series_quickstart.git 2 git clone https://e.coding.net/weidongshan/noos/cortexA7_windows_tools.git 3 git clone https://e.coding.net/weidongshan/hardware/doc_and_source_for_hardware.git 4 git clone https://e.coding.net/weidongshan/noos/doc_and_source_for_mcu_mpu.git编译器下载:arm-none-linux-gnueabihf\n1 # ，用 aria2c 比 wget 实在是快太多了 2 https://armkeil.blob.core.windows.net/developer/Files/downloads/gnu/13.2.rel1/binrel/arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-linux-gnueabihf.tar.xz armv7架构 寄存器 异常处理 lr的地址调整：关于ARM的PC指针 ==疑问：== armv7进入异常的时候根据规范描述是可以选择进入arm，或者thumb状态的？那么如果可以选择thumb编译的时候要按照thumb的格式编译\nA3：Application Level Memory Model 三种属性的设备： Normal Device Strongly-ordered 猜测：和 mmu，或者乱序执行有关？\nGeneral Timer 产生timer中断信号必须同时满足以下两个条件：\nCompareValue或者TimerValue计时时间到 timer必须enable且是unmask 消除timer中断信号只需要满是下面的其中一个条件即可：\n重新设置CompareValue或TimerValue寄存器，使其两个定时条件都不满足 使用timer掩码（CNTP_CTL.IMASK） 禁用timer（CNTP_CTL.ENABLE, 不再产出中断信号） 主要操作寄存器： CNTFRQ：读取设置频率\nCNTPCT：读取定时器的计数值（64位的）\nCNTP_CTL：控制寄存器（是否使能屏蔽定时器中断，状态指示是否发生中断）\nCNTP_CVAL：设置定时器的计时时间（64位，向上加）\n用法如：setTimer(getSystemTick()+delayTick)\nCNTP_TVAL：设置定时器的计时时间（32位有符号，向下减）\n用法如：setTimer(delayTick)\nCortex A7 gic 中断源ID： Software Generated Interrupts：0-15\nPrivate Peripheral Interrupts：16-31\n安全物理定时器ID：29\n非安全物理定时器ID：30\nShared Peripheral Interrupts ：32-1019，支持480个 （cortexa7,179）\n特殊中断ID GIC memory-map Memory regions used for these registers must be marked as Device or Strongly-ordered in the translation tables.\nMemory regions marked as Normal Memory cannot access any of the GIC registers, instead access caches or external memory as required ？？\n优先级：32级 GICC_BPR -\u0026gt;0,所有支持抢占，-\u0026gt;7，所有非抢占模式\ngic寄存器 0x000: RW: GICD_CTLR: 控制寄存器，是否使能 gic distributor\n0x004: RO: GICD_TYPER: bit5-7,支持的cpu数量+1，bit0-4,gic支持的中断个数x32\n0x008: RO: GICD_IIDR: bit24-31，ProductId，bit16-19,产品编号？bit12-15,revision num, [bit0-6,0x3b,bit7,0,bit8-11,0x4]\n0x080: RW: GICD_IGROUPRn: 0,Group0,1,Group1, 0x080+(n\u0026raquo;5)\u0026laquo;2, n\u0026amp;0x1F\n0x100: RW: GICD_ISENABLERn: 0,interrupt is disabled, 1,interrupt is enable; 写1-\u0026gt;1\n0x180: RW: GICD_ICENABLERn: 禁中断 0,disabled, 1,enabled; 写1-\u0026gt;0\n0x200: RW: GICD_ISPENDRn: 0,no pending,1,ppi/swi pending on this cpu, spi pending any cpu\n写1, edge: inactive-\u0026gt;pending; acitve-\u0026gt;active and pending; pending-\u0026gt;pending\nlevel: inactive-\u0026gt;pending; active-\u0026gt;active and pending; pending-\u0026gt;pending\n0x280: RW: GICD_ICPENDRn: 0,no pending,1,ppi/swi pending on this cpu, spi pending any cpu\n写1, edge: pending-\u0026gt;inactive; active and pending-\u0026gt;active\nlevel: pending-\u0026gt;inactive; active and pending-\u0026gt;active ? todo\n0x300: RW: GICD_ISACTIVERn: 0, not active, 1,active; 写1-\u0026gt;1\n0x380: RW: GICD_ICACTIVERn: 0, not active, 1,active; 写1-\u0026gt;0\n0x400: RW: GICD_IPRIORITYRn: 设置优先级 0, proiority0,1,2,3 0x400+(m\u0026raquo;2)\u0026laquo;2 (m\u0026amp;0x3)*8\n0x800: RW: GICD_ITARGETSRn: 绑定cpu，0, target cpu, byte0,1,2,3, each byte:cpu/isr\nGICD_ITARGETSR0-7,只读的（id0-31，swi中断）其他spi可写\n0xc00: RW: GICD_ICFGRn: low,0,N-N,1,1-N; high, 0,level,1,edge 0xc00+(m\u0026raquo;4)*4 (m\u0026amp;0xf)*2\n0xe00: RW: GICD_NSACRn: 0,no-secure\n0xf00: RO：GICD_SGIR: 软件参数中断，bit24-25,0,CPUTargeList，1，其他cpu，2，to self，bit16-23,target cpu,bit-cpu;\nbit15,0,SGIINTID,Group0,1,Group1;bit0-3,Interrupt id 0-15\n0xf10: RW: GICD_CPENDSGIRn: byte0,1,2,3; 0,not pending, 1,pending; write 1, remove pending ?\n0xf20: RW: GICD_SPENDSGIRn: byte0,1,2,3; 0,not pending, 1,pending; write 1, add pending ?\n0x0000: RW: GICC_CTLR: bit0:0,禁用中断信号，1使能中断信号\n0x0004: RW: GICC_PMR: 中断优先级掩码 bit0-7,bit0:128 bit0-1:64 bit0-2:32 bit0-3:16\n0x0008: RW: GICC_BPR：中断group分割点 bit0-2\n0x000c: RO: GICC_IAR: 响应的中断号，bit10-12,swi请求中断的cpu，bit0-9，中断id\n0x0010：WO：GICC_EOIR：中断处理完成，bit10-12,同上，同上\n0x0014: RO: GICC_RPR: bit0-7，当前运行的中断优先级\n0x0018: RO: GICC_HPPIR: 最高pending的优先级，bit10-12，swi产生中断的cpu，bit0-9：最高pending中断id\n0x001c: RW: GICC_ABPR:\n0x0020: RO: GICC_AIAR:\n0x0024: WO: GICC_AEOIR:\n0x0028: RO: GICC_AHPPIR:\n0x00d0: RW: GICC_APRn:\n0x00e0: RW: GICC_NSAPRn:\n0x00fc: RO: GICC_IIDR：读取productid, gic版本\n0x1000：WO：GICC_DIR:\n操作方法：\nGICD_TYPER：获取支持的中断信息 GICD_ICENABLERn：禁止中断转发 GICC_PMR：设置中断掩码 GICC_BPR：设置group，Subpriority（0,全抢占，7，禁止抢占） GICD_CTLR：使能 GICC_CTLR：使能 MMU相关 多核之间的操作全局变量的问题？\n如何保证数据是最新的，手动刷缓存？\na . memory type中有三种概念，是不是把全局变量定位到device区域，就不需要考虑缓存的问题了 硬件支持，只要写全局变量，自动处理，用户无感？ arm寄存器 cpsr 1N, bit[31] Negative condition flag. 2Z, bit[30] Zero condition flag. 3C, bit[29] Carry condition flag. 4V, bit[28] Overflow condition flag. 5 6A, bit[8] Asynchronous abort mask bit. 7I, bit[7] IRQ mask bit. 8F, bit[6] FIQ mask bit. 9\t0 Exception not masked. 10\t1 Exception masked 11T, bit[5] Thumb execution state bit 12\tJ\tT 13\t0\t0\tARM 14\t0\t1\tThubm 15\t1\t0 Jazelle 16\t1\t1 ThumbEE 17M[4:0], bits[4:0] Mode field 18\tUser\t10000 19\tFIQ\t10001 20\tIRQ\t10010 21\tSupervisor\t10011 22\tMonitor\t10110 23\tAbort\t10111 24\tHyp\t11010 25\tUndefined\t11011 26\tSystem\t11111 汇编指令 c嵌汇编 ( Mixing C and assembly code ) ARM64基础4：在C语言中嵌入ARM64汇编代码\n1__asm__ [__volatile__] ( assembler template 2 : [output operand list] /* optional */ 3 : [input operand list] /* optional */ 4 : [clobbered register list] /* optional */ 5 ); 伪指令 global：别的文件可以调用当前汇编文件里的函数\nextern：当前汇编可以调用别的文件的函数\nthumb: 指令来指明接下来的代码应以 Thumb 模式进行汇编\n条件执行 A8.3 Conditional execution msr srs rfe 编译链接 ARM链接脚本详解\nlinker script ld链接脚本语法简介\nGCC Arm 12.2编译提示 LOAD segment with RWX permissions 警告\n–start-group 和 –end-group 功能作用 做了哪些工作 设置异常向量表 设置模式下的sp，关mmu、icache、dcache 初始化gic（distribution，cpuifterface） 设置arch time 初始化串口 两个task进行任务切换，实现中。。。 qemu启动，task调度代码 使能arch timer 初始化 uart，支持printf打印 支持添加task，task循环调度，上下文切换，任务栈保存恢复 1tree 2├── build.sh # 编译执行，可能需要调整编译器路径 3├── CMakeLists.txt 4├── lib 5│ ├── gic.c 6│ ├── gic.h 7│ ├── timer.c 8│ ├── timer.h 9│ ├── uart.c 10│ └── uart.h 11├── out 12├── qemu.sh # qemu执行脚本 13└── src 14 ├── link.ld 15 ├── main.c 16 ├── my_printf.c 17 ├── my_printf.h 18 ├── start.S 19 └── task_test.c 参考文章 在线脑图工具 processon\nqemu嵌入式arm快速体验\nQEMU imx6ul开发板环境搭建\n百问网资料下载中心\nuboot源码\nqemu很老的例程\ngithbub文档语法\n【从0学ARM】你不了解的ARM处理异常之道\n视频\nSTM32:从0写RTOS,学习内部机制\n文档介绍\n记录问题 armv7需要设置异常向量表，即 VBAR 寄存器 在上电reset_handler中调用svc #0无法调转swi_handler，所以才发现需要设置异常向量中断 arm arch timer 每个核上的timer一直是在计数的，设置中断信号之后，要在中断函数中更新CompareValue或TimeValue的值 无法通过通过cp15读取gic基地址 ？, Configuration Base Address Register, （cortexa7，p137） 1MRC p15, 4, \u0026lt;Rt\u0026gt;, c15, c0, 0; Read Configuration Base Address Register 读取cpuid，MPIDR 1MRC p15, 0, \u0026lt;Rt\u0026gt;, c0, c0, 5; Read Multiprocessor Affinity Register 5. 调试阶段发现有些代码执行异常，比如c和汇编相互调用的时候，发现可能是armv7支持thumb造成的，-marm强制arm态 6. task栈切换 task中添加uint64变量执行异常（Undefined_Handler） 分析汇编代码发现了vmov指令，在编译选项中添加 -mfpu=vfpv3解决，vfpv3和neon的区别是啥呢？ arm编译器的区别 遇到编译链接问题，注意到编译器不一样，记录一下\n9. c 函数库 （newlic 和 glic） C 函数库 （libc,glibc,uClibc,newlib）\n遇到一个编译很坑的问题，查了好久发现是 project enable_language 和 设置编译器，先后顺序导致的问题 此案例中，先设置project(IMX6ULL ASM C)，后设置编译器即可解决问题 那么是如何发现的问题呢，因为我开始的时候用的是 arm-none-linux-gnueabihf-gcc 编译freertos，测试qemu启动，简单的task切换都没有问题，然后开始加入freertos源码，编译就出现一堆奇怪的问题（undefined reference __gcc_personality_v0 / __aeabi_unwind_cpp_pr0）等一大堆问题，先是问了人工智能改了一大圈也无果 后面我发现其他工程用的编译器是 arm-none-eabi-gcc（上述问题8）, 换了之后直接报错 \u0026lt; is not able to compile a simple test program. undefined reference to `_exit\u0026rsquo; \u0026gt;, 对我来说有是一个奇怪的问题 根据ai的回答，加上_exit函数也不行，后面我就用cmake写了一个最小编译环境，和我工程交叉测试发现了问题所在，不过根本原因也没深究，也可能只是碰巧解决了问题吧\nVERBOSE=1，编译详细日志\nCMAKE_EXE_LINKER_FLAGS_xxx 和 CMAKE_BUILD_TYPE CMAKE_\u0026lt;LANG\u0026gt;_FLAGS_\u0026lt;CONFIG\u0026gt; , 测试发现 CMAKE_BUILD_TYPE (release，debug，或者自定义标签)，会决定前面的\u0026lt;CONFIG\u0026gt;,\nCmake笔记\n12. xxxx.c.obj 和 xxx.c.o 生成差异\nCMAKE_SYSTEM_NAME 变量用于设置目标系统的操作系统。不同的操作系统通常有不同的编译工具链和库路径。通过设置 CMAKE_SYSTEM_NAME，你告诉CMake期望的目标系统是什么，这影响了CMake配置过程中的行为。例如： Windows、Linux、Darwin（macOS）、Generic（通常用于裸机或嵌入式系统）\nset(CMAKE_SYSTEM_NAME Generic) set(CMAKE_SYSTEM_PROCESSOR arm) 测试设置之后会生成obj后缀文件\ngcc 链接 和 ld 链接异同点 安装的 arm-none-eabi-gdb 报错：libncurses.so.5: cannot open shared object file: No such file or directory 网上的答案 sudo apt install libncurses5* 搞定，不知道是不是我的最新ubuntu24的问题，找不到下载源，所有就手动下载安装\nubuntu lib库下载地址：https://packages.ubuntu.com/ http://security.ubuntu.com/ubuntu/pool/universe/n/ncurses/libncurses5_6.2-0ubuntu2.1_amd64.deb http://security.ubuntu.com/ubuntu/pool/universe/n/ncurses/libtinfo5_6.2-0ubuntu2.1_amd64.deb 版本：6.2-0ubuntu2.1， 架构：i386，amd64\n64位电脑只需要 amd64，旧的gdb版本需要libncurses5, Distribution选择any\n基于imx6ull的sdk，在qemu上实现freertos，编译正常，运行的时候 portYIELD_WITHIN_API 这个就崩了，其实调用svc异常,主要分析定位异常原因 根本原因是问题1，未设置vbar寄存器，如何定位呢，\n首先肯定可以定位到哪一行的代码执行异常 在执行异常代码的时候切换到汇编代码查看，可以分析异常原因，比如此异常时候，跳到了0x000000c8, 这个地址是不正常的（由汇编文件可以分析向量地址0x80002008），就能知道是哪里的异常了 is not able to compile a simple test program https://discourse.cmake.org/t/ the-c-compiler-is-not-able-to-compile-a-simple-test-program-when-compiling-using-arm-gnu-toolchain/8215\nset(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY) 即可\n","date":"2025年7月19日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/arm/armv7-qemu/","series":[],"smallImg":"","tags":[{"title":"Armv7","url":"/tags/armv7/"},{"title":"Qemu","url":"/tags/qemu/"}],"timestamp":1752896693,"title":"Armv7 Qemu"},{"authors":[],"categories":[],"content":"IMX6ULL裸机启动，IMX6ULL运行FreeRTOS，源代码分析\n裸机启动部分 imx6ull中根据运行代码位置的不同RAM/flash/SD卡，上电会先运行片上ROM中的代码，搬运的数据大小是不同的，代码也不是存储在0地址处的。如下图，比如从sd中运行代码，代码IVToffset大小1k，initloadSize为4k。 实质上应用程序前红色框中的大小有3k，可以配置启动信息，入口地址，初始化设备，基本的时钟，DDR要先初始化才能使用吧。具体的可以参考其他资料如百问网的imx6ull手册 韦老师的裸机代码中，写好的程序是调用mkimage给app程序加上特有的头部信息，配合其开发的烧录工具100ask_imx6ull_flashing_tool可以下载到ram运行（*.imx文件）。如果想下载sd中，需要在imx文件前面加上1k的偏移（image vector table offset）\n1mkimage -n ./tools/imximage.cfg.cfgtmp -T imximage -e 0x80200000 -d led.bin led.imx 2// -e 0x80200000程序会被搬运到的位置 其他的开发板如，原子的imxdownload工具中直接固定了加载地址为0X87800000，链接脚本中也是这个地址，如不地址不相同，就会牵扯到代码重定位的问题。 但也有可能有人设置的就是不一样的地址，照样能跑下去，这就要看start.s中的跳转指令是\n1 ldr sp, =main /* 跳转到main函数 */ 2 b main /* 跳转到main函数 */链接地址和加载地址不一样的情况： 如果是第一行的话就无法运行，地址相关代码 如果第二行的话就代码可以部分运行，比如打印定义好的全局变量就不正常了，data区没有搬运到相应的链接地址去。\nIMX6ULL运行FreeRTOS imx6ull有官网的skd，里面已经有一些例子。 第一步： SDK_2.2_MCIM6ULL/boards/evkmcimx6ull/demo_apps/hello_world/armgcc中直接运行 ./build_ddr_debug.sh\n1SDK_2.2_MCIM6ULL/boards/evkmcimx6ull/demo_apps/hello_world/armgcc# ./build_ddr_debug.sh第二步：\n1mkimage -n ./tools/imximage.cfg.cfgtmp -T imximage -e 0x80002000 -d led.bin led.imx注意：-e 地址 为 0x80002000\n第三步： 利用100ask_imx6ull_flashing_tool下载到imx6ull上面运行就会看到串口打印的\n1hello world. 买到板子之后不久就一直想在imx6ULL上面跑rtos，结果也没找到啥教程，有人说cortexa7的可以参看a9的移植，无奈还是懵，后来想看看FreeRTOS源码之后在动手，结果发现简单看了源码还是菜到没头绪。 中间玩玩裸机程序，突然有两天就想研究一下，imx上程序从编译好到下载到板子上是怎么运行的，为啥我编译的sdk代码不可以用，后面就发现rtos的demo代码可能启动位置不对，根据连接脚本中的信息链接地址为0x80002000 SDK_2.2_MCIM6ULL/boards/evkmcimx6ull/rtos_examples 目录中有些例子，只要编译后，加上imx头部信息，就可以愉快的在imx6ull上面跑FreeRTOS了， 后续看看我的板子怎么能在FreeRTOS基础上跑lwip\n代码重定位 关于代码重定位。\nAPI总览 @startmindmap + FreeRTOS ++ Task Creation +++_ xTaskCreate +++_ xTaskCreateStatic +++_ vTaskDelete +++_ xTaskGetStaticBuffers ++ Task Control +++_ vTaskDelay +++_ vTaskDelayUntil +++_ xTaskDelayUntil +++_ uxTaskPriorityGet +++_ uxTaskPriorityGetFromISR +++_ uxTaskBasePriorityGet +++_ uxTaskBasePriorityGetFromISR +++_ vTaskPrioritySet +++_ vTaskSuspend +++_ vTaskResume +++_ xTaskResumFromISR +++_ xTaskAbortDelay ++ Task Utilities +++_ uxTaskGetSystemState +++_ vTaskGetInfo +++_ xTaskGetApplicationTaskTag +++_ xTaskGetCurrentTaskHandle +++_ xTaskGetHandle +++_ xTaskGetIdleTaskHandle +++_ uxTaskGetStackHighWaterMark +++_ eTaskGetState +++_ pcTaskGetName +++_ xTaskGetTickCount +++_ xTaskGetTickCountFromISR +++_ xTaskGetSchedulerState +++_ uxTaskGetNumberOfTasks +++_ vTaskList +++_ vTaskStartTrace +++_ ulTaskEndTrace +++_ vTaskGetRunTimeStats +++_ vTaskSetApplicationTaskTag +++_ xTaskCallApplicationTaskHook +++_ vTaskSetThreadLocalStoragePointer +++_ pvTaskGetThreadLocalStoragePointer +++_ vTaskSetTimeoutState +++_ xTaskCheckForTimeOut ++ RTOS Kernel Control +++_ taskYIELD Colors +++_ taskENTER_CRITICAL +++_ taskEXIT_CRITICAL +++_ taskENTER_CRITICAL_FROM_ISR +++_ taskEXIT_CRITICAL_FROM_ISR +++_ taskDISABLE_INTERRUPTS +++_ taskENABBLE_INTERRUPTS +++_ vTaskStartScheduler +++_ vTaskEndScheduler +++_ vTaskSuspendAll +++_ vTaskResumeAll +++_ vTaskStepTick +++_ xTaskCatchUpTicks ++ Direct To Task Notifications +++_ xTaskNotifyGive/xTaskNotifyGiveIndexed +++_ vTaskNotifyGiveFromISR +++_ ulTaskNotifyTake +++_ xTaskNotify +++_ xTaskNotifyAndQuery +++_ xTaskNotifyAndQueryFromISR +++_ xTaskNotifyFromISR +++_ xTaskNotifyWait +++_ xTaskNotifyStateClear +++_ ulTaskNotifyValueClear ++ Queues +++_ xQueueCreate +++_ xQueueCreateStatic +++_ xQueueDelete +++_ xQueueSend +++_ xQueueSendFromISR +++_ xQueueSendToBack +++_ xQueueSendToBackFromISR +++_ xQueueSendToFront +++_ xQueueSendToFrontFromISR +++_ xQueueReceive +++_ xQueueReceiveFromISR +++_ uxQueueMessagesWaiting +++_ uxQueueMessagesWaitingFromISR +++_ uxQueueSpacesAvailable +++_ xQueueReset +++_ xQueueOverwrite +++_ xQueueOverwriteFromISR +++_ xQueuePeek +++_ xQueuePeekFromISR +++_ vQueueAddToRegistry +++_ vQueueUnregisterQueue +++_ pcQueueGetName +++_ xQueueIsQueueFullFromISR +++_ xQueueIsQueueEmptyFormISR +++_ xQueueGetStaticBuffers +++_ xQueue +++_ xQueue +++_ xQueue +++_ xQueued +++_ xQueuedd ++ Queue Sets +++_ xQueueCreateSet +++_ xQueueAddToSet +++_ xQueueRemoveFromSet +++_ xQueueSelectFromSet +++_ xQueueSelectFromSetFromISR -- Stream Buffers ---_ xStreamBufferCreate/xStreamBufferCreateWithCallback ---_ xStreamBufferCreateStatic/xStreamBufferCreateStaticWithCallback ---_ xStreamBufferSend ---_ xStreamBufferSendFromISR ---_ xStreamBufferReceive ---_ xStreamBufferReceiveFromISR ---_ xStreamBufferDelete ---_ xStreamBufferBytesAvailable ---_ xStreamBufferSpacesAvailable ---_ xStreamBufferSetTriggerLevel ---_ xStreamBufferReset ---_ xStreamBufferResetFromISR ---_ xStreamBufferIsEmpty ---_ xStreamBufferIsFull ---_ xStreamBufferGetStaticBuffers ---_ uxStreamBufferGetStreamBufferNotificationIndex ---_ xStreamBufferSetStreamBufferNotificationIndex ---_ xStreamBatchingBufferCreate ---_ xStreamBatchingBufferCreateStatic -- Message Buffers ---_ xMessageBufferCreate ---_ xMessageBufferCreateStatic ---_ xMessageBufferSend ---_ xMessageBufferSendFromISR ---_ xMessageBufferReceive ---_ xMessageBufferReceiveFromISR ---_ xMessageBufferReset ---_ xMessageBufferResetFromISR ---_ xMessageBufferIsEmpty ---_ xMessageBufferIsFull ---_ xMessageBufferGetStaticBuffers -- Semaphore / Mutexes ---_ xSemaphoreCreateBinary ---_ xSemaphoreCreateBinaryStatic ---_ vSemaphoreCreateBinary ---_ xSemaphoreCreateCounting ---_ xSemaphoreCreateCountingStatic ---_ xSemaphoreCreateMutex ---_ xSemaphoreCreateMutexStatic ---_ xSemaphoreCreateRecursiveMutex ---_ xSemaphoreCreateRecursiveMutexStatic ---_ vSemaphoreDelete ---_ xSemaphoreGetMutexHolder ---_ xSemaphoreGetCount ---_ xSemaphoreTake ---_ xSemaphoreTakeFromISR ---_ xSemaphoreTakeRecursive ---_ xSemaphoreGive ---_ xSemaphoreGiveRecursive ---_ xSemaphoreGiveFromISR ---_ xSemaphoreGetStaticBuffer -- Software Timers ---_ xTimerCreate ---_ xTimerCreateStatic ---_ xTimerIsTimerActive ---_ xTimerStart ---_ xTimerStop ---_ xTimerChangePeriod ---_ xTimerDelete ---_ xTimerReset ---_ xTimerStartFromISR ---_ xTimerStopFromISR ---_ xTimerChangePeriodFromISR ---_ xTimerResetFromISR ---_ pvTimerGetTimerID ---_ vTimerSetReloadMode ---_ vTimerSetTimerID ---_ xTimerGetTimerDaemonTaskHandle ---_ xTimerPendFunctionCall ---_ xTimerPendFunctionCallFromISR ---_ xTimerGetName ---_ xTimerGetPeriod ---_ xTimerGetExpiryTime ---_ xTimerGetReloadMode -- Event Groups ---_ xEventGroupCreate ---_ xEventGroupCreatxeStatic ---_ vEventGroupDelte ---_ xEventGroupWaitBits ---_ xEventGroupSetBits ---_ xEventGroupSetBitsFromISR ---_ xEventGroupClearBits ---_ xEventGroupClearBitsFromISR ---_ xEventGroupGetBits ---_ xEventGroupSync ---_ xEventGroupGetStaticBuffer -- MPU ---_ xTaskCreateRestricted ---_ xTaskCreateRestrictedStatic ---_ vTaskAllocateMPURegions ---_ portSWITCH_TO_USER_MODE -- Co-routines ---_ xCoRoutineCreate ---_ crDELAY ---_ crQUEUE_SEND ---_ crQUEUE_RECEIVE ---_ crQUEUE_SEND_FROM_ISR ---_ crQUEUE_RECEIVE_FROM_ISR ---_ vCoRoutineSchedule ---_ vCoRoutineResetState @endmindmap FreeRTOS源代码分析 任务切换 @startuml start fork :Irq Handler; split :other iar func; split again :timer tick func; note right FreeRTOS_Tick_Handler xTaskIncrementTick(超时任务，从delay，event list删除，加入ready list) 如果 xTickCount 溢出，累加 xNumOfOverflows delay到期的任务高于当前优先级，时间片轮转，xYieldPending=true（其他任务抢占需要调度） ulPortYieldRequired = true end note end split if (ulPortYieldRequired == true) then (false) :irq return; else (yes) :save_context_and_switch; note right bl vTaskSwitchContextConst (vTaskSwitchContext) uxSchedulerSuspended != flase 挂起 os 不允许调度 xYieldPending = 0 一个标志位吧，其他需要调度的时候置1 设置新的 pxCurrentTCB，（软件，clz方式找到最高优先级） 就可以恢复当前task上下文，完成任务切换 end note endif fork again :FreeRTOS_SWI_Handler; :save_context bl vTaskSwitchContextConst restroe_context; end merge stop @enduml vTaskDelay @startuml start :vTaskDelay; :vTaskSuspendAll; note right ++uxSchedulerSuspended end note if (xTicksToDelay \u003e 0) then (yes) :prvAddCurrentTaskToDelayedList; note right 设置delay到期时间，更新 xNextTaskUnblockTime end note :xTaskResumeAll; note right --uxSchedulerSuspended， 为0往下继续处理 xPendingReadyList 处理pending list中task，加入ready list 当有任务大于当前优先级，需要任务切换 设置 xYieldPending=true，更新 xNextTaskUnblockTime 补偿系统tick，uxPendedTicks xAlreadyYielded = xTaskIncrementTick() 如果已经有其他task请求切换了，当前就无需再请求切换了 xYieldPending 会在 vTaskSwitchContext 设置 false end note else :xAlreadyYielded = false; endif if (xAlreadyYielded = false) then (yes) :portYIELD_WITHIN_API; note right delay参数为0，强制执行调度 portYIELD __asm volatile ( \"SWI 0\" ) end note else (no) endif stop @enduml xQueueGenericReceive @startuml start :xQueueGenericReceive; repeat :taskENTER_CRITICAL(); if (uxMessagesWaiting \u003e0) then(yes) note right 队列里的元素数量 end note :记录读数据的位置，receive数据会出队，peek只是读数据; :prvCopyDataFromQueue(); note right 读的索引后移一个uxItemSize，如果到tail，再指向head copy一个uxItemSize的数据到pvBuffer中 end note if (xJustPeeking == pdFALSE) then(yes) :当前为receive模式，读了数据之后就更新读指针，相当于出队操作; :当前queue有互斥锁，指向当前的运行task pxCurrentTCB-\u003euxMutexesHeld++; :判断当前queue的 xTasksWaitingToSend 不为空的话; :xTaskRemoveFromEventList(); note left 移除发送队列，os未挂起就加入readylist，挂起加加入pendingreadlist 优先级大的话，设置task调度标志 end note else :当前模式可以一直读队首的数据，不会出队; :恢复上面记录的数据读位置; :判断当前queue的 xTasksWaitingToReceive 不为空的话; :xTaskRemoveFromEventList(), task是否加入readlist的处理，是否切换task等; endif :taskEXIT_CRITICAL(); :return pdPASS; stop else (队列为空) if (xTicksToWait==0) then (等待时间为0) :taskEXIT_CRITICAL(); :return errQUEUE_EMPTY; stop elseif (xEntryTimeSet == pdFALSE) then(等待时间不为0) :vTaskSetTimeOutState(); note right xEntryTimeSet = true 记录 xNumOfOverflows xTickCount 为后面判断delay做准备 end note endif endif :taskEXIT_CRITICAL(); :; :vTaskSuspendAll(); :prvLockQueue(), rx tx加互斥锁; if ( xTaskCheckForTimeOut()== pdFALSE) then (yes) note right 根据xTimeOut pxTicksToWait判断是否延时时间到 延时时间到返回true，否则返回false，并更新vTaskSetTimeOutState( pxTimeOut ); end note :当前wait时间没有超时; if (队列是否为空) then (yes) :互斥锁，进入临界区，修改task优先级，优先级继承机制; note left vTaskPriorityInherit() 持有锁的taskA优先级低于当前task优先级，调整taskA的优先级 锁的持有者可能为null，意味中当前在isr上下文 end note :vTaskPlaceOnEventList; note right insert event list 加入delay list中 end note :prvUnlockQueue(); if (xTaskResumeAll() == false) then (yes) :调用 svc 切换task; endif else :prvUnlockQueue(); :xTaskResumeAll(); endif else :当前时间已经超时,等待结束了，有数据就返回数据，没有就返回空; :prvUnlockQueue(); :xTaskResumeAll(); if (队列 uxMessagesWaiting 是否为空) then (yes) :return errQUEUE_EMPTY; stop else :非空的话,继续下一个循环; endif endif repeat while () @enduml xQueueGenericSend @startuml start :xQueueGenericSend; repeat :taskENTER_CRITICAL(); if (队列有空闲 || 覆盖写) then(yes) note right 队列里的元素数量 end note :记录读数据的位置，receive数据会出队，peek只是读数据; :xYieldRequired = prvCopyDataToQueue(); note left 1. uxItemSize = 0可能表示互斥锁，需要调整恢复task优先级 xTaskPriorityDisinherit 2. queueSEND_TO_BACK，pcWriteTo+uxItemSize 3. queueSEND_TO_FRONT 先写后调整位置pcReadFrom-uxItemSize pcReadFrom指向的是空 4. queueOVERWRITE，有点坑，只能用在队列长度为1的场景中（无法执行，否则队列中就会存在无效的值） end note if (configUSE_QUEUE_SETS) then (yes) :prvNotifyQueueSetContainer; note left 1. prvCopyDataToQueue,这里把当前queue放入set中 队列集上有等待接收的task，xTaskRemoveFromEventList 唤醒的task高于当前task优先级，则抢占运行 2. set为null场景，判读是否有等待接收task，逻辑同上 end note else :没有配置队列集; if (xTasksWaitingToReceive 非空) then (yes) :xTaskRemoveFromEventList; :如果高优先级task，则抢占运行; else if (xYieldRequired = true) then note left 只有互斥锁的时候才有可能到达这里，因为优先级继承 发送数据的时候会恢复优先级 end note :抢占; endif endif :taskEXIT_CRITICAL(); :return pdPASS; stop else (队列已满) if (xTicksToWait==0) then (等待时间为0) :taskEXIT_CRITICAL(); :return errQUEUE_EMPTY; stop elseif (xEntryTimeSet == pdFALSE) then(等待时间不为0) :vTaskSetTimeOutState(); note right xEntryTimeSet = true 记录时间戳 xNumOfOverflows xTickCount 为后面判断delay做准备 end note endif endif :taskEXIT_CRITICAL(); :; :vTaskSuspendAll(); :prvLockQueue(), rx tx加互斥锁; if ( xTaskCheckForTimeOut()== pdFALSE) then (yes) note right 根据xTimeOut pxTicksToWait判断是否延时时间到 延时时间到返回true，否则返回false，并更新vTaskSetTimeOutState( pxTimeOut ); end note :当前wait时间没有超时; if (队列是否已满) then (yes) :互斥锁，进入临界区，修改task优先级，优先级继承机制; :vTaskPlaceOnEventList; note left 加入待发送队列 xTasksWaitingToSend，xEventListItem 从当前优先级队列移除，加入 delaylist， xStateListItem end note :prvUnlockQueue(); if (xTaskResumeAll() == false) then (yes) :调用 svc 切换task; endif else :prvUnlockQueue(); :xTaskResumeAll(); endif else :当前时间已经超时,等待结束了; :prvUnlockQueue(); :xTaskResumeAll(); :return errQUEUE_FULL; note right #yellow 为啥这里直接返回，不判断队列是否已满 有空闲的话，进行下一次循环呢？？ end note stop endif repeat while () @enduml 参考 PlantUML 语言参考指引\nPlantUML 快速入门指南\nFreeRTOS开发者文档\n","date":"2025年7月19日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/arm/imx6ull-freertos/","series":[],"smallImg":"","tags":[{"title":"Imx6ull","url":"/tags/imx6ull/"},{"title":"Freertos","url":"/tags/freertos/"}],"timestamp":1752896623,"title":"Imx6ull FreeRTOS"},{"authors":[],"categories":[],"content":"autosar vector candb工具\n精选文章 AUTOSAR精选文章推荐\n如何快速学习AUTOSAR?\ntoppers\ntoppers.atk2\n【Autosar】学习总结-BSW层_autosar bsw-CSDN博客\n","date":"2025年7月9日","img":"https://6668688.xyz/images/autosar/2025-07-20-11-21-22.png","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/autosar/autosar/","series":[],"smallImg":"","tags":[],"timestamp":1752045220,"title":"Autosar"},{"authors":[],"categories":[],"content":"","date":"2025年7月8日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/onlinetools/calculator/","series":[],"smallImg":"","tags":[],"timestamp":1751987502,"title":"计算器"},{"authors":[],"categories":[{"title":"嵌入式架构","url":"/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9E%B6%E6%9E%84/"}],"content":" tc397学习资料\nInfineon 相关资料： AURIX™ Development Studio\niLLD\n开发板套件介绍页面：https://www.infineon.com/cms/en/product/evaluation-boards/kit_a2g_tc397_5v_tft/\n开发板说明文档：Application Kit Manual TC3X7， ASCLIN_Shell_UART_1_KIT_TC397_TFT TC3xx系列总览： 32-bit TriCore™ AURIX™– TC3xx\n用户手册： AURIX™ TC39x User Manual 示例代码： Infineon/AURIX_code_examples\n英飞凌汽车电子生态圈：https://www.infineon.com/cms/cn/partners/partner-ecosystems/greater-china/autoeco/\n选型： 搜索 Microcontroller pocket guide 文档\n命令规则： Infineon-Microcontroller_Pocket_Guide_2022-ProductSelectionGuide-v02_00-EN.pdf\nTriCore架构 Infineon-AURIX_TC3xx_Architecture_all-UserManual-v01_00-EN.pdf\nTriCore是一种统一的、单核的32位微控制器-DSP架构，专为实时嵌入式系统优化。TriCore指令集架构（ISA）结合了微控制器的实时能力、DSP的计算能力和RISC加载/存储架构的高性能/价格特点，并且具有紧凑的可重编程核心\n统一32位地址空间，包含可选的虚拟地址和内存映射I/O 支持16位和32位指令格式，16位指令是32位指令的子集，因其使用频率高才选择。这些指令显著减少了代码空间，降低了内存需求、系统和功耗 实时响应能力主要由中断延迟和上下文切换时间决定，避免长的多周期指令和提供灵活的硬件支持中断方案来最小化中断延迟 支持快速上下文切换 小端字节序：data memory and CPU registers EABI传参 2.2.3 Argument Passing1\n用于 非指针类型（例如 int, float, char 等） 的寄存器： D4, D5, D6, D7 用于 指针类型（例如 char*, int*, struct* 等） 的寄存器： A4, A5, A6, A7 CALL 和 RET自动保存/恢复这些寄存器： D8–D15, A10–A15 task切换只需手动保存lower context即可\n返回值\n2.2.5 Return Values\n包括 int, float, char, bool 等类型\nD2 64-bit 标量\n使用 E2，即 D2:D3 32-bit 指针类型\n使用 A2 64-bit 指针\nA2:A3 小于等于 32-bit 的结构体\nD2 大小在 33 ~ 64-bit 的结构体\nA2:A3 大于 64-bit 的结构体\n调用者（caller）分配返回结构体所需的缓冲区 寄存器： 通用寄存器：32个 数据寄存器 (D[0] - D[15]): 用于存储和处理数据\n地址寄存器 (A[0] - A[15]): 用于存储和操作内存地址\nA[10]、A[11]、A[15]、D[15]这4个通用寄存器还有特殊功能：\nA[10]：栈指针寄存器Stack Pointer (SP) register\nA[11]：返回地址寄存器Return Address (RA) register\nA[15]：隐式基地址寄存器Implicit Address register\nD[15]：隐式数据寄存器Implicit Data register\nA[0]、A[1]、A[8]、A[9]是系统全局寄存器：\n函数调用、中断发生过程中，上下文的Save和Restore不会存储这4个寄存器中的信息\n其他功能寄存器 DEA (Data Error Address Register):记录触发异常的内存地址（对于数据访问异常，如空指针或写只读区域） DSTR (Data Synchronous Trap Register):提供数据访问异常的详细信息 FCX (Free Context List Pointer):指向可用上下文保存区域，可能用于检查上下文是否耗尽（可能导致异常） Register Name Description AddressOffset PCXI2 Previous Context Information Register FE00 PSW3 Program Status Word Register FE04 CPU_ID CPU Identification Register (Read Only) FE18 CORE_ID Core Identification Register FE1C BIV4 Base Interrupt Vector Table Pointer FE20 BTV5 Base Trap Vector Table Pointer FE24 ISP Interrupt Stack Pointer Register FE28 ICR6 ICU Interrupt Control Register FE2C Trap System 处理各种异常事件，如不可屏蔽中断（NMI）、指令异常或非法访问，不能被软件屏蔽，trap一直是使能的\ntrap类型： TriCore架构将陷阱分为八个类别，每个类别进一步分为同步或异步、硬件或软件陷阱。每个陷阱都有一个陷阱识别号（Trap Identification Number, TIN），用于在其类别内标识陷阱的原因。当陷阱被捕获时，陷阱识别号 TIN 会放置在数据寄存器D[15]中\nD15的低六位中\nMMU (Memory Management Unit) 陷阱: 与内存管理单元相关的异常，如内存访问违例。 内部保护陷阱: 保护机制引发的异常，如权限问题。 指令错误陷阱: 指令执行过程中发生的错误，如非法指令。 上下文管理陷阱: 与任务上下文切换相关的异常。 系统总线和外设陷阱: 系统总线和外设引发的异常。 断言陷阱: 程序中断言失败引发的异常。 系统调用陷阱: 系统调用指令引发的异常。 不可屏蔽中断 (NMI) 陷阱: 高优先级的不可屏蔽中断引发的异常。 又可分为如下几种类型：\n同步陷阱: 由指令执行过程中的错误引发，发生在程序的预定点。 异步陷阱: 由外部事件（如中断）引发，可能在程序执行的任意时刻发生。 硬件陷阱: 由硬件错误或异常引发。 软件陷阱: 由软件错误或异常引发。 不可恢复的陷阱: 引发任务不可恢复，无法简单重新启动。 TIN Name Synch./\nASynch. HW/\nSW Definition Class 0 \u0026mdash; \u0026mdash; \u0026mdash; MMU 0 VAF Synch. HW Virtual Address Fill. 1 VAP Synch. HW Virtual Address Protection. Class 1 \u0026mdash; \u0026mdash; \u0026mdash; Internal Protection Traps 1 PRIV Synch. HW Privileged Instruction. 2 MPR Synch. HW Memory Protection Read. 3 MPW Synch. HW Memory Protection Write. 4 MPX Synch. HW Memory Protection Execution. 5 MPP Synch. HW Memory Protection Peripheral Access. 6 MPN Synch. HW Memory Protection Null Address. 7 GRWP Synch. HW Global Register Write Protection. Class 2 \u0026mdash; \u0026mdash; \u0026mdash; Instruction Errors 1 IOPC Synch. HW Illegal Opcode. 2 UOPC Synch. HW Unimplemented Opcode. 3 OPD Synch. HW Invalid Operand specification. 4 ALN Synch. HW Data Address Alignment. 5 MEM Synch. HW Invalid Local Memory Address. Class 3 \u0026mdash; \u0026mdash; \u0026mdash; Context Management 1 FCD Synch. HW Free Context List Depletion (FCX = LCX). 2 CDO Synch. HW Call Depth Overflow. 3 CDU Synch. HW Call Depth Underflow 4 FCU Synch. HW Free Context List Underflow (FCX = 0). 5 CSU Synch. HW Call Stack Underflow (PCX = 0). 6 CTYP Synch. HW Context Type (PCXI.UL wrong). 7 NEST Synch. HW Nesting Error: RFE with non-zero call depth. Class 4 \u0026mdash; \u0026mdash; \u0026mdash; System Bus and Peripheral Errors 1 PSE Synch. HW Program Fetch Synchronous Error. 2 DSE Synch. HW Data Access Synchronous Error. 3 DAE Asynch AHW Data Access Asynchronous Error. 4 CAE Asynch HW Coprocessor Trap Asynchronous Error. 5 PIE Synch HW Program Memory Integrity Error. 6 DIE Asynch HW Data Memory Integrity Error. 7 TAE Asynch HW Temporal Asynchronous Error Class 5 \u0026mdash; \u0026mdash; \u0026mdash; Assertion Traps 1 OVF Synch SW Arithmetic Overflow. 2 SOVF Synch SW Sticky Arithmetic Overflow. Class 6 \u0026mdash; \u0026mdash; \u0026mdash; System Call SYS Synch SW System Call. Class 7 \u0026mdash; \u0026mdash; \u0026mdash; Non-Maskable Interrupt 0 NMI Asynch HW Non-Maskable Interrupt Infineon-AURIX_TC3xx_Architecture_vol1-UserManual-v01_00-EN_merged_unsigned.pdf -\u0026gt; 6.1 Trap Types\n异常处理： 陷阱不会改变 CPU 的中断优先级，因此 ICR.CCPN 字段不会被更新\n返回地址存储在返回地址寄存器 A[11] 中。\n同步陷阱，返回地址是引发陷阱的指令的程序计数器 (PC)\nSYS 陷阱: 由 SYSCALL 指令触发的 SYS 陷阱，返回地址指向 SYSCALL 之后的指令\nFCD 陷阱: 详见 “FCD - 自由上下文列表耗尽 (TIN 1)”\n异步陷阱: 返回地址是如果未发生陷阱将要执行的下一条指令地址。中断的返回地址也遵循相同的规则\n当发生陷阱时，硬件会生成一个陷阱标识符，该标识符由两个部分组成：\n陷阱类别号 (TCN): 用于索引到陷阱向量表。 陷阱识别号 (TIN): 该号码会被加载到数据寄存器 D[15] 中。 陷阱类别号 (TCN) 会左移五位，并与 BTV 寄存器中的地址进行按位或操作，以生成陷阱处理程序的入口地址。\n异常向量基地址 ：BTV， 每两个之间间隔32个byte ，如果处理逻辑很简短，可以放在向量代码段32个byte内，否则就跳到处理程序其他部分，使用 MTCR 指令修改 BTV 寄存器，有多个异常向量表的时候可以适配调整。\n通过TCN左移5位与上BTV，找到函数的入口地址\nUnlike the Interrupt Vector Table, entries in the Trap Vector Table cannot be spanned. 所有的trap条目都要配置 ?\nTCN的作用，计算配置trap向量表，找到入口地址，然后TIN进行处理？\n陷阱触发时的初始状态 当陷阱发生时的初始状态定义如下：\n上层上下文被保存。 返回地址更新至 A[11]。 陷阱识别号 (TIN) 被加载到 D[15]。 堆栈指针 (A[10]) 被设置为中断堆栈指针 (ISP)，前提是处理器之前未使用中断堆栈（即 PSW.IS = 0）。堆栈指针位被设置为使用中断堆栈：PSW.IS = 1。 I/O 模式被设置为监督模式，这意味着所有权限都被启用：PSW.IO = 10B。 当前保护寄存器组被设置为 0：PSW.PRS = 000B。 调用深度计数器 (CDC) 被清零，调用深度限制设置为 64：PSW.CDC = 0000000B。 启用调用深度计数器，PSW.CDE = 1。 PSW 安全位被设置为 SYSCON 寄存器中定义的值：PSW.S = SYSCON.TS。 禁止写入全局寄存器 A[0], A[1], A[8], A[9]：PSW.GW = 0。 中断系统被全局禁用：ICR.IE = 0。旧的 ICR.IE 和 ICR.CCPN 分别保存到 PCXI.PIE 和 PCXI.PCPN 中。ICR.CCPN 保持不变。 访问陷阱向量表以获取陷阱处理程序的第一条指令。 **尽管陷阱不会更改 ** ICR.CCPN ，但它们的处理程序仍然在中断被禁用的情况下开始执行。因此，它们可以在不被中断的情况下执行关键的初始操作，直到它们明确重新启用中断。\n对于不可恢复的 FCU 陷阱，初始状态有所不同。上层上下文无法保存。只有以下状态被保证：\nTIN 被加载到 D[15]。 堆栈指针 (A[10]) 被设置为中断堆栈指针 (ISP)，前提是处理器之前未使用中断堆栈（即 PSW.IS == 0）。 I/O 模式被设置为监督模式（所有权限都被启用：PSW.IO = 10B）。 当前保护寄存器组被设置为 0：PSW.PRS = 000B。 PSW 安全位被设置为 SYSCON 寄存器中定义的值：PSW.S = SYSCON.TS。 中断系统被全局禁用：ICR.IE = 0。ICR.CCPN 保持不变。 访问陷阱向量表以获取 FCU 陷阱处理程序的第一条指令 代码分析 BTV寄存器设置trap异常跳转函数\n1#define TRAPTAB0 (LCF_TRAPVEC0_START) 2group trapvec_tc0 (align = 8, run_addr=LCF_TRAPVEC0_START) 3{ 4 section \u0026#34;trapvec_tc0\u0026#34; (size=0x100, attributes=rx, fill=0) 5 { 6 select \u0026#34;(.text.traptab_cpu0*)\u0026#34;; 7 } 8} 9\u0026#34;__TRAPTAB_CPU0\u0026#34; := TRAPTAB0; 10#define CPU_BTV 0xFE24 11#define __TRAPTAB_CPU(cpu) __TRAPTAB_CPU##cpu 12#define __TRAPTAB(cpu) __TRAPTAB_CPU##cpu 13Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(0)); 14 15 16#pragma ghs section text=\u0026#34;.traptab_cpu0\u0026#34; 17void IfxCpu_Trap_vectorTable0(void) 18{ 19 IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError); 20 IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError); 21 IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError); 22 IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError); 23 IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError); 24 IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion); 25 IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu0); 26 IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt); 27} 28#pragma ghs section 29 30// defined(__ghs__) 31#define __ALIGN_TRAP_TAB__ __asm(\u0026#34; .align 32\u0026#34;); 32#define IfxCpu_Tsr_CallTSR(serviceRoutine) \\ 33 { \\ 34 __ALIGN_TRAP_TAB__; \\ 35 __asm(\u0026#34;svlcx\\n\u0026#34;); \\ 36 __asm(\u0026#34;mov\\t d4, d15\u0026#34;); \\ 37 __asm(\u0026#34;ji\\t %0\u0026#34; : : \u0026#34;a\u0026#34; (serviceRoutine)); \\ 38 __asm(\u0026#34;rfe\u0026#34;); \\ 39 } 40#define IfxCpu_Tsr_CallCSATSR(serviceRoutine) \\ 41 { \\ 42 __ALIGN_TRAP_TAB__; \\ 43 __asm(\u0026#34;mov\\t d4, d15\u0026#34;); \\ 44 __asm(\u0026#34;ji\\t %0\u0026#34; : : \u0026#34;a\u0026#34; (serviceRoutine)); \\ 45 __asm(\u0026#34;rfe\u0026#34;); \\ 46 } 中断： SRPN (Service Request Priority Number): 每个中断源分配一个唯一的 SRPN\nPIPN (Pending Interrupt Priority Number) : 挂起中断优先级号\nCCPN (Current CPU Priority Number): 当前cpu优先级\nICU (Interrupt Control Unit ): 中断控制单元\n中断描述： 中断控制单元 (ICU) 使用 SRPN 来优先处理多个并发的中断请求。获胜请求的 SRPN 作为挂起中断优先级号 (PIPN)，当有新的中断请求触发,CPU 通过将 PIPN 与当前 CPU 优先级号 (CCPN) 进行比较，决定是否接受请求的中断。如果 CPU 决定接受中断请求，它将响应一个中断确认，并返回已接受中断的优先级号。ICU 随后会清除请求的中断源\n**中断响应条件： **ICR.IE == 1 \u0026amp;\u0026amp; PIPN \u0026gt; CCPN\n可能禁止中断响应的条件：\n中断系统全局禁用 (ICR.IE == 0)。\n当前 CPU 优先级 (CCPN) 等于或高于挂起中断优先级号 (PIPN)。\nCPU 正在进入中断或陷阱服务例程。\nCPU 正在执行不可中断的陷阱服务。\nCPU 正在执行多周期指令。\nCPU 正在执行修改 ICR 的指令\n中断向量表： 每个中断向量占用32byte或者8byte，由BIV.VSS的值决定\n1if (BIV.VSS == 1’b0) 2 ISR_Entry_PC = {BIV[31:1],1’b0} | {PIPN\u0026lt;\u0026lt;5}; 3else 4 ISR_Entry_PC = {BIV[31:1],1’b0} | {PIPN\u0026lt;\u0026lt;3}; 优先级组：\n中断优先级组描述了一组不能中断彼此服务程序的中断。当 CPU 开始处理某个中断时，中断系统会被全局禁用，且 CPU 的当前优先级号码 (CCPN) 设置为正在服务的中断的优先级号码。这会阻止所有进一步的中断服务，直到通过软件重新启用中断系统或使用 RFE（异常返回）指令终止服务例程。\nRFE 指令：RFE 指令会自动恢复 ICR.IE 位的前一个状态（ICR.IE = 1）\n当 ISR 软件通过设置 ICR.IE 再次启用中断系统而不改变 CCPN 时，就可以阻止所有与 CCPN 相同或更低优先级的中断请求。这包括当前中断的重新发生，即当前中断不能中断自己的服务。但会被更高优先级的中断打断。为了实现中断优先级组，相关的服务例程软件会在再次启用中断系统之前， 将 CCPN 设置为该组中最高 SRPN 的值 ，如下图：\n组1：11-12，CCPN=12\n组2：14-17，CCPN=17\n中断优先级： 中断处理： 进入中断的行为如下：\nThe upper context of the current task is saved. The Return Address (A[11]) is updated with the current PC. If the processor was not previously using the interrupt stack (PSW.IS = 0), then the A[10] Stack Pointer is set to the interrupt stack pointer (ISP). The stack pointer bit is then set for using the interrupt stack: PSW.IS = 1. The I/O mode is set to Supervisor mode, which means all permissions are enabled: PSW.IO = 10B. The current Protection Register Set is set to 0: PSW.PRS = 000B. The Call Depth Counter (PSW.CDC) is cleared, and the call depth limit selector is set for 64: PSW.CDC = 0000000B. Call Depth Counter is enabled, PSW.CDE = 1. PSW Safety bit is set to value defined in the SYSCON register. PSW.S = SYSCON.IS. Write permission to global registers A[0], A[1], A[8], A[9] is disabled: PSW.GW = 0. The interrupt system is globally disabled: ICR.IE = 0. The old ICR.IE is saved into PCXI.PIE. The Current CPU Priority Number (ICR.CCPN) is saved into the Previous CPU Priority Number (PCXI.PCPN) field. The Pending Interrupt Priority Number (ICR.PIPN) is saved into the Current CPU Priority Number (ICR.CCPN) field. The interrupt vector table is accessed to fetch the first instruction of the ISR. 中断退出的行为：\nPCXI.PCPN is written to ICR.CCPN to set the CPU priority number to the value before interruption. PCXI.PIE is written to ICR.IE to restore the state of this bit. 任务切换 在嵌入式和实时控制系统设计中，通常将中断处理程序和软件管理的任务视为在各自的“虚拟”微控制器上执行。这个模型通常由实时执行系统或实时操作系统（RTOS）支持，这些系统层叠在底层机器架构的功能之上。\n在TriCore™架构中，RTOS层需要处理的更少，硬件可以高效地处理任务之间的切换。同时，该架构允许在任务模型中具有相当大的灵活性。系统设计人员可以根据应用程序的需求选择最合适的实时执行系统和软件设计方法，而架构对其施加的限制相对较少。\n在TriCore架构中，低开销的任务切换和函数调用机制是密切相关的。\n任务切换，保护当前任务的上下文，然后回复另一个待执行任务的上下文，并执行\nContexts, when saved to memory, occupy 16 word blocks of storage, known as **Context Save Areas ** (CSAs).\nUpper context: 包括地址寄存器A[10]到A[15]和数据寄存器D[8]到D[15]，PCXI和PSW。\nLower context : 包括地址寄存器A[2]到A[7]、数据寄存器D[0]到D[7]、A[11]（返回地址）和PCXI。\n每个CSA保存一个 Upper context 或 Lower context\nLink Word由两部分组成，Segment和Offset，上面解释了一个CSA占用64byte大小，所有CSA可用的大小是4M\n系统中的会维护两个CSA链表，Previous Context List (PCX) 和 Free Context List (FCX)\n上下文保存：\n下半部分上下文寄存器：类似于全局寄存器，即中断处理程序、陷阱处理程序或调用函数可以看到这些寄存器中断前的值。在事件结束后，这些寄存器中的任何更改会保留，因此可以用于 传递函数参数和返回值 。中断和陷阱处理程序必须在使用这些寄存器之前保存它们的原始值，并在退出之前恢复这些值。 上半部分上下文寄存器：这些寄存器不是硬件静态寄存器。概念上，函数调用或中断处理程序总是以自己私有的上半部分上下文寄存器开始执行。被中断或调用的函数的上半部分上下文寄存器不会被继承 只有 A10（sp）、A11（RA）、PSW、PCXI 和在陷阱情况下的 D[15] 寄存器在调用函数、陷阱处理程序或中断处理程序中具有架构定义的初始值。函数、陷阱处理程序或中断处理程序在写入其他上半部分上下文寄存器之前读取这些寄存器的值，是未定义操作。 上下文保存：\n上下文恢复：\n1/* 第一个 CSA */ 2uppercontext = (uppercontext_t)LINKWORDTOEA(Fcx); 3/* 第二个 CSA */ 4lowercontext = (lowercontext_t)LINKWORDTOEA(uppercontext-\u0026gt;PCXI); 5/* 第三个 CSA 线程退出 */ 6exitcontext = (uppercontext_t)LINKWORDTOEA(lowercontext-\u0026gt;PCXI); 模式与访问权限： 用户模式（User Mode） User-0模式: 该模式用于不访问外设的任务。在这个模式下，任务无法启用或禁用中断。 User-1模式: 该模式用于访问常见的、未保护的外设任务。例如，串口读写操作、计时器的读操作，以及大多数I/O状态寄存器的访问。此模式下的任务可以禁用中断（此行为可以通过系统控制寄存器覆盖）。 监督模式（Supervisor Mode） 该模式允许任务读取和写入系统寄存器，并访问所有外设设备。此模式下的任务可以禁用中断。 Memory Barrier 内存屏障（Memory Barrier），也叫内存栅栏，是一种用于控制 CPU 和编译器在执行操作时的顺序的机制。内存屏障确保某些操作在代码执行顺序上保持一致，从而避免因指令重排序导致的不一致性问题。\n内存屏障的作用 在多核系统中，不同核心可能会乱序执行指令或者 乱序读取/写入内存 。如果没有内存屏障，以下问题可能会发生：\n数据竞争：两个核心同时访问同一内存位置，其中一个核心写入数据后，另一个核心可能会读到旧的数据。 指令重排序：编译器或 CPU 出于优化目的，可能会改变指令执行顺序，导致预期的同步行为被破坏。 内存屏障通过阻止这种乱序操作，确保所有核心看到一致的数据和内存操作顺序。\nDSYNC（Data Synchronization） DSYNC 指令保证在 DSYNC 指令之前的所有数据访问操作都已完成，然后才会启动与 DSYNC 之后的指令相关联的任何数据内存访问操作。这包括所有对系统总线和本地数据内存的访问。 ISYNC（Instruction Synchronization） ISYNC 指令用于确保 CPU 内部的状态一致性。它主要用于指令的同步，确保在 ISYNC 指令之前的所有指令都已执行完毕，并且对架构状态的任何更改已经生效，然后才会继续执行 ISYNC 之后的指令。 ISYNC 指令的操作如下： 等待 ISYNC 之前的所有指令完成。 刷新 CPU 管道并取消 ISYNC 之后的所有指令。 使管道中所有缓存状态失效，例如循环缓存缓冲区。 重新获取 ISYNC 之后的下一条指令。 TC397XX： 官方介绍： SAK-TC397XX-256F300S BD\nInfineon-AURIX_TC3xx_Architecture_all-UserManual-v01_00-EN.pdf\nInfineon-AURIX_TC39x-UserManual-v02_00-EN.pdf\n硬件特性： TriCore™ TC397xx是32位高性能的微控制器，广泛应用于汽车和其他要求高可靠性和高性能的领域。以下是其主要特性：\n处理器架构：\n配备6个TriCore™（TC1.6.2）核心，主频为300 MHz，其中包括4个附加的检查核心，提供4000 DMIPS（Dhrystone MIPS）。 浮点与定点支持：\n所有核心都支持浮点运算和定点运算，提供灵活的计算能力。 RAM/ROM：\n16 MB flash，支持ECC（错误更正码）保护。 umbrella (5 x 3 MB, 1 x 1 MB)1. 高达6.9 MB SRAM，支持ECC保护，增强数据可靠性。 通信接口：\n1 Gbit以太网接口。 12个CAN FD接口，用于高带宽的控制器局域网络通信。 2个FlexRay接口，支持高速车载通信。 12个ASCLIN（异步串行通信接口），适用于多种串行通信需求。 6个QSPI接口（四线串行外设接口），用于高速外部存储。 2个I²C接口，支持多主设备和多从设备的串行通信。 25个SENT接口（串行增强数字传感器接口），用于传感器数据采集。 4个PSI5接口和1个PSI5S接口，支持车载传感器的数据传输。 2个HSSLL接口（高速同步串行链路），适用于高速数据传输。 4个MSC接口（多功能同步通信），用于多种数据通信需求。 1个eMMC/SDIOT接口，支持外部存储扩展。 1个I²S仿真接口，用于音频数据传输。 定时器模块：\n多种冗余和多样化的定时器模块，如GTM（通用定时器模块）、CCU6（计数器控制单元6）、GPT12（通用预分频定时器12），提供精确的时间管理和测量功能。 安全性：\nEVITA Full HSM（硬件安全模块），支持ECC256（椭圆曲线密码学256位密钥）和SHA2（安全散列算法2），提供高级的安全保障。 封装：\n采用LFBGA-292封装，适合高密度集成。 安全标准：\n依照ISO 26262/IEC 61508标准进行开发和文档化，支持高达ASIL-D（汽车安全完整性等级D）/SIL3（安全完整性等级3）的安全要求。 AUTOSAR支持：\n支持AUTOSAR 4.2（汽车开放系统架构），用于车载软件的标准化开发。 可选浮点单元 （FPU） 和内存管理单元 （MMU）\n电源供应：\n单电压供电，支持5 V或3.3 V电压输入。 温度范围：\n工作温度范围为-40°C到125°C，适合极端环境下的应用。 优势：\n最佳性能，支持ASIL-D设计\nASIL-D合规性：TC397xx微控制器提供了顶级的性能，能够支持达到ASIL-D安全标准的设计。ASIL-D是ISO 26262标准中最高的汽车安全完整性等级，确保汽车应用的最高安全水平。 向下兼容，适配成本更低的AURIX™ TC3xx微控制器\n成本效益：TC397xx微控制器可以向下兼容，适配较低成本的AURIX™ TC3xx系列微控制器。这种向下兼容性意味着可以在不同成本级别的产品中使用相似的硬件架构，帮助降低整体系统成本，同时保留核心功能和性能。 支持A/B交换的软件更新\n远程更新支持：TC397xx支持A/B交换的软件更新机制，这允许在系统运行时进行安全的软件更新。A/B交换的方式可以在不影响系统正常运行的情况下完成软件更新，提升系统的可靠性和安全性。这种支持对汽车系统的维护和升级非常重要，尤其是在需要远程更新的情况下。 从AURIX™第一代产品的易迁移\n兼容性：TC397xx微控制器与AURIX™第一代产品在软件和硬件方面具有兼容性，使得从早期版本的AURIX™微控制器迁移到TC397xx变得更为简便。这样的兼容性不仅减少了开发时间和成本，还可以确保现有系统的平稳过渡 Flash 中断 中断请求可以由CPU或DMA模块来处理，在文档中被称为“ 服务请求 ”而不是“中断请求”，因为它们可以由任一服务提供者处理。\n中断系统是在中断路由器(IR)模块中实现的，该模块包括服务请求节点（SRNs）、中断控制单元（ICUs），以及一些支持软件开发的附加功能。\n如下图所示，每个可以产生服务请求的模块都连接到 IR 模块中的一个或多个服务请求节点（SRNs）。IR 模块还包括几个通用的服务请求节点（SRNs），即软件触发中断\n每个SRN都包含一个SRC（Service Request Control Register），用来配置服务请求的优先级、映射到的服务提供者等。每个SRN都连接到中断路由器模块中的所有ICUs，而SRN的控制寄存器设置则定义了服务请求的目标服务提供者和优先级。\n每个ICU负责在映射到该ICU的多个服务请求之间进行中断仲裁。ICU在仲裁轮中选择一个有效的获胜服务请求/SRN，并将其提供给服务提供者（CPU或DMA模块）。服务提供者在处理服务请求时，向ICU反馈当前正在处理的服务请求。\n中断仲裁 每个中断模块中的中断控制单元 (ICU) 都有自己独立的中断总线。每个服务请求节点 (SRN) 都可以通过在SRC.TOS 位字段中设置，将其映射到相关的 ICU / 中断总线上，从而将该服务请求节点定向到特定的服务提供者\nSRC.TOS: Type of Service Control ( cpu0-5, dma ）\nSRC.SRE: Service Request Enable （1：enabled）\n当第一个服务请求pending时，相关的中断总线将启动第一次仲裁过程。相关的中断控制单元 (ICU) 提供在上一次仲裁过程中获胜的服务。仲裁过程使用 3-4 个系统外围总线时钟周期来确定具有最高优先级号码 (SRPN) 的待处理服务请求。\n在仲裁过程中，中断总线会比较映射到此中断总线（通过 SRC.TOS 设置）的所有待处理服务请求节点 (SRN) 的SRC.SRPN 位字段。仲裁过程中，具有最高优先级号码的待处理服务请求将被识别为获胜者，并且相关的 SRN 服务请求控制寄存器的位字段值（SRPN、ECC 和 SRN 的索引）将提供给 ICU，并传给给服务提供者，然后ICU会收到确认信息，之后进行ECC校验,中断路由模块会将检测到的错误信号发送到安全管理单元 (SMU)（SMU 中的一个位覆盖了所有 SRN 和 ICU 的错误）。\n中断配置 如下图中断向量表可以配置32byte，8byte，单地址\n中断初始化：\n外部中断： External Request Unit (ERU) 是一个多功能的事件和模式检测单元，其主要功能是根据可选择的触发事件生成中断（例如，当输入引脚上检测到边沿变化时，生成外部中断请求）。此外，ERU还可以将检测到的事件用于其他目标模块，以触发或控制模块特定的操作。\n功能列表：\n生成中断：支持基于不同输入上的可选择触发事件生成中断。 8个独立输入通道：用于输入选择和触发或控制功能的条件设定。 事件分配矩阵：使用连接矩阵定义输入通道x的事件，这些事件将导致输出通道y的反应。 8个独立输出通道：用于事件组合、定义事件的效果，并分配给系统（例如，中断生成、定时器触发等）。 这些功能使ERU成为一个强大的工具，用于检测和响应多种外部信号和事件，在嵌入式系统中具有广泛的应用。\n这些任务由以下构建块(building block)处理:\nExternal Request Select Unit (ERSx), 每个输入通道都有一个外部请求选择单元（ERSx），可以从6个可能的可用输入中选择一个输入向量 Event Trigger Logic (ETLx), 每个输入通道的事件触发逻辑（ETLx）允许定义导致触发事件的转换（边缘选择或通过软件），也可以存储此状态. 此处，所选信号的输入电平被转换为事件（检测到事件=置位事件标志，与原始输入信号的极性无关） Connecting Matrix, 连接矩阵将输入通道生成的事件和状态标志分配到输出通道 Output Gating Unit (OGUy), 每个输出通道的输出门控单元（OGUy），结合了可用的触发事件和来自输入通道的状态信息. 一个输入通道的事件可以导致多个输出通道的反应，或者多个输入通道的事件也可以组合成一个输出通道的反应（模式检测）. 可以配置不同类型的反应，例如产生中断. 可以从大量输入信号中选择ERU的输入, 这些输入中的16个直接来自输入端口，而其他输入则来自各种外围模块状态信号.\nREQxy Digital PORT Input Glitch Filter (FILT), 毛刺滤波器仅在端口(PORTS)可用, 用寄存器EIFILT配置, 用于抑制信号噪声导致PORTS的输入引脚上发生的不必要的快速转换, 类似于延时消抖. 滤波器预分频器可以设置为1到15之间的值，从而提供从10ns ~ \u0026gt;2µs的可能的毛刺特性范围, 通常，3~5 Tfilt的深度就足够了. 默认情况下，它是清除的. 如果清除了DEPTH，则所有过滤器均处于非活动状态:\nExternal Request Selector Unit (ERS)：\nEvent Trigger Logic (ETLx), 事件触发逻辑, 基于边缘检测模块，在该模块中，可以分别启用对上升沿或下降沿的检测. 如果两个使能位都被置位（例如处理触发输入），则两个边沿都会导致触发事件. 四个ETL单元中的每对都有一个关联的EICRy寄存器，该寄存器控制ETL的所有选项（该寄存器还保存关联的ERS单元对的控制位）\nERU_Interrupt_1 for KIT_AURIX_TC397_TFT\n如何设置中断向量表，以及中断handler如何放到中断向量表中的\nLcf_Tasking_Tricore_Tc.lsl\n1 2#define LCF_TRAPVEC0_START 0x80000100 3#define TRAPTAB0 (LCF_TRAPVEC0_START) 4 \u0026#34;__TRAPTAB_CPU0\u0026#34; := TRAPTAB0; 5 6 group trapvec_tc0 (align = 8, run_addr=LCF_TRAPVEC0_START) 7 { 8 section \u0026#34;trapvec_tc0\u0026#34; (size=0x100, attributes=rx, fill=0) 9 { 10 select \u0026#34;(.text.traptab_cpu0*)\u0026#34;; // 下文代码中配置的 11 } 12 } 1// IfxCpu_Trap.c 2 3#pragma protect on 4#pragma section code \u0026#34;traptab_cpu0\u0026#34; 5 6void IfxCpu_Trap_vectorTable0(void) 7 8#pragma endprotect 9 10| IfxCpu_Trap.o | .text.traptab_cpu0 (27065)| 0x000000f2 | 0x0| .text.traptab_cpu0 (27065) | 0x000000f2 | 1#define LCF_INTVEC0_START 0x802FE000 2#define INTTAB0 (LCF_INTVEC0_START) 3 \u0026#34;_lc_u_int_tab\u0026#34; = (LCF_INTVEC0_START); 4 \u0026#34;__INTTAB_CPU0\u0026#34; = (LCF_INTVEC0_START); 5 6 7#define IFX_INTERRUPT(isr, vectabNum, prio) IFX_INTERRUPT_INTERNAL(isr, vectabNum, prio) 8#define IFX_INTERRUPT_INTERNAL(isr, vectabNum, prio) void __interrupt(prio) __vector_table(vectabNum) isr(void) 参考： AURIX TC397 SCU 之 ERU 外部中断_scu中断配置-CSDN博客\n【回眸】AurixTC397ERU外部中断开发 萌新札记\nUCB：6.8 User Configuration Block (UCB)\nTriCore™ Embedded Applications Binary Interface (EABI)\n问题定位 访问空指针 DMI-\u0026gt;DSTR-\u0026gt;MPE : Error\n系统寄存器 port多核访问 Write access enable register 配置 tc4规范章节4了解 缩略词 展开: Acronym Description ADAS Advanced Driver Assistance System ADC Analog-to-Digital Converter ALU Arithmetic and Logic Unit ASCLIN Asynchronous/Synchronous Serial Controller with LIN BBB Back Bone Bus BCU Bus Control Unit BROM Boot ROM \u0026amp; Test ROM CAN Controller Area Network CIF Camera (and ADC) Interface CCU Clock Control Unit CPU Central Processing Unit CRC Cyclic Redundancy Code CSA Context Save Area CSFR Core Special Function Register CCU6 Capture Compare Unit 6 DAM Default Application Memory DAP Device Access Port DAS Device Access Server DPI Direct Processor Interface (to Local Flash Bank) DCACHE Data Cache DFLASH (or DF) Data Flash Memory DLMU Direct-connected Local Memory Unit DMA Direct Memory Access DMBI Data Memory Bus Interface DMI Data Memory Interface DMU Data Memory Unit DRLB Data Read Line Buffer DSPR Data Scratchpad RAM EBU External Bus Interface ECC Error Correction Code ED Emulation Device EDSADC Enhanced Delta-Sigma Analog to Digital Converter EVADC Enhanced Versatile Analog-to-Digital Converter EMI Electro-Magnetic Interference ERAY Flexray Controller EtherMAC Ethernet Media Access Controller EVR Embedded Voltage Regulator FCE Flexible CRC Engine FCOMP Fast Comparator FM-PLL PLL with Frequency Modulation support FPI Flexible Peripheral Interconnect (Bus protocol) FPU Floating Point Unit FSM Finite State Machine GPIO General Purpose Input/Output GPT12 General Purpose Timer 12 GTM Generic Timer Module HSM Hardware Security Module HSPDM High Speed Pulse Density Modulator HSSL High Speed Serial Link I2C Inter-Integrated Circuit Controller I/O Input / Output IOM I/O Monitor Unit IR Interrupt Router JTAG Joint Test Action Group = IEEE1149.1 LMU Local Bus Memory Unit MBIST Memory Build In Self Test MMU Memory Management Unit MSB Most Significant Bit MSC Micro Second Channel MTU Memory Test Unit MCMCAN CAN controller NC Not Connected NMI Non-Maskable Interrupt NVM Non Volatile Memory OCDS On-Chip Debug Support OVRAM Overlay Memory PLL Phase Locked Loop PCACHE Program Cache PD Production Device PFI Program Flash Interface PFLASH (or PF) Program Flash Memory PMBI Program Memory Bus Interface PMI Program Memory Interface PMS Power Management System PSI5 Peripheral Sensor Interface PSI5-S Peripheral Sensor Interface with Serial Interface to Phy PSPR Program Scratchpad RAM QSPI Queued SPI Controller RAM Random Access Memory RCU Reset Control Unit RIF Radar Interface RISC Reduced Instruction Set Computing SBCU System Peripheral Bus Control Unit SCU System Control Unit SCR Standby Controller SENT Single Edge Nibble Transmission SFR Special Function Register SMU Safety Management Unit SPB System Peripheral Bus (based on FPI protocol) SPU Signal Processing Unit SPD Single Pin DAP SPI Synchronous Serial Controller SRI Shared Resource Interconnect SRAM Static Data Memory SRN Service Request Node STM System Timer SWD Supply Watchdog TC1.6.2P TriCore CPU TC1.6.2P UCB User Configuration Block WDT Watchdog Timer XBar, XBar_SRI Cross Bar Interconnect, based on the Shared Resource Interconnect protocol Infineon-TC2xx_EABI-UM-v02_09-EN.pdf\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPCXI(Previous Context Information register): 保存任务上下文信息\nField Bits Type Description PCPN [29:22] rw Previous CPU PriorityNumber PIE 21 rw Previous Interrupt Enable (ICR.IE) UL 20 rw 0:Lower, 1:Upper Context PCXS [19:16] rw PCX Segment Address PCXO [15:0] rw Previous Context Pointer Offset \u0026#160;\u0026#x21a9;\u0026#xfe0e; PSW (Program Status Word): 记录处理器状态、保护模式等\nField Bits Type Description USB [31:24] rw User Status Bits PRS[2] 15 - Protection Register Set bit[2] S 14 rw Safety Task Identifier PRS[1:0] [13:12] rw Protection Register Set bits[1:0] IO [11:10] rw Access Privilege Level Control IS 9 rw 0:User Stack, 1: Shared Global Stack GW 8 rw Global Address Register Write Permission CDE 7 rw Call Depth Count Enable CDC [6:0] rw Call Depth Counter (0-64) User Status Bits: Field Bits Type Description C 31 rw Carry V 30 rw Overflow SV 29 rw Sticky Overflow AV 28 rw Advance Overflow SAV 27 rw Sticky Advance Overflow RES [26:24] - Reserved Field Access Privilege Level Control: 00: User-0 Mode, No peripheral access\n01: User-1 Mode, Regular peripheral access\n10: Supervisor Mode, Enables access to all peripheral devices \u0026#160;\u0026#x21a9;\u0026#xfe0e; BIV(Base Interrupt Vector Table Pointer): 中断向量地址\nField Bits Type Description BIV [31:1] rw Base Address of Interrupt Vector Table VSS 0 rw Vector Spacing Selec (0:32byte,1:8byte) \u0026#160;\u0026#x21a9;\u0026#xfe0e; BTV(Base Trap Vector Table Pointer): trap异常地址\nField Bits Type Description BIV [31:1] rw Base Address of Trap Vector Table RES 0 - Reserved \u0026#160;\u0026#x21a9;\u0026#xfe0e; ICR(ICU Interrupt Control Register): 中断控制寄存器\nField Bits Type Description PIPN [23:16] rh Pending Interrupt Priority Number\n0:no pending, 1:lower priority IE 15 rwh Global Interrupt Enable Bit\n0:全局关中断，1:全局开中断 CCPN [7:0] rwh Current CPU Priority Number \u0026#160;\u0026#x21a9;\u0026#xfe0e; ","date":"2025年7月8日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/tricore/tc397/","series":[{"title":"Tc397 架构系列","url":"/series/tc397-%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97/"}],"smallImg":"","tags":[{"title":"Tricore","url":"/tags/tricore/"},{"title":"Tc397","url":"/tags/tc397/"}],"timestamp":1751986567,"title":"Tc397"},{"authors":[],"categories":[{"title":"Tricore中断","url":"/categories/tricore%E4%B8%AD%E6%96%AD/"}],"content":" Tc397中断子系统\n通用寄存器和系统寄存器 核心寄存器有两种类型：通用寄存器（GPRs）和核心特殊功能寄存器（CSFRs）。GPRs包括16个通用数据寄存器和16个通用地址寄存器。CSFRs用于控制核心的操作并提供关于核心的状态信息。\n通用寄存器 系统寄存器（PSW，PC，PCXI） 栈管理寄存器（A[10] 和 ISP） SYSCON和CPU_ID寄存器 陷阱寄存器 (Trap registers) 上下文管理寄存器 内存保护寄存器 内存管理寄存器 调试寄存器 浮点寄存器 与核心相关的特殊功能寄存器 复位值 应注意，由于本手册描述的是TriCore®架构，而不是该架构的具体实现，因此某些复位值未给出。未提供的复位值是具体实现相关的。\nENDINIT保护 该架构支持在操作状态之前的初始化状态的概念。\n在初始化状态下，所有核心特殊功能寄存器（CSFRs）都可以使用MTCR指令进行修改。在操作状态下，只有部分CSFRs可以通过这种方式修改。其他功能在这两种状态下保持相同。\n在初始化状态下只能写入的CSFRs被描述为ENDINIT保护的。\n初始化状态和操作状态之间的转换由系统实现控制。此功能通过仅允许在初始化状态下更改关键CSFRs，增加了额外的保护级别。\n以下寄存器受ENDINIT保护：\nBTV, BIV, ISP, PMA0, PMA1, PMA2, PCON0, DCON0, SEGEN 提供了一个专为安全设计的ENDINIT保护版本。以下寄存器受SAFETY_ENDINIT保护：\nSMACON, SYSCON, COMPAT, TPS_EXTIM_ENTRY_LVAL, TPS_EXTIM_EXIT_LVAL 任务和功能 大多数嵌入式和实时控制系统都是根据一个模型设计的，该模型中中断处理程序和软件管理的任务各自被视为在自己的“虚拟”微控制器上执行。这种模型通常由实时执行体或实时操作系统（RTOS）的服务支持，这些服务位于底层机器架构的特性和功能之上。\n在TriCore™架构中，RTOS层可以非常“薄”，硬件可以高效地处理一个任务与另一个任务之间的切换。同时，该架构允许在所使用的任务模型中具有相当的灵活性。系统设计者可以选择最适合其应用需求的实时执行体和软件设计方法，架构施加的限制相对较少。\n中断系统 在TriCoreTM系统中，多个源（如外围设备或外部中断）可以向CPU或DMA通道等中断服务提供者发出中断请求。本章描述了CPU的中断处理能力，包括中断优先级方案和对向量表的访问。\n一般操作 每个中断源都会被分配一个唯一的中断优先级编号，称为服务请求优先级编号（SRPN）。在接收到来自中断源的中断请求后，SRPN会被中断控制单元（ICU）用来在多个并发中断请求之间进行优先级排序。获胜请求的SRPN作为挂起中断优先级编号（PIPN）与请求触发一起传递给CPU。CPU通过将PIPN与当前CPU优先级编号（CCPN）进行比较，决定是否接受请求的中断。如果CPU决定接受请求的中断，它会以中断确认响应，并返回已接收中断的优先级编号。随后ICU将清除请求中断的源。\nICU中断控制寄存器（ICR） ICU中断控制寄存器（ICR）包含当前CPU优先级编号（CCPN）、全局中断启用/禁用位（IE）和当前挂起中断优先级编号（PIPN）。\nCPU对中断请求的操作 CPU检查全局中断启用位ICR.IE的状态，并将当前CPU优先级编号ICR.CCPN与PIPN进行比较。只有当ICR.IE == 1并且PIPN大于CCPN时，CPU才会被中断。如果满足条件，CPU可以进入服务例程。PIPN用于确定中断向量表的入口点，并向ICU确认，ICU随后会向挂起的中断请求发送确认。\n几种情况可能会阻止CPU立即响应由ICU生成的中断请求，这些情况包括：\n中断系统被全局禁用（ICR.IE == 0）。 当前CPU优先级（CCPN）等于或高于挂起中断优先级编号（PIPN）。 CPU正在进入中断或陷阱服务例程的过程中。 CPU正在执行不可中断的陷阱服务。 CPU正在执行多周期指令。 CPU正在执行修改ICR的指令。 只有当这些条件不再成立时，CPU才会响应中断请求。\n进入中断服务例程（ISR） 当 CPU 满足所有条件来处理中断请求时，将执行以下操作以进入中断服务程序 (ISR)：：\n当前任务的上文被保存。 当前PC保存到返回地址（A[11]）中。 如果处理器之前没有使用中断栈（PSW.IS = 0），则A[10]栈指针会被设置为中断栈指针（ISP）。随后栈指针位被设置为使用中断栈：PSW.IS = 1。 I/O模式设置为Supervisor模式，这意味着所有权限被启用：PSW.IO = 10B。 当前的保护寄存器集被设置为0：PSW.PRS = 000B。 调用深度计数器（PSW.CDC）被清除，调用深度限制选择器被设置为64：PSW.CDC = 0000000B。 调用深度计数器已启用，PSW.CDE = 1。 PSW安全位设置为SYSCON寄存器中定义的值：PSW.S = SYSCON.IS。 禁止对全局寄存器A[0]、A[1]、A[8]、A[9]的写入权限：PSW.GW = 0。 中断系统被全局禁用：ICR.IE = 0。旧的ICR.IE被保存到PCXI.PIE中。 当前CPU优先级编号（ICR.CCPN）被保存到前一个CPU优先级编号（PCXI.PCPN）字段中。 挂起中断优先级编号（ICR.PIPN）被保存到当前CPU优先级编号（ICR.CCPN）字段中。 访问中断向量表以获取ISR的第一条指令。 注意 : 每当进入中断服务例程或陷阱处理程序时，都会禁用全局寄存器写入权限（PSW.GW == 0）。这确保所有陷阱和中断默认情况下都假设它们没有写入受PSW.GW控制的寄存器的权限。\n进入中断服务例程，中断系统全局禁用，当前 CPU 优先级 (CCPN) 设置为正在服务的中断的优先级 (PIPN)。用户需要自行再次启用中断系统，并可以选择修改优先级编号CCPN，以实现中断优先级级别或处理特殊情况。有关详细信息，请参见《使用TriCore中断系统》。\n开启中断的方式如：\nENABLE指令，ENABLE将ICR.IE设置为1（中断系统启用）。\nBISR（Begin Interrupt Service Routine）指令也会启用中断系统，将ICR.CCPN设置为新值，并保存被中断任务的下文。\nMTCR（Move To Core Register）指令修改中断启用位（ICR.IE）和当前CPU优先级编号（ICR.CCPN）。\nENABLE、BISR和DISABLE（禁用中断）指令都是在 CPU完全执行完这些指令后才允许接受中断请求的 。这避免了流水线副作用，并消除了在这些指令之后使用ISYNC（同步指令流）的需要。MTCR是个例外，必须在之后跟随ISYNC指令。\n退出中断服务例程（ISR） 当ISR通过RFE（Return From Exception）指令退出时，硬件会自动恢复上文。上文包括保存前一个CPU优先级编号（PCXI.PCPN）和前一个全局中断启用位（PCXI.PIE）。这些相应位中的值将如下使用：\n将PCXI.PCPN写入ICR.CCPN，以将CPU优先级编号恢复为中断前的值。 将PCXI.PIE写入ICR.IE，以恢复该位的状态。 被中断的例程随后将继续执行。\n中断向量表 中断服务例程（ISR）通过中断向量表与特定优先级的中断关联。中断向量表是中断服务例程（ISR）入口点的数组。中断向量表存储在内存中。\n当CPU响应中断时，它会计算一个中断向量表中的地址，该地址与中断的优先级（ICR.PIPN位字段）相对应。此地址被加载到PC中，CPU开始执行此地址的指令。此地址的代码是所选中断服务例程（ISR）的起始部分。根据ISR的代码大小，中断向量表可能只存储ISR的初始部分，例如将CPU引导到ISR其余部分的跳转指令，这些部分可能存储在内存的其他地方。\n中断向量表基地址寄存器 （BIV）存储中断向量表的基地址。中断向量在表中按优先级递增的顺序排列。在启用中断之前进行, BIV寄存器可以在系统初始化阶段使用MTCR指令进行修改（BIV受ENDINIT保护）。通过这种方式，可以使用多个中断向量表，并通过更改BIV寄存器的内容在它们之间切换。\n当发生中断时，CPU从ICU.PIPN和BIV寄存器的计算出相应中断服务例程的入口点。有 两种向量表配置可用，向量之间的间隔分别为32字节或8字节 。间隔由BIV寄存器的向量大小选择（BIV.VSS）位选择。\n为了生成中断向量表中的指针，PIPN向左移位五位（VSS=0）或三位（VSS=1），然后与BIV寄存器中的地址进行“或”运算，以生成指向中断向量表的指针。ISR的执行从这个地址开始。由于这种操作，建议BIV寄存器的[14:5]位（VSS=0）或[12:3]位（VSS=1）设置为0。\n1if (BIV.VSS == 1’b0) 2 ISR_Entry_PC = {BIV[31:1],1’b0} | {PIPN\u0026lt;\u0026lt;5}; 3else 4 ISR_Entry_PC = {BIV[31:1],1’b0} | {PIPN\u0026lt;\u0026lt;3};如果一个中断处理程序非常短，它可能完全适合在向量代码段中提供的指令字内。否则，存储在入口位置的代码可以跨越多个向量条目，或者包含一些初始指令，然后跳转到处理程序的其余部分。有关跨越向量条目的中断服务例程的详细信息，请参见“跨越向量条目的中断服务例程”。\nBIV寄存器允许中断向量表位于可用代码内存的任何位置。上电时的默认值取决于具体的实现。可以在系统初始化阶段使用MTCR指令写入BIV寄存器，这通常是在启用中断之前进行。还可以通过修改BIV寄存器的内容，实现多个中断向量表之间的切换。\n使用TriCore中断系统 以下部分包含一些示例，展示了如何使用TriCore架构灵活的中断系统来解决典型和特殊应用的需求。\n跨向量条目扩展中断服务例程（ISRs） 由于向量条目并未与中断源直接绑定，因此很容易跨越多个向量条目位置来扩展中断服务例程，如之前图22所示。如果中断处理程序的剩余部分无法容纳在入口位置之间的八个字内，则扩展可消除跳转到中断处理程序剩余部分的需要。。\n要注意的是，与跨越服务例程相关的条目所对应的优先级号，不能用于请求同一服务提供者服务的活动服务请求节点（SRNs）。\n在图22中，向量位置三和四被第二条目的服务例程覆盖。因此，这些优先级号不能分配给请求CPU服务的SRNs，虽然它们可以用于请求其他服务提供者。接下来的可用向量条目是条目五。\n使用这种技术会增加系统中所需的优先级号码范围，但需要相应调整向量表的大小。\n中断优先级组 中断优先级组描述了一组中断，这些中断的服务例程不能相互中断。这些组可以通过TriCore中断系统架构轻松创建。\n当CPU开始服务某个中断时，中断系统会全局禁用，并且CPU优先级CCPN设置为正在服务的中断的优先级。这将阻止所有对其他中断的处理，直到通过软件重新启用中断系统，或通过RFE（异常返回）指令终止服务例程。\n注意： RFE指令会自动恢复ICR.IE位的先前状态。这将是1（ICR.IE = 1），否则该中断就不会被处理 。\n当中断服务例程（ISR）软件在不改变CCPN的情况下重新开启中断（设置ICR.IE），其效果是，所有优先级等于或低于CCPN的中断请求仍然被阻止服务。这包括当前中断的再次发生；即它不能中断此服务。\n然而，具有比CCPN更高优先级号码的每个请求都会中断此ISR。一个潜在的问题（在TriCore架构中可以轻松克服）是，应用程序需求通常要求相似重要性的中断请求被分组在一起，使得该组中的任何请求都不能中断同组其他成员的ISR。\n在中断系统中创建这些中断优先级组非常容易。对于定义的一组中断请求，其相应服务例程的软件在再次启用中断系统之前，将CCPN设置为该组中使用的最高SRPN的号码。如图23所示。\n优先级号为11和12的中断请求构成一个组，而优先级号为14到17（包括14和17）的中断请求构成另一个组。每次在处理第一个组中的一个中断时，服务例程会将CCPN设置为该组中的最高优先级号12，然后再重新启用中断系统。每次处理第二个组中的一个中断时，服务例程会将CCPN设置为17，然后再重新启用中断系统。例如，如果处理了中断14，它只能被优先级高于17的请求中断，而不会被来自其自身优先级组的请求或优先级较低的请求中断。\n可以看出该系统的灵活性及其优于固定优先级系统的地方。在上述示例中，优先级号为13的中断请求形成了一个单独的“组”。 在每个服务例程中将CCPN设置为最大值255的效果与不重新启用中断系统的效果相同 ；即所有中断请求都可以被视为属于同一个组。\n中断优先级水平的灵活性范围从所有中断在一个组内，到每个中断请求形成自己的组，以及所有介于两者之间的可能组合。\n将ISR分为不同的优先级 中断服务例程（ISR）可以很容易地分为不同优先级的部分 。例如，一个中断被设置为非常高的优先级，因为对事件的响应时间和反应非常关键，但该服务例程中的进一步操作可以在较低优先级上运行。在这种情况下，服务例程将被分为两个部分，一部分包含关键操作，另一部分包含较不关键的操作。\n首先将中断节点的优先级设置为高优先级，以便当中断发生时，立即执行必要的操作。然后将该中断的优先级降低，并在仍处于服务例程中时通过软件再次设置中断请求位（表示有待处理的中断）。返回被中断的程序将终止高优先级的服务例程。当CPU的优先级低于挂起中断的优先级时，该待处理中断将被服务。进入服务例程后（此时服务例程在程序存储器的不同地址），执行剩余的低优先级中断操作。\n在其他情况下，服务请求的优先级可能较低，因为对事件的响应时间并不关键，但一旦获得服务则不应被中断。为了防止任何中断，TriCore架构允许在ISR内提高服务请求的优先级，并且允许完全禁用中断。\n即对于同一个isr，进入中断handler前后设置不同的优先级\n使用不同的优先级处理相同的中断源 对于某些应用程序，中断请求的优先级相对于其他请求并不是固定的，而是取决于系统的当前情况。这可以通过在不同时间为中断源分配不同的服务请求优先级号码（SRPNs）来实现，以满足应用程序的需求。通常，针对该中断的ISR会根据优先级执行不同的代码。\n在传统的中断系统中，ISR必须检查当前中断请求的优先级，并根据优先级执行适当的代码部分，这可能导致对请求的响应延迟。然而，在TriCore系统中，中断会自动为不同的优先级提供不同的向量条目。因此，不需要在ISR中进行额外的检查和跳转，从而减少了中断延迟。\n如果ISR与中断的优先级无关，则需要在该中断的每个向量条目上跳转到通用ISR代码。\n为一个中断使用不同优先级号码时，在创建向量表时需要考虑这一点。\n中断控制寄存器 ICR： ICU Interrupt Control Register 中断控制寄存器 ICR.PIPN [23:16] : 挂起的中断优先级号\n0：无效，1：最低，0xff:最高\nICR.IE [15] : 中断系统使能/禁用位\nICR.CCPN [7:0] : 当前 CPU 优先级号\nBIV： Base Interrupt Vector Table Pointer 基本中断向量表指针 ICR.BIV [31:1] : 中断向量表的基地址\nICR.VSS [0] : 向量间距选择\n0 -\u0026gt; 32byte, 1 -\u0026gt; 8byte\n中断路由器 (Interrupt Router, IR) 本章描述了中断路由器模块，该模块将来自外部资源、内部资源和软件的中断（在此称为 服务请求 ）调度到CPU和DMA模块（在此称为 服务提供者 ）。\n本文档的范围 本文档适用于TC3xx，并涵盖以下主题：\n中断系统架构 中断系统配置 中断路由器操作 功能列表 以下列表显示了中断路由器模块的主要功能：\n支持最多1024个服务请求的中断系统 每个ICU1) / 服务提供者支持多达255个服务请求优先级别 支持多达 8个ICU / 服务提供者 （ 397有只有7个**）** 每个实现的CPU / DMA模块（服务提供者）都有一个专用ICU 低延迟仲裁 - 从接收到服务请求到发送给服务提供者，耗时仅为三到四个时钟周期 每个外设中断都有一个专用的服务请求节点（SRN） 每个SRN都有一个可编程的8位优先级向量 每个SRN可以映射到一个已实现的ICU / 服务提供者 当配置的服务提供者确认中断时，SRN将由硬件自动清除 支持完整性保护的中断系统 每个CPU有8个通用服务请求（GPSR），可用作软件中断（不分配给外设或外部中断） 服务请求广播寄存器（SRB），可同时向多个服务提供者发出通用服务请求（软件中断） 服务请求的优先级依赖屏蔽（针对CPU，相关控制寄存器包含在CPU中） 具有滤波模式和触发模式（如下降沿、上升沿、高电平或低电平）的外部中断。模式可在运行时配置3) CPU唤醒支持（当CPUx处于IDLE状态时，将服务请求信号发送至SCU以唤醒CPUx） 与TC2xx的差异 以下功能变化是从Aurix到TC3xx引入的：\n通用服务请求组：每组服务请求节点的数量从4个变更为8个SRN（详见 16.7 “通用服务请求，服务请求广播”） 广播寄存器：广播寄存器的位图已适应新的GPSR SRN数量（详见 16.7 “通用服务请求，服务请求广播”）。 广播寄存器：每个广播寄存器现在都有一个专用的ACCEN寄存器（详见 16.7.3 “SRBx寄存器的访问保护（ACCEN_SRBx）”）。 SRCx：引入了SRCx[31:0]的访问保护（每个实现的TOS编码/ICU都有一个ACCEN寄存器，详见 16.4.1.3 “SRC寄存器的保护”）。 SRC.ECC：ECC位字段的大小从6位更改为5位（详见 16.4.1.1 “通用服务请求控制寄存器格式”）。 SRC.TOS：TOS位字段的大小更改为3位（详见 16.4.1.1 “通用服务请求控制寄存器格式”）。 SRC偏移和索引编号方案更改：SRC被映射到1024 * 32位范围内。索引编号（0-1023）等于SRC的32位偏移量（详见 16.4.1.1 “通用服务请求控制寄存器格式”）。 检测到信号到保留TOS的服务请求时，会向SMU发出警报。 SRC寄存器映射到IR地址映射已重新设计。 概述 中断请求可以由CPU或DMA模块服务 。本文档中使用“服务请求”而非“中断请求”，因为它们可以由任一服务提供者服务。\n中断系统在中断路由器模块中实现，该模块包括服务请求节点（SRNs : Service Request Nodes ）、中断控制单元（ICU : Interrupt Control Units ）以及支持软件开发的附加功能。\n如图173所示，每个能够生成服务请求的模块都连接到中央中断路由器模块中的一个或多个服务请求节点（SRN）。中断路由器模块还包括多个通用服务请求节点（SRN），这些节点可用于软件（SW）触发的服务请求。\n每个SRN包含一个服务请求控制寄存器（SRC），用于配置服务请求，例如优先级、映射到一个可用的服务提供者。\n每个SRN连接到中断路由器模块中的所有ICU，在那里，SRN的控制寄存器设置定义了目标服务提供者和服务请求的优先级。\n每个ICU处理来自映射到该ICU的SRN的竞争服务请求之间的中断仲裁。\n每个ICU连接到一个服务提供者（CPU或DMA模块），在仲裁轮中，ICU向服务提供者提供有效的获胜服务请求/SRN，并且服务提供者在处理服务请求时向ICU发回信号。\n服务请求节点 (SRN) 中断路由器模块中的每个服务请求节点（SRN）包含一个服务请求控制（SRC）寄存器和接口逻辑，该接口逻辑将其连接到中断路由器模块外部的触发单元以及中断路由器内部的中断仲裁总线（参见图173）。\n服务请求控制寄存器 中断路由器模块中的所有服务请求控制寄存器格式相同。通常，这些寄存器包含以下信息：\n启用/禁用信息（SRE，第9页） 服务请求设置位和服务请求清除位（SETR，CLRR，第9页） 软件粘滞位（SWS），用于指示软件发起的服务请求（SWS，第12页） 服务请求优先级向量（SRPN，第10页） 服务请求目标/服务提供者（TOS，第9页） 服务请求状态位（SRR，第9页） 向安全管理单元（SMU）信号完整性错误（第11页） 中断溢出位（IOV，第11页） 除了可以通过硬件由相关的触发单元激活外，每个SRN还可以通过软件通过两个软件发起的服务请求控制位进行设置或重置。\n通用服务请求控制寄存器格式 服务请求控制寄存器（SRC ： Service Request Control Register ） 本章描述了服务请求控制寄存器（SRC）的特性。\n请注意：一些模块在模块级别有额外的中断相关控制寄存器（例如，中断状态、设置清除或启用寄存器）。这些模块寄存器在相应模块章节中描述。\n服务请求控制寄存器 i ，SRCi (i=0-1023)，(00000H + i*4)\nSRC.SRPN [7:0] : 服务请求优先级\n0：最低，0xff：最高；cpu的最小值为1，dma最小值0\nSRC.SRE [10] : 服务请求使能/禁用位\nSRC.TOS [13:11] : 服务请求类型\n0：cpu0，1：DMA，2-6：cpu1-5\nSRC.ECC [20:16] : 错误纠正码\nSRC.SRR [24] : 服务请求挂起标志位\nSRC.CLRR [25] : clear SRR 清楚服务挂起位\nSRC.SETR [26] : set SRR 设置服务器请求位\nSRC.IOV [27] : hw中断触发溢出标志位\nSRC.IOVCLR [28] : clear IOV\nSRC.SWS [29] : 软件中断标志位\nSRC.SWSCLR [30] : clear SWS\n更改SRN配置 默认情况下，所有服务请求节点（SRN）均被禁用。要使用服务请求节点，必须通过将SRC.SRE位设置为 1来配置并启用它。\n服务请求节点可以针对中断服务提供者目标（SRC.TOS）和服务请求优先级编号（SRC.SRPN）进行配置。启用SRN后，可以通过以下步骤更改TOS和/或SRPN位字段：\n禁用SRN（设置SRC.SRE= 0）。 检查SRN是否已禁用（读回SRC.SRE并检查SRE= 0）。 检查寄存器LWSRx（最后的获胜服务请求，读取/轮询LWSRx，参见下述说明）： 如果LWSRx.STAT= 0或LWSRx.SRPN或LWSRx.ECC不再等于旧的SRC值，则继续进行下一步（更改SRC值）。 如果LWSRx.STAT= 1且LWSRx.SRPN和LWSRx.ECC等于（旧的）SRC值，则再次检查LWSRx。 更改SRC.TOS和/或SRC.SRPN位字段。 启用SRN（SRC.SRE= 1，写入SRC.SRE）。 如果需要重新配置的服务请求在禁用时处于挂起状态，可能该服务请求已被仲裁并提供给中断服务提供者（CPU或DMA）。在这种情况下，应延迟启用重新配置的SRN，直到上述LWSRx轮询算法完成，以确保刚禁用的SRN配置不再存在于中断系统中。如果禁用的服务请求节点映射到TriCore，读取/轮询序列的时间是非确定性的。如果ISP是DMA模块，则进入和确认在同一周期内发出。LWSRx中的 x表示需要检查与TOS设置相关的LWSR寄存器（TOS=0 -\u0026gt; LWSR0，TOS=1 -\u0026gt; LWSR1，\u0026hellip;）。\nSRC寄存器的保护 SRC寄存器通过片上总线主控TAG-ID保护（详见第16.8.1章）进行写保护。此保护由中断路由器控制寄存器ACCEN_CONFIG和ACCEN_TOSx控制。\nSRC[31:16]：受ACCEN_TOSx（x = SRC.TOS）写保护。 SRC[15:0]：受ACCEN_CONFIG写保护。 将SRC写保护划分为SRC[31:16]和SRC[15:0]的不同写保护寄存器，允许为所有服务请求节点的配置（通常在运行时是静态的）和在运行时由相关软件任务作为正常应用程序一部分使用的服务请求节点控制寄存器定义不同的保护配置（例如软件中断）。\n对SRC[31:16]进行写访问时发生访问保护违规\n当使用32位数据访问写入SRC寄存器时，仅更新未发生ACCEN保护违规的SRC寄存器部分：\n对SRC[31:16]（ACCEN_TOSx）和SRC[15:0]（ACCEN_CONFIG）的违规 不更新SRC寄存器，向SMU发送警报。 对SRC[31:16]（ACCEN_TOSx）的违规： 不更新SRC[31:16]，更新SRC[15:0]，向SMU发送警报。 对SRC[15:0]（ACCEN_CONFIG）的违规： 更新SRC[31:16]，不更新SRC[15:0]，向SMU发送警报。 SRC配置的访问保护（SRC[15:0]）\n所有SRC寄存器的下半部分SRCx[15:0]通过ACCEN_CONFIG寄存器进行写保护。这意味着，ACCEN_CONFIG的配置定义了哪些TAG ID被允许写入所有已实现的SRC寄存器的下半部分。需要注意的是，对SRC.TOS、SRC.SRE、SRC.SRPN（均映射在SRC[15:0]）的修改也会间接修改SRC.ECC位字段。\n背景 / 用例（ACCEN_CONFIG保护的SRC[15:0]）\nSRCx[15:0]包括服务请求节点的配置位/位字段，通常：\n在启动期间配置 在运行时是静态的 不应由非安全软件任务修改 ACCEN_CONFIG允许配置仅特定的TAG ID可以重新配置SRC配置，例如CPUx.DMI安全TAG ID。\nSRC控制位的访问保护（SRC[31:16]）\nSRC寄存器的上半部分SRC[31:16]通过一个ACCEN_SRC_TOSx寄存器进行写保护。保护SRN的ACCEN_SRC_TOSx寄存器由SRN的SRC.TOS配置选择：\nSRCx.TOS = 0 -\u0026gt; SRC寄存器通过ACCEN_SRC_TOS0进行写保护 SRCx.TOS = 1 -\u0026gt; SRC寄存器通过ACCEN_SRC_TOS1进行写保护 SRCx.TOS = 2 -\u0026gt; SRC寄存器通过ACCEN_SRC_TOS2进行写保护 \u0026hellip; 对于“保留”TOS编码，没有实现ACCEN_SRC_TOSx寄存器。这意味着，对于配置了保留TOS编码的SRCy，SRCy始终可以写入。服务请求到未实现的ISP（SRC.TOS=保留）将作为警报发送到SMU。\n背景 / 用例（ACCEN_SRC_TOSx保护的SRC[31:16]）\nSRCx[31:16]包括服务请求节点的控制位/位字段，可用于在运行时：\n设置服务请求（软件中断） 清除服务请求 清除中断溢出或粘滞位 通过SRC.ECC位字段注入ECC错误 如果没有这个机制，任何CPU任务和任何具有主功能的片上总线IP都可以生成对任何CPU的SW中断和/或清除任何中断。该机制使系统能够以“每CPU”为粒度封装软件任务，并限制不正确软件的副作用仅影响执行该软件的CPU。\n例如：所有映射到CPU0的SRNs（TOS=0）都通过ACCEN_SRC_TOS0进行写保护。这意味着，通过ACCEN_SRC_TOS0的配置，定义了哪些TAG ID被允许向CPU0设置或清除服务请求。ACCEN_SRC_TOS0可以配置为仅允许CPU0任务向CPU0设置软件中断。这确保了任何其他CPU或DMA通道上的损坏软件不会通过永久软件中断影响CPU0。\n在这种情况下，如果发生访问保护错误，写入操作将被静默忽略，并向SMU发送错误信号。除向SMU发出信号外，不会生成其他错误、中断或陷阱。\n请求设置和清除位（SETR，CLRR） SETR位：写入1会将SRR位设置为1。 CLRR位：写入1会将SRR位清除为0。 同时写入1到SETR和CLRR时，SRR位不会改变。 写入SETR或CLRR的值不会被存储。 写入0对这些位没有影响。 读取这些位时总是返回0。 使能位（SRE） SRE位允许中断参与选定服务提供者的仲裁。它不会启用或禁用请求标志SRR的设置；请求标志可以通过硬件或软件（通过SETR）独立于SRE位的状态进行设置。这使得服务请求可以通过硬件自动处理或通过软件轮询处理。\nSRE = 1： 如果SRE = 1，待处理的服务请求将传递给指定的服务提供者进行中断仲裁。当服务请求被服务提供者确认时，硬件会自动将SRR位重置为0。在这种情况下，建议软件不要修改SRR位，以避免由于硬件控制该位导致的意外行为。 SRE = 0： 如果SRE = 0，待处理的服务请求不会传递给服务提供者。软件可以轮询SRR位以检查是否有服务请求待处理。要确认服务请求，SRR位必须通过软件写入1到CLRR来重置。 在本文档中，“active source”指的是其请求使能位SRE设置为1，以允许其服务请求参与中断仲裁的SRN。\n服务请求标志（SRR） 当设置时，SRR标志表示有一个服务请求待处理。它可以通过硬件直接设置或重置，或通过软件使用SETR和CLRR位间接设置或重置。通过软件直接写入该位没有效果。 SRR可以由硬件或软件设置或清除，无论SRE位的状态如何。然而，只有当SRE位设置为1时，请求才会被转发进行服务。如果SRE = 1，待处理的服务请求将参与设备TOS位字段选择的服务提供者的中断仲裁。如果SRE = 0，待处理的服务请求将被排除在中断仲裁之外。 当服务请求被确认并服务后，硬件会自动重置SRR。软件可以轮询SRR以检查待处理的服务请求。在这种情况下，SRR必须通过软件写入1到CLRR来重置。 清除待处理的服务请求标志SRR和启用相应的服务请求节点（SRN）应分两步/两次写入：首先清除SRR标志（SRC.CLRR），然后启用（SRC.SRE）。\n类型服务控制 (TOS) 每个 TriCore CPU 和每个系统 DMA 实例都可以作为中断服务提供者（ISP）。服务请求节点（SRN）可以通过 TOS 位字段映射到一个确切的 ISP。\nTOS 配置将服务请求映射到：\n中断服务提供者（CPUx，DMA） 与 ISP 相关的中断路由器内部中断控制单元（ICUx），例如 TOS=0 映射到 ICU0，TOS=1 映射到 ICU1，\u0026hellip; 一个 ACCEN_SRC_TOSx 写保护寄存器，例如 TOS=0 映射到 ACCEN_SRC_TOS0，\u0026hellip; 如果 SRN 启用且配置为保留 TOS 编码，HW 或 SW 触发该 SRN 将通过警报发送到 SMU，不会有进一步的操作。\n服务请求优先级号 (SRPN) SRPN 定义了服务请求相对于同一服务提供者的其他请求源的优先级，以及相对于服务提供者本身的优先级。\n对于映射到相同服务提供者（相同 TOS 配置）的每个活动 SRN：\n可以具有唯一的 SRPN 值 可以具有非唯一的 SRPN，以赋予一组服务请求相同的优先级 对于具有相同 SRPN 的服务请求组，执行顺序无法定义 如果 SRN 未激活（即 SRE 位为 0），则 SRPN 配置没有限制 服务提供者是 CPU：\n服务请求通过位于每个 CPU 的中断向量表与服务请求优先级号相关联。这意味着 ** CPU 中断向量表按优先级号排序** 。这与传统的中断 CPU 架构不同，传统架构的中断向量表按中断源排序。CPU 中断向量表允许单个外设为不同目的设置多个优先级。 对于 CPU，SRPN 值 0000H 是一个特殊值。SRPN 为 0000H 的服务请求将被 CPU 忽略。CPU 不会确认该请求，相关的服务请求节点将因此不会被清除。由于优先级 0 是最低的服务请求优先级，它不会阻塞中断路由器仲裁。\nTriCore CPU 提供灵活的中断表对齐，可配置 8 字节或 32 字节的向量间距。另请参阅 CPU chapter\n服务提供者是 DMA：\n服务请求通过服务请求优先级号与 DMA 通道号相关联： SRPN=x 将触发 DMA 通道 x（如果 DMA 通道 x 已实现） 仅 SRPN 号在 0 到最大通道号之间会触发相关的 DMA 通道。SRPN 号大于最大通道号的请求将作为其他待处理服务请求处理，但不会触发 DMA 通道。 示例：\n对于一个 16 通道的 DMA 模块，SRPN 号 00H 将触发通道 0，07H 将触发通道 7。所有 SRPN 大于 0FH 的请求将作为其他服务请求处理，但不会触发通道。 对于一个 64 通道的 DMA 模块，SRPN 号 00H 将触发通道 0，17H 将触发通道 23，3FH 将触发通道 64。所有 SRPN 大于 3FH 的请求将作为其他服务请求处理，但不会触发通道。 损坏的 SRC 配置会触发不存在的 DMA（由于 TOS、SRPN 或SRE 损坏），ICU EDC 检查（第 16.4.1.9 章）会检测到该配置损坏的服务请求，并在中断服务提供商（此处为：DMA）确认该服务请求后立即向 ICU 发出信号。 由于 TOS，SRPN 或 SRE 的损坏而触发不存在的 DMA 的损坏 SRC 配置，将由 ICU EDC 检查检测，并在服务请求被服务提供者（DMA）确认后向 ICU 发送警报。 ECC 编码 (ECC) SRC.ECC 位字段会在以下情况下由服务请求节点（SRN）更新：\n对 SRC[31:0] 进行写操作或读-修改-写操作。 对 SRC[15:0] 进行写操作（16 位写入）。 对 SRC[15:8] 或 SRC[7:0] 进行写操作（字节写入）。 在执行 32 位写入或读-修改-写入操作时，ECC 位字段将使用计算出的 ECC 更新，写入到 ECC 位字段的数据将被忽略。\nECC 编码涵盖：\nSRC.SRPN，SRC.TOS，SRC.SRE 的新值，以及写入的 SRN 的内部 10 位索引号。 ECC 没有永久性的检查。每当挂起的服务请求被选定的（TOS）服务提供者接受为下一个处理的服务请求时，ECC 将进行检查。\nECC 错误检测机制：\nECC 错误可以通过以下方式插入（修改 ECC 位字段）： 写入 SRC[23:16]（字节写入） 写入 SRC[31:16]（16 位写入） 在当前实现中，ECC 代码仅用于错误检测。检测到的错误会报告给 SMU，但不会进行纠正。\nECC 代码：\n用于中断路由器错误检测机制的 ECC 代码是 Hsiao 22_5 代码，具有双重错误检测（DED）能力：\n1 2GEN_ENC22_5 : if (word_width_g/(nb_mems_g*ecc_granularity_g)) = 22 and 3(nb_check_bits_g = 5) generate cmr22_5: for i in 0 to nb_check_bits_g - 1 generate 4CODE_MATRIX_ROWS(i) \u0026lt;= code_rows_22_5(i); end generate; end generate; 5 6type rows_22_5_t is array (4 downto 0) of std_ulogic_vector(21 downto 0); constant 7code_rows_22_5 : rows_22_5_t := (\u0026#34;0001001011001011011011\u0026#34;, 8\u0026#34;0010010101010101101101\u0026#34;, \u0026#34;0100100110100110110110\u0026#34;, 9\u0026#34;1000111000111000111111\u0026#34;, \u0026#34;1111000000111111000111\u0026#34; 10); 中断触发溢出位 (IOV) IOV 位由硬件设置，当以下两个条件都为真时：\n服务请求处于挂起状态。 新的服务请求通过中断触发或 SETR 位触发。 中断触发溢出清除位 (IOVCLR) 中断触发溢出清除位（IOVCLR）用于清除 IOV 位。通过向 IOVCLR 位写入 1，可以清除 IOV 位。\n软件粘滞位 (SWS) 当 SETR（请求设置位）被写入 1 时，软件粘滞位（SWS）将被设置。\n软件粘滞清除位 (SWSCLR) 软件粘滞清除位（SWSCLR）用于清除 SWS 位。通过向 SWSCLR 位写入 1，可以清除 SWS 位。\n模块中断请求触发到服务请求节点 (SRN) 的映射 所有模块中断请求都映射到中断路由器中的服务请求节点（SRN）。每个模块中断请求都有一个专用的服务请求节点（SRN）。\n每个 SRN 在中断路由器模块内都有一个唯一的 SRN 索引号。索引号并不是中断路由器模块本身功能所必须的。索引号可以用于通过 OTGM 功能选择一个服务请求节点进行观察。\n服务请求控制（SRC）寄存器的索引号可以直接从其在 SRC 地址范围内的地址偏移量中计算出来，详见第 16.5.1 章。\n中断路由器模块有一个 1024 个中断触发输入向量。每个中断触发输入向量位 [x] 与 SRN 索引号 x 的一个 SRN 相关联。这意味着在中断触发输入向量位 [x] 上的触发脉冲将触发 SRN [x]。\n中断触发信号的正边沿被解释为中断触发。详见第 16.5.3 章。\nSRC 索引号 每个服务请求节点（SRN）都可以通过其专用的服务请求控制寄存器（SRC）进行配置和控制\n与某个模块实例相关的 SRC 寄存器的地址在整个 Aurix 系列中都是相同的（例如，QSPI0 的中断）。\n每个 SRC 在中断路由器模块中都有一个唯一的索引号。\n服务请求控制（SRC）的索引号可以直接通过其在 SRC 地址范围内的地址偏移量来计算：\n索引号(SRC) = \u0026lt;SRC 地址偏移量\u0026gt; / 4 示例：\nSRC_BCU_SPB 的偏移量为 20Hex（见第 16.13 章） 索引号(SRC_BCU_SPB) = 20Hex / 4 = 8 与调试复位相关的中断 为了软件调试的目的，AURIX 设备需要一些仅与调试复位相关的服务请求节点（SRN）。这些 SRN 在非调试复位（例如应用复位）情况下保持其 SRC 寄存器内容和挂起的服务请求状态。结合其他与调试复位相关的调试逻辑（例如断点逻辑），这允许用户软件在应用复位后调试导致应用复位的情况。\n服务请求触发信号的时序特性 中断路由器由系统外围总线（SPB）时钟驱动。对于模块中断/服务请求触发信号到中断路由器的规则如下：\n触发信号必须与 SPB 时钟同步 中断路由器的触发输入是边沿敏感的（对正时钟边沿敏感） 触发信号脉冲的最小高电平长度为一个 SPB 时钟周期，高电平脉冲长度可以大于 1 个 SPB 时钟周期 与调试相关的触发信号脉冲应由相关模块保持高电平，直到触发被处理 中断控制单元 (ICU) 中断路由器模块包括每个服务提供者（如 CPU 和 DMA 模块）对应的一个中断控制单元 (ICU)，每个 ICU 与一个服务提供者相关联。服务请求节点 (SRN) 可以通过 SRN 的 SRCx.TOS 寄存器位字段映射到其中一个 ICU（参见图 173）。\nICU 的功能包括：\n管理映射到 ICU 的 SRN 之间竞争的服务请求的仲裁。 向服务提供者提供仲裁轮次的胜利者。 接收来自服务提供者的信息，表明哪个服务请求被接受。 检查被接受的服务请求信息（ECC 检查）。 向安全管理单元 (SMU) 发出完整性错误信号。 管理相关 SRN 中被确认的服务请求的清除。 当前实现中，ECC 代码仅用于错误检测。检测到的错误会报告给 SMU，但不会被纠正。\nICU 与 ISP 的接口 ICU 和连接的 ISP 之间的接口由中断路由器的 EDC 保护覆盖。为了增强接口的稳健性，在没有服务请求信号发送给 ISP 或 ISP 未确认服务请求给 ICU 的情况下，ICU 和 ISP 输出会被设置为默认值。\n当 VALID 信号发生卡住在高电平的错误时，CPU 将忽略默认信息（SRPN=8\u0026rsquo; h00），而 DMA 将触发通道并确认默认信息给 ICU，ICU 会通过 EDC 保护检测到此情况并向 SMU 发送警报。\n当 ACKNOWLEDGE 信号发生卡住在高电平的错误时，ICU 会采用默认值并检测到 EDC 错误。\n只要 ICU 未向连接的 ISP 发送服务请求（VALID=0），ICU 输出信号将设置为以下默认值：\nIDX = 10\u0026rsquo;h 000 PIPN/SRPN = 8\u0026rsquo;h 00 ECC = 5\u0026rsquo;h 00 只要 ISP 未确认服务请求给相关的 ICU（ACKNOWLEDGE=0），ICU 输出信号将设置为以下默认值：\nIDX = 10\u0026rsquo;h 000 PIPN/SRPN = 8\u0026rsquo;h 00 ECC = 5\u0026rsquo;h 00 ICU 控制寄存器 本节描述中断控制单元 (ICU) 寄存器。每个 ICU 包含两个控制寄存器：\nLWSR：最新获胜服务请求寄存器（第 16 页）提供有关上一次服务请求仲裁轮次的获胜者的信息。 最后确认服务请求寄存器（第 17 页）提供有关被服务提供者接受的最后一个服务请求的信息。 错误捕获寄存器（第 17 页）在 ICU 检测到 ECC 错误时捕获最后确认服务请求寄存器的内容。 LWSR：最新获胜服务请求寄存器 最新获胜服务请求寄存器 x，与 ICUx 相关。\n该寄存器提供有关上一次仲裁轮次获胜者的信息。寄存器位字段表示 ICU 向中断服务提供者提供的内容。\nLWSRx (x=0-7) 最新获胜服务请求寄存器 x，与 ICUx 相关 (0200H+x*10H)，default：0\nLWSR.PN [7:0] : Latest Winner Priority Number\nLWSR.ECC [14:10] : Latest Winner ECC\nLWSR.ID [25:16] : Latest Winner Index Number of SRN\nLWSR.STAT [31] : LWSR Register Status，是否有效\nLASR：最后确认的服务请求寄存器 最后确认的服务请求寄存器 x，与 ICUx 相关。\n最后确认的服务请求寄存器提供了有关被中断服务提供者 (ISP) 确认的最后一个服务请求的信息。寄存器位字段显示了中断服务提供者与最新确认一起发送的内容。\nLASRx (x=0-7) 最后确认的服务请求寄存器 x，与 ICUx 相关 (0204H + x*10H)，复位值: 0\nLASR.PN [7:0] : Last Acknowledged Service Request Priority Number\nLASR.ECC [14:10] : Latest Acknowledged Interrupt ECC\nLASR.ID [25:16] : Last Acknowledged Interrupt SRN ID\nECR：错误捕获寄存器 错误捕获寄存器 x，与 ICUx 相关。\n在检测到 ECC 错误时，错误捕获寄存器 (ECRx) 会捕获相关的服务请求信息。这是通过在检测到 ECC 错误时，将最后确认的服务请求 (LASRx) 寄存器的内容更新到 ECR 来实现的。ECR 始终显示检测到 ECC 错误时的最后一次 ECR 内容。\n软件可以通过写入 ECRx 来清除 ECR 位字段中的 PN，ECC，ID。错误状态 (STAT) 和错误溢出 (EOV) 位可以用作错误处理机制，并指示错误信息的丢失。如果 ECR.EOV 被软件清除，则 ECR.EOV 必须与 ECR.STAT 一起清除。如果在 ECR.EOV 清除的同时检测到新的错误，硬件会再次设置 ECR.EOV，而 ECR.STAT 则被清除。\n注意: 在当前的实现中，ECC 代码仅用于错误检测。检测到的错误会报告给 SMU，但不会被纠正。\nECRx (x=0-7)\n错误捕获寄存器 x，与 ICUx 相关 (0208H + x*10H)，复位值: 0\nECR.PN [7:0] : Service Request Priority Number\nECR.ECC [14:10] : Service Request ECC\nECR.ID [25:16] : Service Request Node ID\nECR.EOVCLR [28] : Error Overflow Bit\nECR.STATCLR [29] : Error Status Bit\nECR.EOV [30] : Error Overflow Bit\nECR.STAT [31] : Error Status Bit，错误检测标志位\n通用服务请求，服务请求广播 INT 模块提供了多个通用服务请求 (GPSR) 组，以及通过软件并行触发 GPSR 组中多个服务请求的机制（见 16.7.2 章节）。\n通用服务请求主要用于软件中断，因为它们并未映射到硬件中断触发事件\n通用服务请求 (GPSRxy) INT 模块提供了多个通用服务请求组：\n每个通用服务请求组包含八个服务请求节点 (SRN)。 通用服务请求命名为 SRC_GPSRxy。 x = 组号; y= 组内的中断号, y=0:7\nGPSR 主要用于软件中断（未映射到硬件服务请求触发器）。 GPSR 只能通过向相关的 SRC_GPSRxy.SETR 位写入 1 或通过向相关的服务请求广播寄存器 SRBx[y] 写入 1 来触发。 服务请求广播寄存器 (SRBx) 服务请求广播寄存器 (SRBx) 可用于并行向多个服务提供者（CPU 或 DMA）发送服务请求。\n每个通用服务请求组 (GPSRxy) 对应一个服务请求广播寄存器 (SRBx)。 SRBx 可用于并行触发 SRC_GPSRx 组内的多个服务请求。 SRBx 总是读取为 0。 向 SRBx[y] 写入 1 触发服务请求 GPXRxy。 向 SRBx[31:6] 写入 1 无效。 SRBx 寄存器的访问保护 (ACCEN_SRBx) 每个 SRBx 寄存器通过专用的 ACCEN_SRx0 / ACCEN_SRBx1 寄存器组进行写保护：\n每个 SRBx 寄存器都有一个相关的 ACCEN_SRBx 寄存器。 ACCEN_SRBx 的配置定义了哪个 TAG ID 可以写入相关的 SRBx 寄存器。 如果发生访问保护违规，写操作将被静默忽略，并向 SMU 报告错误。除此之外，不会生成其他错误、中断或陷阱。 系统寄存器 中断路由器模块不支持 CLC, OCS 和 KRSTx 寄存器。中断路由器支持多组访问启用 (ACCEN) 寄存器：\nINT_ACCENx：寄存器访问保护通过标准 ACCEN 寄存器实现，但包括 ACCEN_CONFIG0/1、ACCEN_SRBx0/1 和 ACCEN_SRC_TOSx0/1。 INT_CLC：中断路由器模块不支持时钟控制 (CLC) 功能。 INT_KRSTx：中断路由器模块不支持模块内核重置功能。 OCS：中断路由器不支持 OCDS 控制和状态寄存器。 中断路由器寄存器的写保护 中断路由器模块提供基于主 TAG ID 的写访问保护，作为 AURIX 安全概念的一部分。每个具有直接或间接总线主控能力的片上资源都有一个唯一的主 TAG ID，可用于标识片上总线事务的主控。\n中断路由器模块通过三个访问启用寄存器/寄存器组提供控制寄存器的写保护：\n服务请求广播寄存器的访问保护 (ACCEN_SRBx0/1)： 中断路由器模块提供一个或多个通用服务请求组 (GPSRx)。 每个 GPSRx 组都有一个专用的服务请求广播寄存器 (SRBx)，可用于并行设置组中的多个服务请求节点。 静态控制寄存器的访问保护 (ACCEN_CONFIG0/1)： ACCEN_CONFIG 提供对以下寄存器的写访问保护： 所有 SRC 寄存器的低 15 位 (SRCx[15:0])，包括 TOS、SRE 和 SRPN 位字段。 所有 ICU 错误捕获寄存器 (ECRx)。 SRC 控制寄存器的访问保护 (ACCEN_SRC_TOSy)： ACCEN_SRC_TOSy 提供对 SRCx[31:16] 的写访问保护。 内核复位寄存器 (KRST1/0, KRSTCLR) INT 模块不包括内核复位寄存器 (KRST1, KRST0, KRSTCLR)。\n注意： 中断路由器模块不支持模块内核复位。\n时钟控制寄存器 (CLC) INT 模块不包括模块时钟控制 (CLC)。\n注意： 中断路由器模块不支持时钟控制寄存器功能，这意味着不能通过 CLC 寄存器禁用中断路由器模块的时钟。\nOCDS 控制和状态寄存器 (OCS) INT 模块不包括 OCDS 控制和状态 (OCS) 寄存器。\n注意： 中断路由器模块不支持 OCS 寄存器功能。\n仲裁过程 在中断模块中，每个 ICU 都有其自己的中断总线。每个服务请求节点 (SRN) 都可以通过将 SRC.TOS 位字段设置映射到相关的 ICU / 中断总线，将其定向到一个服务提供者。\n当有第一个待处理的服务请求时，相关的中断总线将开始第一次仲裁过程。相关的中断控制单元 (ICU) 将提供在上一次仲裁过程中获胜的服务请求。\n仲裁过程使用 3-4 个系统外围总线 (SPB) 时钟周期来确定具有最高优先级编号 (SRPN) 的待处理服务请求。确切的实现方式在模块实现章节中有所描述。\n在仲裁过程中，中断总线会比较所有映射到该中断总线的待处理服务请求节点 (SRN) 的 SRC.SRPN 位字段。仲裁过程中，具有最高优先级编号的待处理服务请求被确定为获胜者，并将相关的 SRN 服务请求控制寄存器位字段值 (SRPN, ECC 和 SRN 的索引) 提供给 ICU。 ICU 将这些信息 (SRPN, ECC, SRN 索引) 提供给服务提供者。当服务提供者返回确认信息时，ICU 将进行 ECC 校验。ECC 校验使用接收到的值：ECC, SRPN, SRN 索引号，假定为 1 的 SRE 位 (SRN 启用) 以及 ICU 的 TOS 编号。\n中断路由器模块会将检测到的错误信号发送到安全管理单元 (SMU)（SMU 中的一位，涵盖所有 SRN 和 ICU 的错误）。\n当前实现中，ECC 代码仅用于错误检测，检测到的错误会报告给 SMU，但不会进行纠正。\n每个仲裁过程的时钟周期数 中断路由器的实现可以根据以下方面进行配置：\n支持的服务请求数量 (Service Request Nodes, SRN，最多可达 1024) SRPN 位大小 (8 位) 支持的服务提供者数量 (中断控制单元，ICU) 每个服务请求仲裁的时钟周期数 (3-4 个 SPB 时钟周期) 在 AURIX 产品中实现的中断路由器模块的特性在模块实现子章节中有所描述。\n第178图显示了一个中断路由器在3周期仲裁过程中的中断时序。\nCycle 1: ICU没有待处理的服务请求（因此没有仲裁轮次）。\nCycle 2: 一个模块通过向中断路由器模块中的相关服务请求节点（SRN）发送一个脉冲来触发一个服务请求。\nCycle 3-5: 在所有发送给ICU的待处理服务请求之间进行仲裁，比较所有待处理请求的服务请求优先级编号（SRPN），并确定最高优先级的请求为获胜请求。\nCycle 6: ICU将获胜的服务请求提供给服务提供者，包括SRPN，ECC和SRN索引。\nCycle 7 \u0026ndash; n-1: ICU重新仲裁，当有另一个SRN的新服务请求挂起时，如果该新请求具有更高的SRPN（更高优先级），则提供新的获胜服务请求给ICU。\nCycle 6 \u0026ndash; n-1: 中断服务提供者接收最新的获胜SRN的信息（Enter）。\nCycle n: 服务提供者确认服务请求，提供已确认的服务请求的SRPN、ECC、SRN索引信息。同时，ICU在同一个时钟周期内将信号更改为“无有效服务请求”。\nCycle n+1: ICU对确认信息进行ECC检查，包括SRPN，ECC，SRN索引、SRE=‘1’（SRN已启用）、ICU的TOS编号。如果出现不匹配，则向SMU报告完整性错误，SRPN、ECC和索引会被捕获到ECR中。硬件将清除已确认的SRN索引号的服务请求。\nCycle n+2: 如果ICU中至少有一个服务请求待处理，则在所有待处理服务请求之间进行新的仲裁。\n服务请求有效性 (Service Request Valid) ICU 通过断言 Valid 信号向 ISP 提供仲裁获胜的待处理服务请求的信息。在 ISP 断言 Enter 信号之前，将继续重新仲裁。\n服务请求进入 (Service Request Enter) 当中断服务提供者 (ISP) 接收到服务请求的有效信息后，向 ICU 发送 Enter 信号，表示它已开始准备执行相关的中断服务例程 (ISR)。ISP 可以通过 Acknowledge 信号（表示中断服务例程已经开始执行，ICU 将清除相关的 SRN）或在没有 Acknowledge 信号的情况下重置 Enter 信号（例如，当 CPU 在能够开始 ISR 之前陷入陷阱或异常时，ICU 将不会清除相关的 SRN）。\n服务请求确认 (Service Request Acknowledge) 当服务提供者开始执行 ICU 提供的服务请求时，服务提供者会向 ICU 发送确认信号 (Acknowledge)。同时，服务提供者会将已执行的服务请求的信息 (SRPN, ECC, SRN 索引号) 发送回 ICU。在同一时钟周期内，服务提供者发送确认信号，ICU 将状态更改为“没有可用的服务请求”：ICU 不会再向服务提供者提供仲裁获胜者。ICU 的这种行为确保在 SRN 被重置之前，已确认的服务请求不会再次被提供（参见图 178）。\n处理检测到的 ECC 错误 ICU 会对其从服务提供者接收到的确认信息 (TOS, SRPN, Index 和 ECC) 以及 ICU 本身的 TOS 编号进行错误检测校验。SRE 位假定为 1（SRN 已启用）。SRN 中的 ECC 覆盖了 SRC 位字段的值：SRC.SRPN, SRC.SRN 索引, SRC.SRE 和 SRC.TOS（参见图 178）。\n在当前实现中，ECC 代码仅用于错误检测，检测到的错误会报告给 SMU，但不会进行纠正。\n如果 ICU 检测到 ECC 错误：\nICU 会在错误捕获寄存器 (ECRx) 中捕获显示 ECC 错误的 ECC, SRPN 和索引，设置 ECRx.STAT 位，并在 STAT 位仍然设置时设置 ECRx.EOV 位。 ICU 通过中断路由器错误信号向 AURIX TM TC3xx 平台安全管理单元 (SMU) 发出错误信号。SMU 将此信息转发给 CPU（如果启用）。 ICU 清除 SRN 中的服务请求（由索引选择）。 收到“中断路由器中检测到 ECC 错误”信息的 CPU 可以通过错误状态位 (ECRx.STAT= 1) 识别 ICU，读取相关服务请求信息，并通过写入 1 清除 ECRx.STAT 位。CPU 还可以通过错误溢出位 (ECRx.EOV= 1) 确定是否检测到一个或多个 ECC 错误。 中断系统的使用 以下部分简要介绍了服务提供者与中断路由器 ICU 的接口。\n中断路由器中的所有 ICU 子模块具有相同的功能。\nCPU 到 ICU 接口 中断路由器模块为每个 CPU 和 DMA 模块提供了一个专用的中断控制单元 (ICU)。CPU ICU 接口由一组寄存器组成，CPU 在其中接收 ICU 提供的服务请求信息（SRPN, SRN 索引, ECC）。当 CPU 确认服务请求时，这些信息将被发送回 ICU（参见 16.4.1.8 章节）。\nCPU ICU 接口包含一个中断控制寄存器 (ICR)，该寄存器包含当前 CPU 优先级编号 (CCPN)、全局中断启用/禁用位 (IE) 和挂起中断优先级编号 (PIPN)。CPU ICU 接口的进一步细节以及 CPU 处理中断的方式可以在 CPU 章节中找到。\nDMA 到 ICU 接口 中断路由器模块为每个 DMA 模块提供了专用的中断控制单元 (ICU)。DMA 接管来自 ICU 的服务请求信息，触发相关的 DMA 通道，并立即向 ICU 确认，随后相关的 SRN 被清除。\nDMA 到 ICU 接口由一组寄存器组成，其中它接管 ICU 提供的服务请求信息（SRPN, SRN 索引, ECC）。DMA 在下一个时钟周期内向 ICU 发送确认（参见 16.4.1.8 章节）。\nDMA 通道的优先级方案与 SRPN 优先级方案相同：\nDMA 内的最低优先级：通道 0 最低优先级：SRPN = 0 软件触发的中断 (Software-Initiated Interrupts) 任何服务请求节点 (SRN) 都可以用作软件中断。软件可以通过写入服务请求控制寄存器 (SRC) 中的服务请求位 (SRR)，在任何 SRN 中设置服务请求位，从而触发服务请求。这些服务请求将通过与硬件触发的服务请求相同的机制处理。一旦在 SRN 中设置了 SRR 位，软件触发的服务请求和硬件触发的服务请求将无法区分。因此，软件应该仅使用未用于硬件触发服务请求的 SRNs 和中断优先级编号。\n设备为每个 TriCore CPU 提供了一组通用服务请求 SRNs，每个组包括 8 个 SRNs，这些 SRNs 不连接到内部或外部的硬件触发信号，因此只能用作软件中断或软件触发的服务请求。这些 SRNs 被称为通用服务请求节点 (SRC_GPSRxy, x=组号, y=0-7)。\n此外，任何未使用的 SRN 也可以用于生成软件中断。\n外部中断 (External Interrupts) 有 8 个 SRNs (Int_SCUSRC[7:0]) 保留用于处理外部中断。外部 GPIO 端口输入信号（例如边沿触发或电平触发）的设置，包括中断请求的触发方式，受外部请求单元 (ERU) 控制。ERU 的功能在 SCU 章节中有详细描述。\n使用案例 (Use Case Examples) 本节展示了中断系统的使用案例和 OTGS 的使用案例。\n中断处理程序的使用案例 (Use Case Example Interrupt Handler) 本节解释了如何组织 TriCore 中断向量表。当 TriCore 接受中断时，中断向量表的入口地址由 TriCore 寄存器 BIV（基中断向量表指针）和该中断的优先级编号 (PIPN) 计算得出。TriCore TC1.6P 和 TC1.6E 架构提供了配置向量表条目间距的可能性，可以设置为 32 字节（参见下图 a（图 179））或 8 字节（参见下图 b（图 179））。第三种选择是通过屏蔽 PIPN 将向量表缩减为单个条目（参见下图 c（图 179））。\nc): 单入口地址，软件区分中断handler\n通过使用32字节配置，小型中断程序可以直接在向量表中实现。它们甚至可以跨多个向量条目实现（参见TriCore架构手册）。如果向量表可以位于 TriCore 程序端内存中，这种快速中断处理就很有用。8字节配置减少了向量表的大小。每个向量条目仅包含一个跳转指令或一个调用和返回作为16位操作码指令。 TriCore编译器通过关键字或函数支持这种类型的中断向量表生成 。如果BIV屏蔽了PIPN，使得任何中断地址计算结果相同，则可以配置最小的向量表。例如：\n1__mtcr(BIV,0x80000001 | 0xFF\u0026lt;\u0026lt;3); // 将值写入核心寄存器BIV 这将BIV寄存器配置为使用一个通用的单个条目，其中函数 interruptHandler位于此处，通过使用函数指针数组分支到特定的中断例程。如果使用一个指向数组的指针，该数组可以快速切换。\n初始化和安装中断的步骤描述\n定义ISR指针数组：最多可以有255个中断。 定义指向ISR指针数组起始位置的指针。 开始编写 interruptHandlerInstall函数：此函数用于在数组中安装中断。所需信息是中断优先级和ISR入口地址。 将ISR入口地址存储在数组中。 编写 interruptHandler函数：在中断发生后立即调用此函数，并分支到特定的中断例程。 分支到特定的中断例程。 在ISR处理完毕后执行返回命令。 初始化和安装中断的C代码示例\n1(1) void (*isr_pointer_array[256])(void); 2(2) void (**isr)(void) = isr_pointer_array; 3(3) void interruptHandlerInstall(long int SRprio, long int addr) { 4(4) *isr_pointer_array[SRprio] = addr; 5} 6(5) void interruptHandler(void) { 7(6) isr[__mfcr(ICR) \u0026amp; 0xFF](); 8(7) asm (\u0026#34;rfe\u0026#34;); // 从事件返回 9}在这个例子中，中断入口地址存储在数据数组中，而不是将值编码到指令中。interruptHandlerInstall函数负责组织在该数组中安装中断（参见在STM章节中的模块用例示例）。这种向量表生成方式有时比8字节配置更灵活，并且不需要编译器对中断的特定支持。\n在中断能够发生之前，必须全局启用中断系统。中断控制寄存器（ICR）包含全局中断使能位（ICR.IE），该位启用CPU服务请求系统。大多数编译器支持使用类似以下的属性：__enable(); 来设置此位。详细信息请参见架构手册。\n模块实现 中断路由器模块的特性 表553显示了不同TC3xx设备中实现的中断路由器配置。共享仲裁按ICUx对实现，从ICU0开始（ICU0/ICU1，ICU2/ICU3，\u0026hellip;\u0026hellip;）。\n中断路由器系统和模块寄存器 图180显示了设备中与中断路由器模块相关的所有寄存器。中断路由器分配了两个地址范围：\n2 * 256字节地址范围：覆盖中断路由器系统寄存器、ICU控制寄存器和OTGM寄存器。\n8 KB地址范围：覆盖服务请求控制寄存器。\n使用的访问保护寄存器缩写列表 P0 -\u0026gt; ACCEN_SRBx：相关SRBx寄存器的写保护。服务请求广播寄存器（SRB）的数量和相关的ACCEN_SRB寄存器的数量与已实现的TriCore CPU数量相等。 P1 -\u0026gt; ACCEN_CONFIG：写保护所有SRCx[15:0]和ICUx错误捕获寄存器（ECRx）。 P2 -\u0026gt; ACCEN_SRC_TOSx：写保护所有映射到TOSx的SRC的位[31:16]（SCR.TOS=x）。对于每个已实现的中断控制单元，实现一个ACCEN_SRC_TOSx寄存器。 访问保护的违规行为不会被执行（例如，通过具有禁用的主标记ID的SPB访问写入到受 Px/ACCEN保护的寄存器）。在这种情况下，访问保护错误将被信号发送到SMU。除了向SMU发出信号外，不会产生其他错误、中断或陷阱。\nSystem Control Unit (SCU) chapter, External Request Unit (ERU)\nSTM章节 tc397中断 与 arm gic中断区别\n","date":"2025年7月8日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/tricore/tc397_interrupt/","series":[{"title":"Tc397 架构系列","url":"/series/tc397-%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97/"}],"smallImg":"","tags":[{"title":"Tc397中断","url":"/tags/tc397%E4%B8%AD%E6%96%AD/"},{"title":"中断管理","url":"/tags/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"timestamp":1751986567,"title":"Tc397中断子系统"},{"authors":[],"categories":[{"title":"J6M","url":"/categories/j6m/"}],"content":" J6M\nJ6 开发者文档\n","date":"2025年7月7日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/arm/j6m/","series":[{"title":"J6M","url":"/series/j6m/"}],"smallImg":"","tags":[{"title":"J6M","url":"/tags/j6m/"}],"timestamp":1751868731,"title":"J6M"},{"authors":[],"categories":[],"content":"","date":"2025年7月6日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/onlinetools/timestamp/","series":[],"smallImg":"","tags":[],"timestamp":1751760000,"title":"时间戳转换"},{"authors":[],"categories":[{"title":"理财科普","url":"/categories/%E7%90%86%E8%B4%A2%E7%A7%91%E6%99%AE/"}],"content":"货币基金是最基础、最稳健的一类基金产品，也是许多人接触基金投资的第一步。它风险极低，流动性强，堪称“余额宝的亲戚”。\n本文将用通俗语言，带你快速了解货币基金的原理、收益、风险以及适合人群。\n🏦 什么是货币基金？ 货币市场基金（Money Market Fund）是一种投资于短期、高流动性、低风险的金融工具的基金。主要投向包括：\n国债、央行票据 银行定期存单（NCD） 回购协议 短期债券（期限不超过 397 天） 这类基金主要用于保值、流动性管理，风险极低，历史上极少发生亏损。\n类型 投资标的 流动性 预期收益 风险水平 适合场景 货币基金 存款、同业存单、回购 T+0/T+1 1.5%–2.3% 极低 临时闲钱、零钱管理 短债基金 剩余期限 \u0026lt;1年债券 T+1 2%–3.5% 很低 几个月内不用的钱 纯债基金 中长期债券（无股票） T+1/T+2 3%–4.5% 低 中期稳健理财 定开债基 同上，但定期开放 固定周期T+n 3.5%–5% 低 不急用的资金配置 可转债基金 可转债为主 T+1/T+2 5%–10% 中等 看好股市又怕大跌 混合债基 债+股+转债 T+1 6%–12% 中高 想增强收益 📌 简记口诀：货币流动快，短债期限短，纯债更稳健，定开锁一段。\n💰 收益来源 货币基金的收益来自于上述资产的利息收益。例如：\n银行协议存款利息 回购利率（如 7 天回购） 央票利息等 其收益是 浮动的，按“万份收益”和“7 日年化收益率”来展示。\n指标名称 含义 万份收益 每 1 万元每天可获得的收益 7 日年化 最近 7 天平均收益，年化后展示 ⚖️ 与银行活期对比 项目 货币基金 银行活期 收益率 通常在 1.5~2.5% 0.25% 左右 流动性 随存随取，一般 T+1 到账 随存随取 风险等级 极低，但非绝对保本 国家兜底 提现到账速度 普通为 T+1，部分支持快速赎回（2 小时内） 实时 每支货币基金当天可以快速到账1w的话，可以分散购买达到提高每天的提现额度\n🚨 有哪些风险？ 虽然风险非常小，但货币基金并非绝对安全：\n流动性风险：极端市场情况下（如大规模赎回）可能暂停提现 利率波动风险：利率下降，收益率也会随之降低 信用风险：投资标的若出现违约可能影响收益 ✅ 历史上货币基金“负收益”极为罕见，但非不可能。\n✅ 谁适合投资货币基金？ 想让“闲钱”多赚点利息的人 不懂投资、不想承担波动风险的新手 需要流动性强的资金管理工具（替代活期） ✅ 常见用途： 替代活期存款（余额宝即为货币基金） 临时资金过渡（买房、还贷前过渡） 股基/债基中转站（用于分仓打新） 🧠 投资建议 不是保本产品，但安全性很高，可放心持有 选基金看品牌（天弘、华夏、易方达等），更重要的是费率、流动性、历史表现 不建议长期重仓，适合作为理财“底仓”或资金泊位 📌 为何不建议长期重仓货币基金？ 原因 说明 收益太低 年化仅 1.5%–2.3%，跑不赢通胀 无复利优势 收益低、波动小，长期复利效应微弱 资金占用机会 占用可用于更高收益资产的资金 税收优势弱化 货基免税优势对高净值人群作用有限 ✅ 长期投资替代方案（按风险偏好） 风险偏好 推荐资产配置 年化预期 特点 极低风险 定开纯债 + 短债基金 3%–4% 稳健增值，适合保守型投资者 中等风险 60% 指数基金 + 40% 债基 6%–8% 波动适中，收益稳定 较高风险 80% 指数基金 + 20% 短债/货基 8%–12% 长期成长，波动大 全球配置 MSCI全球 + 标普500 + A股ETF 6%–10% 分散风险，应对单国波动 货币基金适合作为流动资金池，不宜重仓长期持有。应将长期资金投入能跑赢通胀、具备复利效应的资产如指数基金或优质债基中。\n指数基金 “美股十年翻倍，A股十年原地踏步”——这不是段子，是一场指数设计哲学的实战对比。\n想要长期投资，买了“上证指数”基金； 看着美股指数节节攀升，自己的账户却亏钱； 明明“押注国家崛起”，结果却成了“韭菜收割”？ 问题不在市场本身，而在指数背后的“设计者思维”。\n主要指数及分支指数基金对比表 指数名称 代表市场 投资标的特点 主要成分特点 历史表现（长期） 风险水平 典型基金示例 适合投资者 上证指数 中国A股主板 大盘股，国企为主 国企权重高，周期和资源类居多 低或负收益 高 易方达上证50ETF 国内价值投资者 深证成指 中国中小盘股 中小市值成长股较多 创新企业、消费及科技较多 中等波动大 中高 华夏成长ETF 看好中国成长股 沪深300 中国大盘蓝筹 蓝筹股集中，市场代表性强 行业分布较均衡 较稳健 中 嘉实沪深300ETF 追求稳健成长投资者 标普500 美国大型股 500大盘蓝筹股 高科技与消费龙头集中 年化约10% 中 VOO、SPY、IVV 全球长期稳健投资者 纳斯达克100 美国科技成长股 科技、互联网成长股为主 主要科技巨头 年化约12-15% 高 QQQ 追求高成长投资者 MSCI全球指数 全球市场 全球发达及部分新兴市场 行业和国家多元化 平衡增长 中 iShares MSCI ACWI ETF 全球配置投资者 恒生指数 香港市场 香港大型蓝筹股 金融、地产占比高 波动较大 中 南方恒生ETF 关注港股及中国海外股 📊 为什么标普500长期上涨？ ✅ 成分公司选择逻辑 标普500 不是“谁市值大谁进”，而是：\n财报盈利连续 4 个季度为正 流动性强，代表行业龙头 审核委员会主观把关，不符合就踢出去 这意味着：\n劣质企业进不了 表现差的会被剔除 指数“自动优化” ✅ 权重设计逻辑 使用自由流通市值加权（即市值×流通比例） 科技龙头占据核心（如苹果、英伟达、微软） 它不是“平均持股”，而是“抱紧赢家”\n📉 为什么上证指数反而让人亏钱？ ❌ 指数成分问题 按“总市值”加权，国企占比极大 龙头是工商银行、中国石油、宝钢、中国建筑等低增长老企业 科技、消费、新能源等优质成长股权重极低 ❌ 剔除机制形同虚设 僵尸企业、亏损国企常年霸榜 没有动态优化 指数就像“老龄化人口结构”，缺乏活力 ❌ 新股扩容稀释收益 新股频繁上市，不断“抽水” 权重重新洗牌，老股不涨，新股抢流 散户投资就像不断被“摊薄”的股东 🔍 举个例子 指数 2008–2024年涨幅 年化收益 最大回撤 标普500 +330% 以上 ~10% -55%（2008） 纳指100 +800% 以上 ~13% -80%（2000科网泡沫） 上证指数 基本持平（或负收益） ~0%–1% 多次腰斩 🧠 怎么做？ ✅ 看好中国发展，请考虑： 沪深300（结构更优） 中证500 / 中证红利（成长性 \u0026amp; 分红） ETF 行业精选：新能源车、医疗、科技等 ✅ 做全球配置，别只靠A股： 有其他券商？买 VOO、QQQ 等美股 ETF 没有？也可以通过买 513500、513100 等跟踪美股的ETF ","date":"2025年7月5日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/misc/investment/funds/","series":[{"title":"投资理财","url":"/series/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/"}],"smallImg":"","tags":[{"title":"货币基金","url":"/tags/%E8%B4%A7%E5%B8%81%E5%9F%BA%E9%87%91/"},{"title":"基金基础","url":"/tags/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80/"},{"title":"零风险理财","url":"/tags/%E9%9B%B6%E9%A3%8E%E9%99%A9%E7%90%86%E8%B4%A2/"},{"title":"收益计算","url":"/tags/%E6%94%B6%E7%9B%8A%E8%AE%A1%E7%AE%97/"},{"title":"指数基金","url":"/tags/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91/"}],"timestamp":1751729103,"title":"货币基金"},{"authors":[],"categories":[{"title":"电动车续航测试","url":"/categories/%E7%94%B5%E5%8A%A8%E8%BD%A6%E7%BB%AD%E8%88%AA%E6%B5%8B%E8%AF%95/"}],"content":" 随着电动车的普及，各家厂商纷纷标榜自家车型“续航 600 公里、700 公里”，但用户实际体验往往达不到标称。为什么？这背后关键在于所采用的测试标准不同。\n本文将带你了解目前全球主流的几种电动车测试标准：CLTC、WLTP、EPA、NEDC，比较它们的特点、优缺点，以及哪种更贴近日常使用。\n🧭 常见测试标准一览 标准 地区 全称 当前状态 启用时间 CLTC 中国 China Light-duty Vehicle Test Cycle ✅ 现行 2021 年起 WLTP 欧洲、日韩 Worldwide Harmonized Light Vehicle Test Procedure ✅ 现行 2017 年起 EPA 美国 Environmental Protection Agency Test Cycle ✅ 现行 1970s 起，持续迭代 NEDC 欧洲、中国（旧） New European Driving Cycle ❌ 已淘汰 1997~2020 🧪 各测试标准简要说明 🇨🇳 CLTC（中国标准） 由中国工信部制定，2021 年起替代 NEDC 以城市低速工况为主，起步/停车频繁 测试环境理想化（不含空调、电器负载） 优点：宣传续航高；缺点：偏差太大 🇪🇺 WLTP（全球统一轻型车测试程序） 由联合国欧洲经济委员会（UNECE）制定 包含低速、中速、高速、超高速四段工况 模拟更广泛的驾驶行为和交通情景 优点：中庸实用；缺点：仍略乐观 🇺🇸 EPA（美国环保署标准） 包含城市、市郊和高速测试，考虑空调负载 所有主流第三方测评网站普遍采用 被认为最贴近日常驾驶 优点：可信度高；缺点：宣传数字不好看 ❌ NEDC（已淘汰） 原为欧盟标准，测试条件极度理想化，后被 CLTC、WLTP 替代 工况过于温和，平均速度低，未考虑现实情况 经常导致续航虚高 实测打 5~7 折非常常见 ⚖️ 不同标准对比表 数据来源不详，仅仅供参考\n特性 CLTC WLTP EPA NEDC 最高车速 114 km/h 131 km/h 129 km/h 120 km/h 平均速度 32 km/h 46.5 km/h 48.3 km/h 34 km/h 是否考虑空调等负载 ❌ 否 部分工况支持 ✅ 是 ❌ 否 城市/高速比例 偏城市 综合 综合 偏城市 实测偏差率 20~30% 10~15% 5~10% 30~40% 🚗 实测案例：特斯拉 Model Y（长续航版） 数据来源不详，仅仅供参考\n测试标准 标称续航 实测高速续航（110 km/h） 偏差率 CLTC 660 km 470~500 km ↓ 25~30% WLTP 565 km 480~500 km ↓ 10~15% EPA 525 km 480~500 km ↓ 5~8% NEDC❌ 700+ km（历史） ~420 km ↓ 35~40% 🔍 注：同款车型在不同市场宣传用不同标准。例如，Model Y 在中国用 CLTC，欧洲用 WLTP，美国用 EPA。\n✅ 总结对比与建议 需求类型 推荐测试标准 日常真实体验、长期表现 ✅ EPA 欧系车数据、城市+郊区 ✅ WLTP 中国车型标称宣传 🟡 CLTC（需结合实测） 历史车型参考 ❌ NEDC（已过时） 建议： 🚫 不盲信续航数字，看清使用的测试标准 ✅ 看第三方实测或用户实用报告更可信 🚘 高速用车需求者优先关注 EPA 和实测表现 🔗 延伸阅读 CLTC EPA 官网 - FuelEconomy.gov WLTP 官方介绍 - UNECE 电动车实测续航大全（EV Database） ","date":"2025年7月5日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/stellate/sd/cltc/","series":[{"title":"国标那些事","url":"/series/%E5%9B%BD%E6%A0%87%E9%82%A3%E4%BA%9B%E4%BA%8B/"}],"smallImg":"","tags":[{"title":"电动车续航测试","url":"/tags/%E7%94%B5%E5%8A%A8%E8%BD%A6%E7%BB%AD%E8%88%AA%E6%B5%8B%E8%AF%95/"},{"title":"CLTC","url":"/tags/cltc/"},{"title":"EPA","url":"/tags/epa/"},{"title":"WLTP","url":"/tags/wltp/"},{"title":"NEDC","url":"/tags/nedc/"}],"timestamp":1751727427,"title":"电动车续航测试标准对比"},{"authors":[],"categories":[],"content":" 作为一个合格的懒人，致力于收集奇技淫巧，不再浪费时间于无聊的搜索\nshell 1# 查找某个文件夹的前三级文件夹 2# 如果查找前三级的文件 可以使用把 d --\u0026gt; f 3find /path -mindepth 1 -maxdepth 3 -type d 4tree -L 3 -d /path/ 5cd $(cd \u0026#34;$(dirname \u0026#34;${BASH_SOURCE[0]}\u0026#34;)\u0026#34; \u0026amp;\u0026amp; pwd) 6 7scp -rp -P 22 test@xxxxx:/file . 8# 错误直接退出 9set -o errexit 10 11seq -f \u0026#34;HELLO:%g,\u0026#34; 1 16 # HELLO1-HELLO16 12 13echo \u0026#34;脚本名: $0\u0026#34; 14echo \u0026#34;第1个参数: $1\u0026#34; 15echo \u0026#34;第2个参数: $2\u0026#34; 16echo \u0026#34;参数总数: $#\u0026#34; 17echo \u0026#34;所有参数(@): $@\u0026#34; 18echo \u0026#34;所有参数(*): $*\u0026#34; 代理 1# 服务器映射到本地端口 2ssh -i test.key -D localport -p 22 user@1.1.1.1 3scp -O # 表示 使用传统 SCP 协议 4 5export http_proxy=socks5://127.0.0.1:1080 6export https_proxy=socks5://127.0.0.1:1080 7curl --proxy socks5://127.0.0.1:1080 www.google.com 8 9# 远程vps访问本地的8000端口 10ssh -R 9000:localhost:8000 user@serverB # -f -N -R 文本处理 find/sed/xargs 查找批量替换等\n1# 文件头尾部空格 2 find ./ -name \u0026#34;*.[ch]\u0026#34; -exec sed -i \u0026#39;/./,$!d\u0026#39; {} + 3 find ./ -name \u0026#34;*.[ch]\u0026#34; -exec sed -i -e :a -e \u0026#39;/^\\n*$/{$d;N;ba\u0026#39; -e \u0026#39;}\u0026#39; -e \u0026#39;$a\\\u0026#39; {} \\; 4# 文件编码改为utf8 5 find ./ -name \u0026#34;*.[ch]\u0026#34; -exec sh -c \u0026#39;file \u0026#34;$0\u0026#34; | grep 8859 \u0026amp;\u0026amp; iconv -f gbk -t utf-8 \u0026#34;$0\u0026#34; | sponge \u0026#34;$0\u0026#34;\u0026#39; {} \\; 6# tab转空格 7 find ./ -name \u0026#34;*.[ch]\u0026#34; ! -type d -exec bash -c \u0026#39;expand -t 4 \u0026#34;$0\u0026#34; | sponge \u0026#34;$0\u0026#34;\u0026#39; {} \\; 8# 回车格式转换为LF 9 find ./ -name \u0026#34;*.[ch]\u0026#34; -exec dos2unix {} \\; # 单个 10 find ./ -name \u0026#34;*.[ch]\u0026#34; -exec dos2unix {} + # 批量 11 find ./ -name \u0026#34;*.[ch]\u0026#34; -print0 | xargs -0 dos2unix # 批量 12# 同时多个类型 13 find . \\( -name \u0026#34;*.[csh]\u0026#34; -o -name \u0026#34;*.txt\u0026#34; -o -name \u0026#34;*.ld\u0026#34; \\) -exec dos2unix {} + sed 1# 某行插入文本 2sed -i \u0026#39;8a This is a test\u0026#39; regular_express.txt 3 4# 字符替换 5str=\u0026#34;hello world\u0026#34; 6echo\\${str//o/P} 7echo\\${str/o/P} 8# 区别是str后面两个//可以全局替换 9filestr=\\$(echo ${filestr}| sed \u0026#39;s/^/-add_set_file=/g\u0026#39; ) 10filestr=\\$(sed \u0026#39;s/^/-add_set_file=/g\u0026#39; \u0026lt;\u0026lt;\u0026lt;${filestr}) echo颜色 1# Font Color 2Black=\u0026#39;\\033[0;30m\u0026#39; # 黑色 3Red=\u0026#39;\\033[0;31m\u0026#39; # 红色 4Green=\u0026#39;\\033[0;32m\u0026#39; # 绿色 5Yellow=\u0026#39;\\033[0;33m\u0026#39; # 黄色 6Blue=\u0026#39;\\033[0;34m\u0026#39; # 蓝色 7Purple=\u0026#39;\\033[0;35m\u0026#39; # 紫色 8Cyan=\u0026#39;\\033[0;36m\u0026#39; # 青色 9White=\u0026#39;\\033[0;37m\u0026#39; # 白色 10 11# Background Color 12On_Black=\u0026#39;\\033[40m\u0026#39; # 黑色背景 13On_Red=\u0026#39;\\033[41m\u0026#39; # 红色背景 14On_Green=\u0026#39;\\033[42m\u0026#39; # 绿色背景 15On_Yellow=\u0026#39;\\033[43m\u0026#39; # 黄色背景 16On_Blue=\u0026#39;\\033[44m\u0026#39; # 蓝色背景 17On_Purple=\u0026#39;\\033[45m\u0026#39; # 紫色背景 18On_Cyan=\u0026#39;\\033[46m\u0026#39; # 青色背景 19On_White=\u0026#39;\\033[47m\u0026#39; # 白色背景 20 21# Special effects 22NC=\u0026#39;\\033[0m\u0026#39; # 无颜色，清除颜色设置 23Bold=\u0026#39;\\033[1m\u0026#39; # 粗体 24Underline=\u0026#39;\\033[4m\u0026#39; # 下划线 25Blink=\u0026#39;\\033[5m\u0026#39; # 闪烁 26Inverted=\u0026#39;\\033[7m\u0026#39; # 反白显示 27 28echo -e \u0026#34;$REDS********$ENDS\u0026#34; 自动补全 alias hi=\u0026rsquo;$HOME/xxx/hi.sh' source hi_complete 在hi.sh中添加参数处理逻辑即可 1complete -F _hi_complete hi 2 3_hi_complete() 4{ 5 local cur prev opts 6 COMPREPLY=() 7 cur=\u0026#34;${COMP_WORDS[COMP_CWORD]}\u0026#34; 8 prev=\u0026#34;${COMP_WORDS[COMP_CWORD-1]}\u0026#34; 9 local prev2=\u0026#34;${COMP_WORDS[COMP_CWORD-2]}\u0026#34; 10 11 case ${prev,,} in 12 \u0026#34;hi\u0026#34;) 13 opts=\u0026#34;build docker\u0026#34; 14 COMPREPLY=( $(compgen -W \u0026#39;${opts[@]}\u0026#39; -- $cur) ) 15 ;; 16 \u0026#34;docker\u0026#34;) 17 local docker_opts=(on off ps in) 18 COMPREPLY=( $(compgen -W \u0026#39;${docker_opts[@]}\u0026#39; -- $cur) ) 19 ;; 20 *) 21 _filedir 22 ;; 23 esac 24 25 # echo \u0026#39;cur=\u0026#39;$cur,\u0026#39;prev\u0026#39;=$prev,\u0026#39;prev2\u0026#39;=$prev2\u0026gt;\u0026gt;~/11.txt 26} 添加用户/用户组 1# 进入docker以后，新建一个和主机上相同的用户，用户组 2sudo useradd bob 3sudo groupadd autosar 4sudo usermod -g autosar bob 5\t# usermod -aG autosar bob 新增用户组； -g 直接修改 6sudo mkdir /home/bob 7sudo chown bob:autosar /home/bob/ 8 9# 把docker中的id修改为主机上相同的id 10cat /etc/passwd | grep bob 11# 记录用户id 用户组id bob:x:1006:1001:bob:/home/bob:/bin/sh 12sudo usermod -u 1006 bob 13sudo groupmod -g 1001 autosar 14 15# 后续共享目录放到自己的用户目录中 挂载网络目录 1sshfs cn@172.22.22.230:/mnt/hgfs/test/ test/ 2# 卸载 3fusermount -u /path/to/local/mountpoint wget 1wget -r -np -nH --cut-dirs=3 -R \u0026#34;index.html*\u0026#34; \u0026#34;http://xxxxx/yy/zzz/dir/\u0026#34; 2 3 4命令参数的解释： 5 6-r 或 --recursive：递归下载。 7-np 或 --no-parent：不下载父目录，避免爬升到父目录中去。 8-nH 或 --no-host-directories：禁止创建包含服务器名的目录。 9--cut-dirs=3：跳过远程服务器上的前3个目录层级。在这个例子中，yy/zzz/dir/ 被忽略。调整这个数字根据实际的URL路径。 10-R \u0026#34;index.html*\u0026#34;：拒绝下载所有以index.html开头的文件（这通常是服务器生成的目录索引页面）。 11最后是您要下载的URL。 12该命令会在当前目录下创建一个包含所有下载文件和目录的结构，忽略上述提到的目录层级。 gerrit 查询当前patch\n1#!/bin/sh 2 3# Automatically trigger jenkins compilation 4# */20 10-21 * * * /home/xxx/test.sh 5 6# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DO NOT EDIT ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 7# exclude_times=(\u0026#34;12:00\u0026#34; \u0026#34;18:00\u0026#34; \u0026#34;21:00\u0026#34;) 8# [[ \u0026#34; ${exclude_times[*]} \u0026#34; =~ \u0026#34; $(date \u0026#39;+%H:%M\u0026#39;) \u0026#34; ]] \u0026amp;\u0026amp; exit 0 9 10cd /home/xxx 11 12current_timestamp=$(date +%s) 13logfile=\u0026#39;/home/xxx/test.log\u0026#39; 14sed -i \u0026#34;1i$(date +\u0026#34;%Y.%m.%d %H:%M:%S\u0026#34;)\u0026#34; $logfile 15 16ssh -p 22 test@gerrit3.xxx.com gerrit query is:open project:code/test/branch/xxx --patch-sets --format json \\ 17| jq -r \u0026#39;select(.branch == \u0026#34;codebase_rtos_dev\u0026#34;) | [.owner.email, (.patchSets | max_by(.number).createdOn), (.patchSets | max_by(.number).ref)] | @tsv\u0026#39; | while IFS=$\u0026#39;\\t\u0026#39; read -r -a array; do 18 userName=$(echo \u0026#34;${array[0]}\u0026#34; | cut -d \u0026#34;@\u0026#34; -f 1) 19 20 # echo \u0026#34;${array[0]} ${array[1]} ${array[2]}\u0026#34; # email, time, ref 21 # if [[ $userName != \u0026#34;test\u0026#34; \u0026amp;\u0026amp; $userName != \u0026#34;abc\u0026#34; ]]; then 22 # continue 23 # fi 24 sed -i \u0026#34;2i\\ $(printf \u0026#34;%-16s\u0026#34; \u0026#34;$userName\u0026#34;) ${array[2]} $(date -d@${array[1]} +\u0026#34;%m/%d %H:%M:%S\u0026#34;) $(date -d@${current_timestamp} +\u0026#34;%m/%d %H:%M:%S\u0026#34;)\u0026#34; $logfile 25 26 time_diff=$((current_timestamp - array[1])) 27 if ((time_diff \u0026lt; 20*60)); then # delay require time 28 patchUrl=\u0026#39;git pull \u0026#34;ssh://\u0026#39;$userName\u0026#39;@gerrit3.xxx.com:22/code/test/branch/xxx\u0026#34; \u0026#39;${array[2]} 29 patchParam=\u0026#39;imagepath=\u0026#39;$(echo $patchUrl | sed \u0026#39;s/ /%20/g\u0026#39; | sed \u0026#39;s/\u0026#34;/%22/g\u0026#39;)\u0026#39;\u0026amp;build_all=yes\u0026amp;autotest=yes\u0026#39; 30 projectNames=(\u0026#39;test_build_1\u0026#39;) 31 for projectName in \u0026#34;${projectNames[@]}\u0026#34; 32 do 33 curlParam=\u0026#39;rtosuser:rtos@user123 xxx:443/job/test_build_1/job/\u0026#39;$projectName\u0026#39;/buildWithParameters?token=123456\u0026amp;\u0026#39;$patchParam 34 curl -u $curlParam 35 sed -i \u0026#34;3i\\ curl -u $curlParam\u0026#34; $logfile 36 done 37 fi 38done查询正在运行jenkins任务，并取消排队的重复任务\n1import subprocess 2import requests 3import re 4from requests.utils import dict_from_cookiejar 5 6logfile = \u0026#34;/home/xxx/test.log\u0026#34; 7subprocess.run(f\u0026#39;sed -i \u0026#34;2i\\ _cancelItem_:\u0026#34; {logfile}\u0026#39; , shell=True) 8 9jenkins_url = \u0026#34;http://xxx:443/\u0026#34; 10username = \u0026#34;test\u0026#34; 11password = \u0026#34;xxx123\u0026#34; 12 13response = requests.get(f\u0026#39;{jenkins_url}queue/api/json\u0026#39;, auth=(username, password)) 14data = response.json() 15# get block job list 16g_patchUrlList = [] 17for item in data[\u0026#39;items\u0026#39;]: 18 if item[\u0026#39;task\u0026#39;][\u0026#39;name\u0026#39;] == \u0026#39;test_build_1\u0026#39;: 19 item_id = item[\u0026#34;id\u0026#34;] 20 causes_action = next((action for action in item[\u0026#39;actions\u0026#39;] if action[\u0026#39;_class\u0026#39;] == \u0026#39;hudson.model.CauseAction\u0026#39;), None) 21 startType = causes_action[\u0026#39;causes\u0026#39;][0][\u0026#39;_class\u0026#39;] if causes_action else None 22 if item[\u0026#34;blocked\u0026#34;] and not item[\u0026#34;buildable\u0026#34;]: 23 if startType == \u0026#39;hudson.model.Cause$RemoteCause\u0026#39; or 1: 24 parameters = next((action[\u0026#39;parameters\u0026#39;] for action in item[\u0026#39;actions\u0026#39;] if action[\u0026#39;_class\u0026#39;] == \u0026#39;hudson.model.ParametersAction\u0026#39;), []) 25 patchUrl = next((param[\u0026#39;value\u0026#39;] for param in parameters if param[\u0026#39;name\u0026#39;] == \u0026#39;imagepath\u0026#39;)).split()[-1] 26 g_patchUrlList.append([item_id, patchUrl]) 27 28g_patchSet = set(re.search(r\u0026#34;(.*)/\\d+$\u0026#34;, y).group(1) for x, y in g_patchUrlList) 29# cancel multi job 30if len(g_patchSet) \u0026gt; 0: 31 response = requests.get(f\u0026#34;{jenkins_url}crumbIssuer/api/xml?xpath=concat(//crumbRequestField,\\\u0026#34;:\\\u0026#34;,//crumb)\u0026#34;, auth=(username, password)) 32 crumb = response.text.split(\u0026#34;:\u0026#34;) 33 cookies = dict_from_cookiejar(response.cookies) 34 headers = { 35 \u0026#34;Jenkins-Crumb\u0026#34;: crumb[1], 36 \u0026#34;Cookie\u0026#34;: \u0026#34;; \u0026#34;.join([f\u0026#34;{name}={value}\u0026#34; for name, value in cookies.items()]) 37 } 38for patch in g_patchSet: 39 tmpList = [x for x, y in g_patchUrlList if patch in y ] 40 tmpList.remove(max(tmpList)) 41 for id in tmpList: 42 cancelUrl = f\u0026#34;{jenkins_url}queue/cancelItem?id={id}\u0026#34; 43 response = requests.post(cancelUrl, auth=(username, password), headers=headers) 44 45 subprocess.run(f\u0026#39;sed -i \u0026#34;3i\\ {next(y for x, y in g_patchUrlList if x == id)} {response.status_code} {response.reason}\u0026#34; {logfile}\u0026#39; , shell=True) gerrit 与 jenkins 集成互通 Gerit:\n管理员登录gerrit, http:/xxxxx/admin/repos/All-Projects,access Global Capabilities-\u0026gt;Stream Events 添加用户 jenkins Reference: refs/heads/* Label Code-Review: -1, +1 jenkins Label Verified: -1, +1 jenkins Jenkins: 安装插件： Gerrit Trigger 新建gerrit trigger 服务 添加jenkins节点：https://www.cnblogs.com/sky-cheng/p/14931503.html\ntab 忽略大小写 vim ~/.inputrc\n1# do not show hidden files in the list 2set match-hidden-files off 3 4# auto complete ignoring case 5set show-all-if-ambiguous on 6set completion-ignore-case on 7# 保存重启终端 minicom win下minicom，ctrl a + q 要快 不能回车输入的话，minicom -s 把流控关闭\n1#!/bin/sh 2 3ls /dev/ttyS* 4 5if [ -z \u0026#34;$1\u0026#34; ]; then 6 read -p \u0026#34;please input a num:\u0026#34; num 7else 8 num=$1 9fi 10 11minicom -b 115200 -D /dev/ttyS$numssh win之后使用 minicom，1.mobaxterm能用，2.通过gitbash套用，然后改一下.bashrc配置\n1\u0026#34;c:\\Program Files\\git\\bin\\bash.exe\u0026#34; -c \u0026#34;/c/Users/xxx/AppData/Roaming/Mobaxterm/slash/bin/bash.exe -i\u0026#34; 2 3c:\\Users\\xxx\\AppData\\Roaming\\MobaXterm\\slash\\bin\\bash.exe -i http server上传下载 1# 本地快速启动 [http server](https://docs.python.org/3/library/http.server.html) 2# 支持上传功能 [uploadserver](https://pypi.org/project/uploadserver/) 3# 无网络安装，下载之后，pip install uploadserver-6.0.0.tar.gz 4python3 -m http.server 8080 --directory /tmp/ 5python3 -m uploadserver --basic-auth hello:world 磁盘性能 1# ? 2sudo smartctl -i /dev/sda 3sudo smartctl -H /dev/sda 4sudo smartctl -A /dev/sda 5sudo smartctl -a /dev/sda openssl证书公私钥 1openssl genrsa -out ca.key 4096 2openssl req -x509 -new -nodes -key ca.key -subj \u0026#34;/CN=example.ca.com\u0026#34; -days 5000 -out ca.crt 3 4openssl genrsa -out client.key 4096 5openssl req -new -sha256 -key client.key \\ 6 -subj \u0026#34;/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=client.com\u0026#34; \\ 7 -reqexts SAN \\ 8 -config \u0026lt;(cat demo.cnf \u0026lt;(printf \u0026#34;\\n[SAN]\\nsubjectAltName=DNS:client.com,DNS:example.client.com\u0026#34;)) \\ 9 -out client.csr 10openssl x509 -req -days 365 -sha256 \\ 11 -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\ 12 -extfile \u0026lt;(printf \u0026#34;subjectAltName=DNS:client.com,DNS:example.client.com\u0026#34;) \\ 13 -out client.crt 14 15openssl genrsa -out server.key 4096 16openssl req -new -sha256 -key server.key \\ 17 -subj \u0026#34;/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=server.com\u0026#34; \\ 18 -reqexts SAN \\ 19 -config \u0026lt;(cat demo.cnf \u0026lt;(printf \u0026#34;\\n[SAN]\\nsubjectAltName=DNS:localhost,IP:127.0.0.1,DNS:example.server.com\u0026#34;)) \\ 20 -out server.csr 21openssl x509 -req -days 365 -sha256 \\ 22 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\ 23 -extfile \u0026lt;(printf \u0026#34;subjectAltName=DNS:localhost,IP:127.0.0.1,DNS:example.server.com\u0026#34;) \\ 24 -out server.crt port开启检测 1# tcp 端口 2telnet ip port 3nc -zv ip port 4# udp 端口 5echo \u0026#34;test\u0026#34; | nc -u -v -w2 ip port bat 1:: 短路径， 如 PROGRA~1 Program Files 2dir /x C:\\ 3 4:: 进入脚本所在目前 5cd /d \u0026#34;%~dp0\u0026#34; 6:: 当前命令提示符的目录 7cd %cd% 8:: 日期时间 9echo %date% %time% 10 11:: 延时启动 12timeout /T 10 /NOBREAK 13start cmd /C x.bat 14 15:: 删除文件夹 16rmdir /s /q build 17del filename 18 19:: 20mklink /D link target 21 22:: powershell 端口检测 23test-netconnection domain.com -p port 24 25:: bois 26shutdown /r /fw /t 0 27 28:: 唤醒源 29powercfg -devicequery wake_armed 30 31:: 重启原因 powershell 32Get-WinEvent -FilterHashtable @{LogName=\u0026#39;System\u0026#39;; Id=1074,6006,6008,41} -MaxEvents 10 | Select-Object TimeCreated, Id, LevelDisplayName, Message 设置ip地址 1netsh interface ip set address name=\u0026#34;以太网 2\u0026#34; static 192.168.1.10 255.255.255.0 2netsh interface ip set address name=\u0026#34;以太网 2\u0026#34; dhcp bat 计算时分秒 1set /a n=0 2for /f \u0026#34;tokens=1-8 delims=.: \u0026#34; %%a in (\u0026#34;%etime%:%stime%\u0026#34;) do ( 3set /a n+=10%%a%%100*360000+10%%b%%100*6000+10%%c%%100*100+10%%d%%100 4set /a n-=10%%e%%100*360000+10%%f%%100*6000+10%%g%%100*100+10%%h%%100) 5set /a s=n/360000,n=n%%360000,f=n/6000,n=n%%6000,m=n/100,n=n%%100 6 7echo time:%s%:%f%:%m% 计划任务/杀掉任务/停止服务 1@echo off 2 3setlocal enabledelayedexpansion 4 5%1 mshta vbscript:createobject(\u0026#34;shell.application\u0026#34;).shellexecute(\u0026#34;\u0026#34;\u0026#34;%~0\u0026#34;\u0026#34;\u0026#34;,\u0026#34;::\u0026#34;,,\u0026#34;runas\u0026#34;,1)(window.close)\u0026amp;\u0026amp;exit /b 6CD /D \u0026#34;%~dp0\u0026#34; 7:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: 8 9echo %cd% 10 11@REM schtasks /Delete /TN \u0026#34;xx1\u0026#34; /F 12 13schtasks /Change /TN \u0026#34;xx1\u0026#34; /DISABLE 14 15schtasks /query /TN \u0026#34;xx1\u0026#34; 16 17taskkill /F /IM xx1.exe 18 19:: 停止服务 20net stop \u0026#34;xx\u0026#34; 21 22pause 23 24exit 0 win自动上报ip地址 1@echo off 2setlocal enabledelayedexpansion 3 4:: 初始化变量 5set \u0026#34;ip_str=test_123 %DATE% %TIME% ip: \u0026#34; 6 7:: 使用 for /f 命令循环解析 ipconfig 输出，只取IPv4地址行的第二个字段（即IP地址） 8for /f \u0026#34;tokens=2 delims=:\u0026#34; %%a in (\u0026#39;ipconfig ^| findstr /i \u0026#34;IPv4\u0026#34;\u0026#39;) do ( 9 set \u0026#34;ip=%%a\u0026#34; 10 :: 删除前导和尾随空格 11 set \u0026#34;ip=!ip:~1!\u0026#34; 12 :: 将找到的IP地址添加到ip_str，以空格分隔 13 if defined ip_str ( 14 set \u0026#34;ip_str=!ip_str! !ip!\u0026#34; 15 ) else ( 16 set \u0026#34;ip_str=!ip!\u0026#34; 17 ) 18) 19 20:: 输出所有拼接的IPv4地址 21echo !ip_str! 22 23ssh -p 22 user@xxxx \u0026#34;echo !ip_str! \u0026gt; /home/test/ip.txt\u0026#34; 普通用户通过管理员提权 1@echo off 2:: 提权执行命令，获取管理员cmd 3runas /user:Administrator cmd 1@echo off 2setlocal 3 4:: 设置目标目录 5set \u0026#34;folder_path=C:\\a2c\u0026#34; 6 7:: 创建目录 8mkdir \u0026#34;%folder_path%\u0026#34; 9if %errorlevel% neq 0 ( 10 echo 创建目录失败：%folder_path% 11 exit /b %errorlevel% 12) 13 14:: 授予所有用户（Everyone）完全控制权限 15icacls \u0026#34;%folder_path%\u0026#34; /grant \u0026#34;Everyone:(OI)(CI)F\u0026#34; /T 16if %errorlevel% neq 0 ( 17 echo 设置权限失败：%folder_path% 18 exit /b %errorlevel% 19) 20 21echo 目录创建成功并已授予所有用户完全控制权限：%folder_path% 22pause 防火墙阻止出入站 1@echo off 2 3:: setlocal ENABLEDELAYEDEXPANSION 4:: mode con: cols=65 lines=25 5:: color 0a 6:: rem 批处理获取管理员权限 7:: :------------------------------------- 8:: %1 mshta vbscript:createobject(\u0026#34;shell.application\u0026#34;).shellexecute(\u0026#34;\u0026#34;\u0026#34;%~0\u0026#34;\u0026#34;\u0026#34;,\u0026#34;::\u0026#34;,,\u0026#34;runas\u0026#34;,1)(window.close)\u0026amp;\u0026amp;exit /b 9:: CD /D \u0026#34;%~dp0\u0026#34; 10:: :------------------------------------- 11 12 13:begin 14 15rem 接收输入 16 17set name= 18set Fpath= 19set /p name=Input software name: 20set /p Fpath=software path (C:Program FilesWinRAR): 21 22rem 输出得到的输入信息 23echo Input software name: %name% 24echo software path: %Fpath% 25 26 27echo \u0026#34;Please cancel: Ctrl+C\u0026#34; 28pause 29 30setlocal enabledelayedexpansion 31set /a n=0 32for /r \u0026#34;%Fpath%\u0026#34; %%i in (*.exe) do ( 33 set /a n+=1 34 echo \u0026#34;%name%_!n!\u0026#34;,\u0026#34;%%i\u0026#34; 35 netsh advfirewall firewall del rule name=\u0026#34;a_user_%name%_!n!\u0026#34;\u0026gt;nul 2\u0026gt;nul 36 netsh advfirewall firewall add rule name=\u0026#34;a_user_%name%_!n!\u0026#34; program=\u0026#34;%%i\u0026#34; action=block dir=out\u0026gt;null 37 netsh advfirewall firewall add rule name=\u0026#34;a_user_%name%_!n!\u0026#34; program=\u0026#34;%%i\u0026#34; action=block dir=in\u0026gt;null 38 echo block %name%_!n! ok ~~~ 39) 40 41rem pause\u0026gt;null 42 43echo. 44 45rem 从begin标签出，再次运行 46goto begin 47 48 49::如果要禁止入站规则，将 action=block dir=out\u0026gt;null，中的out改为in，其他照旧 显示屏尺寸 常见名称 分辨率 (宽×高) 横向像素大约 常见别名 备注 HD / 720p 1280×720 ≈ 1K —— 早期高清电视标准 Full HD / 1080p 1920×1080 ≈ 2.07 百万像素 “1080p” 大多数笔电/显示器默认分辨率 2K（DCI 2K） 2048×1080 ≈ 2.1K 电影行业标准 仅比1080p稍宽 QHD / 1440p / 2.5K 2560×1440 ≈ 2.5K “2K显示器”商业俗称 许多厂商叫“2K”其实是它 4K（UHD） 3840×2160 ≈ 4K 电视标准 UHD 常见于4K显示器、电视 DCI 4K（电影） 4096×2160 ≈ 4K —— 电影工业标准宽一点 powershell\n1# 获取显示器物理尺寸（毫米） 2$monitors = Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorBasicDisplayParams 3# 获取当前显卡输出模式（分辨率+刷新率） 4$video = Get-CimInstance -Namespace root\\cimv2 -ClassName Win32_VideoController 5 6foreach ($m in $monitors) { 7 $width_inch = $m.MaxHorizontalImageSize / 2.54 8 $height_inch = $m.MaxVerticalImageSize / 2.54 9 $diag_inch = [Math]::Sqrt($width_inch * $width_inch + $height_inch * $height_inch) 10 11 $nearest = [Math]::Round($diag_inch) 12 $label = switch ($nearest) { 13 {$_ -ge 23 -and $_ -le 25} { \u0026#34;≈ 24 英寸\u0026#34; } 14 {$_ -ge 26 -and $_ -le 28} { \u0026#34;≈ 27 英寸\u0026#34; } 15 {$_ -ge 31 -and $_ -le 33} { \u0026#34;≈ 32 英寸\u0026#34; } 16 default { \u0026#34;≈ $nearest 英寸\u0026#34; } 17 } 18 19 # 从显卡信息取当前分辨率与刷新率 20 $v = $video | Select-Object -First 1 21 $res = if ($v.CurrentHorizontalResolution -and $v.CurrentVerticalResolution) { 22 \u0026#34;{0}x{1}\u0026#34; -f $v.CurrentHorizontalResolution, $v.CurrentVerticalResolution 23 } else { \u0026#34;未知分辨率\u0026#34; } 24 25 $hz = if ($v.CurrentRefreshRate) { \u0026#34;{0} Hz\u0026#34; -f $v.CurrentRefreshRate } else { \u0026#34;未知刷新率\u0026#34; } 26 27 Write-Output (\u0026#34;显示器: 宽 {0:F1} 英寸, 高 {1:F1} 英寸, 对角线 {2:F1} 英寸 → {3} | 当前分辨率: {4} @ {5}\u0026#34; ` 28 -f $width_inch, $height_inch, $diag_inch, $label, $res, $hz) 29} cmd\n1$video = Get-CimInstance -Namespace root\\cimv2 -ClassName Win32_VideoController 2 3foreach ($v in $video) { 4 $width = $v.CurrentHorizontalResolution 5 $height = $v.CurrentVerticalResolution 6 $hz = [math]::Round($v.CurrentRefreshRate) 7 8 if (-not $width -or -not $height) { 9 Write-Output \u0026#34;未检测到分辨率信息。\u0026#34; 10 continue 11 } 12 13 # 判断分辨率等级（用数值范围而非字符串） 14 if ($width -eq 1280 -and $height -eq 720) { $label = \u0026#34;HD (720p)\u0026#34; } 15 elseif ($width -eq 1920 -and $height -eq 1080) { $label = \u0026#34;Full HD (1080p)\u0026#34; } 16 elseif ($width -eq 2048 -and $height -eq 1080) { $label = \u0026#34;DCI 2K (电影行业标准)\u0026#34; } 17 elseif ($width -eq 2560 -and $height -eq 1440) { $label = \u0026#34;QHD / 2K (1440p)\u0026#34; } 18 elseif ($width -eq 3440 -and $height -eq 1440) { $label = \u0026#34;UWQHD (超宽 2K)\u0026#34; } 19 elseif ($width -eq 3840 -and $height -eq 2160) { $label = \u0026#34;4K UHD (2160p)\u0026#34; } 20 elseif ($width -eq 4096 -and $height -eq 2160) { $label = \u0026#34;DCI 4K (电影级 4K)\u0026#34; } 21 elseif ($width -eq 5120 -and $height -eq 2880) { $label = \u0026#34;5K UHD\u0026#34; } 22 elseif ($width -eq 7680 -and $height -eq 4320) { $label = \u0026#34;8K UHD\u0026#34; } 23 else { $label = \u0026#34;自定义分辨率\u0026#34; } 24 25 Write-Output (\u0026#34;当前分辨率: {0}x{1} @ {2} Hz → {3}\u0026#34; -f $width, $height, $hz, $label) 26} cmd\n1powershell -command \u0026#34;\u0026amp; { $monitors = Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorBasicDisplayParams; foreach ($m in $monitors) { $width_inch = $m.MaxHorizontalImageSize / 2.54; $height_inch = $m.MaxVerticalImageSize / 2.54; $diag_inch = [Math]::Sqrt($width_inch * $width_inch + $height_inch * $height_inch); $nearest = [Math]::Round($diag_inch); $label = switch ($nearest) { {$_ -ge 23 -and $_ -le 25} { \u0026#39;≈ 24 英寸\u0026#39; } {$_ -ge 26 -and $_ -le 28} { \u0026#39;≈ 27 英寸\u0026#39; } {$_ -ge 31 -and $_ -le 33} { \u0026#39;≈ 32 英寸\u0026#39; } default { \u0026#39;≈ \u0026#39; + $nearest + \u0026#39; 英寸\u0026#39; } }; Write-Output (\u0026#39;显示器: 宽 {0:F1} 英寸, 高 {1:F1} 英寸, 对角线 {2:F1} 英寸 → {3}\u0026#39; -f $width_inch, $height_inch, $diag_inch, $label) } }\u0026#34; 微信解毒 1@echo off 2:: 必须管理员权限运行 3net session \u0026gt;nul 2\u0026gt;\u0026amp;1 || (echo 请以管理员身份运行！ \u0026amp; pause \u0026amp; exit /b 1) 4 5setlocal enabledelayedexpansion 6 7:: 设置目标目录 8set \u0026#34;target_dir=C:\\Users\\bob\\AppData\\Roaming\\Tencent\\WeChat\\XPlugin\u0026#34; 9 10:: 检查目录是否存在 11if not exist \u0026#34;%target_dir%\u0026#34; ( 12 echo 目录不存在: %target_dir% 13 pause 14 exit /b 1 15) 16 17:: 查找并输出所有exe文件路径 18echo 正在扫描 %target_dir% 下的exe文件... 19echo ====================================== 20 21for /r \u0026#34;%target_dir%\u0026#34; %%f in (*.exe) do ( 22 echo %%f 23 set \u0026#34;target_path=%%f\u0026#34; 24 25 if exist \u0026#34;!target_path!\u0026#34; ( 26 :: 1. 重置权限（清除所有现有权限） 27 icacls \u0026#34;!target_path!\u0026#34; /reset \u0026gt;nul 28 29 :: 2. 禁用继承（不保留父级权限） 30 icacls \u0026#34;!target_path!\u0026#34; /inheritance:r \u0026gt;nul 2\u0026gt;\u0026amp;1 31 32 :: 3. 仅授予Administrators读取权限, 没生效?? 33 icacls \u0026#34;!target_path!\u0026#34; /grant *S-1-5-32-544:(R) \u0026gt;nul 2\u0026gt;\u0026amp;1 34 35 :: 验证权限 36 icacls \u0026#34;!target_path!\u0026#34; | findstr \u0026#34;Administrators\u0026#34; 37 38 echo 已完成。 39 ) 40) 41 42echo ====================================== 43echo 所有操作完成！ 44 45cd /d %target_dir%\\Plugins 46if not exist \u0026#34;RadiumWMPF--del--\u0026#34; ( 47 rename RadiumWMPF RadiumWMPF--del-- 48 echo \u0026gt; RadiumWMPF 49 icacls RadiumWMPF /reset \u0026gt;nul 50 icacls RadiumWMPF /inheritance:r \u0026gt;nul 2\u0026gt;\u0026amp;1 51 icacls RadiumWMPF /grant *S-1-5-32-544:(R) \u0026gt;nul 2\u0026gt;\u0026amp;1 52) 循环菜单 1@echo off 2%1 mshta vbscript:CreateObject(\u0026#34;Shell.Application\u0026#34;).ShellExecute(\u0026#34;cmd.exe\u0026#34;,\u0026#34;/c %~s0 ::\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;runas\u0026#34;,1)(window.close)\u0026amp;\u0026amp;exit 3cd /d \u0026#34;%~dp0\u0026#34; 4color 0A 5 6:choice 7echo ################################################ 8echo ## 网络配置菜单 9echo ################################################ 10echo ## 0. 查看 ipconfig 11echo ## 1. WLAN DHCP 12echo ## 2. 以太网 DHCP 13echo ## q. 退出 14echo ################################################ 15set /P action=请输入编号: 16 17if /I \u0026#34;%action%\u0026#34;==\u0026#34;q\u0026#34; goto Action_quit 18goto Action_%action% 19 20:Action_0 21call :run ipconfig /all 22call :pause1 23goto choice 24 25:Action_1 26echo [*] 正在设置 WLAN DHCP... 27call :run netsh interface ip set address \u0026#34;WLAN\u0026#34; dhcp 28call :run netsh interface ip set dns \u0026#34;WLAN\u0026#34; dhcp 29call :pause1 30goto choice 31 32:Action_2 33call :run netsh interface ip set address \u0026#34;以太网\u0026#34; dhcp 34call :pause1 35goto choice 36 37:Action_quit 38echo 正在退出... 39call :pause1 40exit 41 42:pause1 43ping 127.0.0.1 -n 1 \u0026gt;nul 44goto :eof 45 46:run 47echo ^\u0026gt; %* 48%* 49goto :eof route 1route ADD 100.1.0.0 MASK 255.255.0.0 10.2.3.255 METRIC 10 IF 26 2route DELETE 100.1.0.0 正则表达式 正则表达式基本点： 符号 用法 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，\u0026rsquo;n\u0026rsquo; 匹配字符 \u0026ldquo;n\u0026rdquo;。\u0026rsquo;\\n\u0026rsquo; 匹配一个换行符。序列 \u0026lsquo;\\\\\u0026rsquo; 匹配 \u0026ldquo;\\\u0026rdquo; 而 \u0026ldquo;\\(\u0026rdquo; 则匹配 \u0026ldquo;(\u0026quot;。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 \u0026lsquo;\\n\u0026rsquo; 或 \u0026lsquo;\\r\u0026rsquo; 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 \u0026lsquo;\\n\u0026rsquo; 或 \u0026lsquo;\\r\u0026rsquo; 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \u0026ldquo;z\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，\u0026lsquo;zo+\u0026rsquo; 能匹配 \u0026ldquo;zo\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;，但不能匹配 \u0026ldquo;z\u0026rdquo;。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，\u0026ldquo;do(es)?\u0026rdquo; 可以匹配 \u0026ldquo;do\u0026rdquo; 或 \u0026ldquo;does\u0026rdquo; 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，\u0026lsquo;o{2}\u0026rsquo; 不能匹配 \u0026ldquo;Bob\u0026rdquo; 中的 \u0026lsquo;o\u0026rsquo;，但是能匹配 \u0026ldquo;food\u0026rdquo; 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，\u0026lsquo;o{2,}\u0026rsquo; 不能匹配 \u0026ldquo;Bob\u0026rdquo; 中的 \u0026lsquo;o\u0026rsquo;，但能匹配 \u0026ldquo;foooood\u0026rdquo; 中的所有 o。\u0026lsquo;o{1,}\u0026rsquo; 等价于 \u0026lsquo;o+\u0026rsquo;。\u0026lsquo;o{0,}\u0026rsquo; 则等价于 \u0026lsquo;o*\u0026rsquo;。 {n,m} m 和 n 均为非负整数，其中n \u0026lt;= m。最少匹配 n 次且最多匹配 m 次。例如，\u0026ldquo;o{1,3}\u0026rdquo; 将匹配 \u0026ldquo;fooooood\u0026rdquo; 中的前三个 o。\u0026lsquo;o{0,1}\u0026rsquo; 等价于 \u0026lsquo;o?\u0026rsquo;。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \u0026ldquo;oooo\u0026rdquo;，\u0026lsquo;o+?\u0026rsquo; 将匹配单个 \u0026ldquo;o\u0026rdquo;，而 \u0026lsquo;o+\u0026rsquo; 将匹配所有 \u0026lsquo;o\u0026rsquo;。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 \u0026lsquo;\\n\u0026rsquo; 在内的任何字符，请使用像\u0026rdquo;(.|\\n)\u0026ldquo;的模式。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [\\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^\\f\\n\\r\\t\\v]。 \\w 匹配字母、数字、下划线。等价于\u0026rsquo;[A-Za-z0-9_]\u0026rsquo;。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 \u0026lsquo;\\(\u0026rsquo; 或 \u0026lsquo;\\)\u0026rsquo;。 x|y 匹配 x 或 y。例如，\u0026lsquo;z|food\u0026rsquo; 能匹配 \u0026ldquo;z\u0026rdquo; 或 \u0026ldquo;food\u0026rdquo;。\u0026rsquo;(z|f)ood\u0026rsquo; 则匹配 \u0026ldquo;zood\u0026rdquo; 或 \u0026ldquo;food\u0026rdquo;。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， \u0026lsquo;[abc]\u0026rsquo; 可以匹配 \u0026ldquo;plain\u0026rdquo; 中的 \u0026lsquo;a\u0026rsquo;。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， \u0026lsquo;[^abc]\u0026rsquo; 可以匹配 \u0026ldquo;plain\u0026rdquo; 中的\u0026rsquo;p\u0026rsquo;、\u0026rsquo;l\u0026rsquo;、\u0026lsquo;i\u0026rsquo;、\u0026rsquo;n\u0026rsquo;。 \\x20 匹配空格字符 [\\u4e00-\\u9fa5] 中文 (?!\u0026hellip;) 负前瞻, 断言后面的位置不匹配括号内的内容 \\b(?!cat)\\w+ 匹配不以 cat 开头的单词,\\b：单词边界 详细可参考：正则表达式 – 教程 | 菜鸟教程\n汉字匹配示例： Unicode扩展：[\\u4e00-\\u9fff] [\\u4e00-\\u9fa5]+ # 一个或多个汉字 [\\u4e00-\\u9fa5]{2,4} # 2到4个汉字 Cmake debug信息 1message(FATAL_ERROR xxxxxx ) 2// FATAL_ERROR SEND_ERROR WARNING AUTHOR_WARNING STATUS DEBUG TRACE 3 4# -Werror=dev 5cmake --trace-expand -Wdev -DCMAKE_VERBOSE_MAKEFILE=ON 6 7# set(CMAKE_C_RESPONSE_FILE_LINK_FLAG \u0026#34;\u0026#34;) 生成中间文件 1set(CMAKE_C_FLAGS \u0026#34;${CMAKE_C_FLAGS} -save-temps=obj\u0026#34;)将保存中间文件，以对象文件（.obj）的形式 分析源文件宏展开之后的代码，生成的中间文件example.c.i\nflag 1set(CMAKE_C_USE_RESPONSE_FILE_FOR_OBJECTS 1) 2set(CMAKE_C_USE_RESPONSE_FILE_FOR_LIBRARIES 1) 3set(CMAKE_C_USE_RESPONSE_FILE_FOR_INCLUDES 1) 4set(CMAKE_C_RESPONSE_FILE_FLAG \u0026#34;-f \u0026#34;) 5set(CMAKE_C_RESPONSE_FILE_LINK_FLAG \u0026#34;-f \u0026#34;) Git git clone 1ssh-keygen -t ed25519 -f ./id_ed25519 -C \u0026#34;@.com\u0026#34; 2ssh -o HostKeyAlgorithms=+ssh-rsa -o PubkeyAcceptedAlgorithms=+ssh-rsa bob@ip 3 4# 测试链接 5ssh -T -vvv git@github.com调试\n1# 测试 git clone 日志debug 2GIT_SSH_COMMAND=\u0026#34;ssh -v\u0026#34; git pull --rebase 3GIT_CURL_VERBOSE=1 git clone https://gitee.com/swoole/swoole.git 4GIT_CURL_VERBOSE=1 git ls-remote https://gitee.com/swoole/swoole.git 5 6git config --system http.sslCAPath /etc/pki/ca-trust/extracted/pem/ 7git config --global http.sslVerify false # 关闭证书验证Faq\nmobaxterm https证书问题 /etc/pki/tls/certs/ca-bundle.crt -\u0026gt; /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem Mobaxterm\\slash\\mx86_64b\\etc\\pki\\ca-trust\\extracted\\pem 文件夹证书文件，查看大小 stty: standard input: Inappropriate ioctl for device\ngit pull 卡死 alias git=\u0026lsquo;winpty \u0026ldquo;/usr/bin/git.exe\u0026rdquo;\u0026rsquo; 加上绝对路径 本地仓库同步 1git config receive.denyCurrentBranch ignore 2#实际.git/config 文件中添加 3#[receive] 4# denyCurrentBranch =ignore Git命令自动补全 参考：https://www.cnblogs.com/kinwing/p/11670577.html\n1# 下载配置文件 git clone git://git.kernel.org/pub/scm/git/git.git 2# linux可能自带无需下载，搜索文件 git-completion.bash 3cp git/contrib/completion/git-completion.bash ~/.git-completion.bash 4# 在.bashrc中添加 5source ~/.git-completion.bash 6source ~/.bashrc .gitconfig 1git config --global core.filemode false 2git config --global core.autocrlf false 3git config --unset-all core.filemode 4git config --global --list 5git config --local --list 6 7# git config --global alias.gc \u0026#39;auto = 256\u0026#39; 8[core] 9 autocrlf = false 10 filemode = true 11 preloadindex = true 12 fscache = true 13 # whitespace = cr-at-eol # 忽略换行差异 14[alias] 15 co = checkout 16 br = branch 17 ci = commit 18 st = status 19 lg = log 20 lgn = log --name-status 21 lgo = log --name-only 22 df = diff 23 dfst = diff --stat 24 dfcst = diff --cached --stat 25 dfc = diff --cached 26 ss = stash 27 sl = stash list 28 sp = stash pop 29 cino = commit --amend --no-edit 30 pr = pull --rebase 31 # pushx = \u0026#34;!f() { git push \\\u0026#34;$@\\\u0026#34; \u0026amp;\u0026amp; .git/hooks/post-push; }; f\u0026#34; 32[color] 33 ui = auto .ssh/config 若是win安装git后不能使用pull，可以先进行如下配置 在秘钥路径中 如 C:\\Users\\xxx.ssh 添加 config 文件，如下配置\n1Host xxxx.com 2HostkeyAlgorithms +ssh-rsa 3PubkeyAcceptedAlgorithms +ssh-rsa 4 5# StrictHostKeyChecking no 6# UserKnownHostsFile /dev/null 7 8# 特定key配置，没有配置默认使用 id_rsa 9Host xxx1.com 10 IdentityFile ~/.ssh/id_rsa 11 IdentityFile ~/.ssh/id_rsa_1 12Host xxx2.com 13 IdentityFile ~/.ssh/id_rsa_2 github多用户 1# ~/.ssh/config 文件新增如下内容 2Host user1.github.com 3 HostName github.com 4 IdentityFile ~/.ssh/user1_ed25519 5 6Host user2.github.com 7 HostName github.com 8 IdentityFile ~/.ssh/user2_ed25519 9 10# 上面的配置可能由于22断开被封，出现错误：Connection closed by remote host 11# 参考 https://paugram.com/tech/github-ssh-connection-closed-problem-with-proxy.html 12Host user1.github.com 13 HostName ssh.github.com 14 User git 15 Port 443 16\tPreferredAuthentications publickey 17 IdentityFile ~/.ssh/user1_ed25519 18 19Host user2.github.com 20 HostName ssh.github.com 21 User git 22 Port 443 23\tPreferredAuthentications publickey 24 IdentityFile ~/.ssh/user2_ed25519 25 26 27# 用法 28# git clone git@github.com:Genymobile/scrcpy.git 替换为如下即可 29git clone git@user1.github.com:Genymobile/scrcpy.git 30 31# 多个用户可能会配置多个用户名和邮箱，在每个仓库单独配置即可 32git config --local user.name \u0026#34;your_name\u0026#34; 33git config --local user.email \u0026#34;your_eamil\u0026#34; github查看仓库大小 直达链接：https://github.com/settings/repositories\n修改分支名 1# 先切换所在分支 2git checkout -b oldname origin/oldname 3# 修改分支名 4git branch -m newname 5# 删除远程分支 6git push origin --delete oldname 7# 推送新分支，如果不进行这一步，相当于删除远程分支 8git push origin newname 9 10# 强制更新修改网页提交记录 11# 本地修改 git log 之后，git push -f origin master 12 13# 主线master直接提交feature分支 14git push origin dev:feature 15# 提交MR之后，在master分支 git pull --rebase 即可，偷懒一直在主线开发 git log 1git log --grep=\u0026#34;xxx\u0026#34; 2# 搜索特定作者 3git log --author=\u0026#34;作者名字\u0026#34; --grep=\u0026#34;关键字\u0026#34; 4# 限定时间段 5git log --after=\u0026#34;YYYY-MM-DD\u0026#34; --before=\u0026#34;YYYY-MM-DD\u0026#34; --grep=\u0026#34;关键字\u0026#34; 6 7# 查看对应的文件变化 8git show commitId 9git whatchanged commitId 10 11# 切换到某次 commitId 12git checkout commitId 13 14# 根据 commitId 定位前后的提交记录， --oneline 简短显示log 15# 前面的一次记录 16git log -1 commitId 17# 后面一次的提交记录 18git log --reverse --oneline commitId..HEAD | head -n 1 19 20# 查看HEAD 21git rev-parse HEAD # HEAD~1 HEAD~n HEAD^n vscode https://code.visualstudio.com/api/references/contribution-points\ngtags -i 搜索索引\ntab四个空格 code-\u0026gt;首选项-\u0026gt; 设置。\n搜索 tab size\u0026rsquo;即将值改为「4」\n注意：\n将 Detect Indentation 设置去掉，否则 vscode 会跟进文件内容自动推测tab 的空格数。就是说计算结果可能不是你设置的值。\ntab与空格相互转换 1ctrl+shift+p 输入： 2 convert indentation to spaces tab转空格 3 convert indentation to tab 空格转tab 文本换行 Ctrl+Shift+P 输入：Toggle World Wrap, 可配置快捷键\n代码折叠 要操作光标所在文件中的所有代码块：\n折叠所有 Ctrl+K+0 展开所有 Ctrl+K+J 仅仅操作光标所处代码块内的代码：\n折叠 Ctrl+Shift+[ 展开 Ctrl+Shift+] 更多操作：Ctrl+Shift+P搜索fold和unfold\nVSCode 的 #ifdef 区域变灰 ctrl+, 搜索 C_Cpp.dimInactiveRegions 勾选即可 或者 setting 中添加：\u0026ldquo;C_Cpp.dimInactiveRegions\u0026rdquo;: true\nsettings.json /home/bob/.vscode-server/data/Machine/settings.json\n1{ 2 \u0026#34;C_Cpp.intelliSenseCacheSize\u0026#34;: 512, 3 \u0026#34;C_Cpp.intelliSenseMemoryLimit\u0026#34;: 512, 4 \u0026#34;C_Cpp.files.exclude\u0026#34;: { 5 \u0026#34;**/build\u0026#34;: true, 6 }, 7 \u0026#34;debug.allowBreakpointsEverywhere\u0026#34;: true, 8 \u0026#34;git.ignoredRepositories\u0026#34;: [ 9 \u0026#34;/home/xxx/\u0026#34; 10 ], 11 \u0026#34;git.scanRepositories\u0026#34;: [ 12 ], 13 \u0026#34;todo-tree.filtering.excludeGlobs\u0026#34;: [ 14 ], 15 \u0026#34;python.analysis.exclude\u0026#34;: [ 16 ] 17} .vscode/settings.json\n1{ 2 \u0026#34;files.associations\u0026#34;: { 3 \u0026#34;CMakeLists.txt\u0026#34;: \u0026#34;cmake\u0026#34;, 4 }, 5 6 \u0026#34;files.exclude\u0026#34;: { 7 \u0026#34;**/.cache\u0026#34;: true 8 }, 9 \u0026#34;search.exclude\u0026#34;: { 10 \u0026#34;**/build/*\u0026#34;: true 11 }, 12 13 // \u0026#34;C_Cpp.intelliSenseEngine\u0026#34;: \u0026#34;disabled\u0026#34;, 14 \u0026#34;C_Cpp.intelliSenseCacheSize\u0026#34;: 512, 15 \u0026#34;C_Cpp.intelliSenseMemoryLimit\u0026#34;: 512, 16 // \u0026#34;C_Cpp.workspaceSymbols\u0026#34;: \u0026#34;Just My Code\u0026#34;, 17 \u0026#34;search.followSymlinks\u0026#34;: false, 18 \u0026#34;C_Cpp.errorSquiggles\u0026#34;: \u0026#34;disabled\u0026#34;, 19} c_cpp_properties.json 1{ 2 \u0026#34;configurations\u0026#34;: [ 3 { 4 \u0026#34;name\u0026#34;: \u0026#34;Win32\u0026#34;, 5 \u0026#34;includePath\u0026#34;: [ 6 \u0026#34;${workspaceFolder}/xx/**\u0026#34; 7 ], 8 \u0026#34;defines\u0026#34;: [ 9 \u0026#34;TEST_MARCO=1\u0026#34; 10 ], 11 \u0026#34;compilerPath\u0026#34;: \u0026#34;C:\\\\MinGW\\\\bin\\\\gcc.exe\u0026#34;, 12 \u0026#34;cStandard\u0026#34;: \u0026#34;gnu17\u0026#34;, 13 \u0026#34;cppStandard\u0026#34;: \u0026#34;gnu++14\u0026#34;, 14 \u0026#34;intelliSenseMode\u0026#34;: \u0026#34;windows-gcc-x86\u0026#34;, 15 \u0026#34;configurationProvider\u0026#34;: \u0026#34;ms-vscode.makefile-tools\u0026#34; 16 } 17 ], 18 \u0026#34;version\u0026#34;: 4 19} 20 21{ 22 \u0026#34;configurations\u0026#34;: [ 23 { 24 \u0026#34;name\u0026#34;: \u0026#34;Linux\u0026#34;, 25 \u0026#34;includePath\u0026#34;: [ 26 \u0026#34;${workspaceFolder}/**\u0026#34; 27 ], 28 \u0026#34;defines\u0026#34;: [ 29 \u0026#34;TEST_MARCO=1\u0026#34; 30 ], 31 \u0026#34;compilerPath\u0026#34;: \u0026#34;/usr/bin/gcc\u0026#34;, 32 \u0026#34;cStandard\u0026#34;: \u0026#34;gnu11\u0026#34;, 33 \u0026#34;cppStandard\u0026#34;: \u0026#34;c++17\u0026#34;, 34 \u0026#34;intelliSenseMode\u0026#34;: \u0026#34;gcc-x64\u0026#34; 35 } 36 ], 37 \u0026#34;version\u0026#34;: 4 38} tasks.json 1{ 2 // See https://go.microsoft.com/fwlink/?LinkId=733558 3 // for the documentation about the tasks.json format 4 \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, 5 \u0026#34;tasks\u0026#34;: [ 6 { 7 \u0026#34;label\u0026#34;: \u0026#34;build\u0026#34;, 8 \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, 9 \u0026#34;isBackground\u0026#34;: true, 10 \u0026#34;command\u0026#34;: \u0026#34;${workspaceFolder}/xxx/test.sh test1\u0026#34;, 11 \u0026#34;args\u0026#34;: [], 12 \u0026#34;problemMatcher\u0026#34;: [ 13 { 14 \u0026#34;pattern\u0026#34;: [ 15 { 16 \u0026#34;regexp\u0026#34;: \u0026#34;.\u0026#34;, 17 \u0026#34;file\u0026#34;: 1, 18 \u0026#34;location\u0026#34;: 2, 19 \u0026#34;message\u0026#34;: 3 20 } 21 ], 22 \u0026#34;background\u0026#34;: { 23 // \u0026#34;activeOnStart\u0026#34;: false, 24 \u0026#34;beginsPattern\u0026#34;: \u0026#34;.*start qemu debug.*\u0026#34;, // 要对应编译成功后,一句echo的内容. 此处对应 Makefile Line:170 https://zhuanlan.zhihu.com/p/501901665 25 \u0026#34;endsPattern\u0026#34;: \u0026#34;build debug elf done.\u0026#34; 26 } 27 }, 28 ], 29 \u0026#34;presentation\u0026#34;: { 30 // \u0026#34;echo\u0026#34;: true, 31 // \u0026#34;showReuseMessage\u0026#34;: false, 32 // \u0026#34;clear\u0026#34;: true, 33 \u0026#34;close\u0026#34;: true, 34 // \u0026#34;group\u0026#34;: \u0026#34;vm\u0026#34; 35 }, 36 }, 37 { 38 \u0026#34;label\u0026#34;: \u0026#34;test\u0026#34;, 39 \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, 40 // \u0026#34;dependsOn\u0026#34;: \u0026#34;autosar64build\u0026#34;, 41 \u0026#34;command\u0026#34;: \u0026#34;qemu-system-aarch64 -m 1024 -machine virt,gic-version=2,virtualization=on -cpu cortex-a53 -smp 2 -nographic -kernel ${workspaceFolder}/test -S -s -gdb\u0026#34;, 42 \u0026#34;args\u0026#34;:[], 43 \u0026#34;isBackground\u0026#34;: true, 44 }, 45 { 46 \u0026#34;label\u0026#34;: \u0026#34;singlebuild\u0026#34;, 47 \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, 48 \u0026#34;command\u0026#34;: \u0026#34;gcc\u0026#34;, 49 \u0026#34;args\u0026#34;: [\u0026#34;-g\u0026#34;, \u0026#34;${fileDirname}/${fileBasename}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}\u0026#34;] 50 }, 51 ] 52} launch.json 1{ 2 // 使用 IntelliSense 了解相关属性。 3 // 悬停以查看现有属性的描述。 4 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 5 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, 6 \u0026#34;configurations\u0026#34;: [ 7 { 8 \u0026#34;name\u0026#34;: \u0026#34;debug_1\u0026#34;, 9 //\u0026#34;preLaunchTask\u0026#34;: \u0026#34;build\u0026#34;, 10 \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, 11 \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, 12 //\u0026#34;miDebuggerServerAddress\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, 13 \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/test.elf\u0026#34;, 14 \u0026#34;args\u0026#34;: [], 15 \u0026#34;stopAtEntry\u0026#34;: true, 16 \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}/\u0026#34;, 17 \u0026#34;environment\u0026#34;: [], 18 \u0026#34;externalConsole\u0026#34;: false, 19 \u0026#34;logging\u0026#34;: { 20 \u0026#34;engineLogging\u0026#34;: false 21 }, 22 \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, 23 \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;aarch64-none-elf-gdb\u0026#34;, 24 \u0026#34;setupCommands\u0026#34;: [ //为了安装基础调试程序而执行的一个或多个GDB/LLDB命令 25 { 26 \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, 27 \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, 28 \u0026#34;ignoreFailures\u0026#34;: true 29 }, 30 { \u0026#34;text\u0026#34;: \u0026#34;set output-radix 16\u0026#34; } // 16进制显示变量 31 ] 32 }, 33 { 34 \u0026#34;name\u0026#34;: \u0026#34;c-debug\u0026#34;, //配置名称，显示在配置下拉菜单中 35 \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, //配置类型 36 \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, //请求配置类型，可以是启动或者是附加 37 \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/test\u0026#34;, //程序可执行文件的完整路径，${workspaceFolder}表示远程连接的初始路径 38 \u0026#34;args\u0026#34;: [], //传递给程序的命令行参数 39 \u0026#34;stopAtEntry\u0026#34;: true,//可选参数，如果为true,调试程序应该在入口（main）处停止 40 \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}/\u0026#34;, //目标的工作目录 41 \u0026#34;environment\u0026#34;: [], //表示要预设的环境变量 42 \u0026#34;externalConsole\u0026#34;: false,//如果为true，则为调试对象启动控制台 43 \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;,//要连接到的控制台启动程序 44 \u0026#34;setupCommands\u0026#34;: [ //为了安装基础调试程序而执行的一个或多个GDB/LLDB命令 45 { 46 \u0026#34;description\u0026#34;: \u0026#34;为 gdb 启用整齐打印\u0026#34;, 47 \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, 48 \u0026#34;ignoreFailures\u0026#34;: true 49 } 50 ] 51 } 52 ] 53} 54 55// ${workspaceFolder} - 当前工作目录(根目录) 56// ${workspaceFolderBasename} - 当前文件的父目录 57// ${file} - 当前打开的文件名(完整路径) 58// ${relativeFile} - 当前根目录到当前打开文件的相对路径(包括文件名) 59// ${relativeFileDirname} - 当前根目录到当前打开文件的相对路径(不包括文件名) 60// ${fileBasename} - 当前打开的文件名(包括扩展名) 61// ${fileBasenameNoExtension} - 当前打开的文件名(不包括扩展名) 62// ${fileDirname} - 当前打开文件的目录 63// ${fileExtname} - 当前打开文件的扩展名 64// ${cwd} - 启动时task工作的目录 Current Working Directory 65// ${lineNumber} - 当前激活文件所选行 66// ${selectedText} - 当前激活文件中所选择的文本 67// ${execPath} - vscode执行文件所在的目录 68// ${defaultBuildTask} - 默认编译任务(build task)的名字 服务器连接异常 可能是更新vscode 需要安装新的vscode-server，ps-ef | grep wget 抓取，或者下面的方法下载 help-\u0026gt;about 中可查看 commit号\n1wget --tries=1 --connect-timeout=7 --dns-timeout=7 -O vscode-server.tar.gz https://update.code.visualstudio.com/commit:0ee08df0cf4527e40edc9aa28f4b5bd38bbff2b2/server-linux-x64/stable vscode-server手动\n替换需要的 commitID https://vscode.download.prss.microsoft.com/dbazure/download/stable/${commitID}/vscode-server-linux-x64.tar.gz\n解压到的路径 ${HOME}/.vscode-server/cli/servers/Stable-${commitID}/server\n1${HOME}/.vscode-server/cli/servers/Stable-384ff7382de624fb94dbaf6da11977bba1ecd427/server 2├── bin 3├── extensions 4├── LICENSE 5├── node 6├── node_modules 7├── out 8├── package.json 9└── product.json gtags 查找跳转 参考：https://blog.japinli.top/2021/06/gtags-exclude-some-directories/\n1default:\\ 2\t:tc=gtags:tc=htags: 3 4common:\\ 5 :skip=GPATH,GTAGS,GRTAGS,dir1/: 6gtags:\\ 7 :tc=common:\\ 8 :langmap=c\\:.c.h,yacc\\:.y,asm\\:.s.S,java\\:.java,cpp\\:.c++.cc.cpp.cxx.hxx.hpp.C.H,php\\:.php.php3.phtml: 9 10htags:\\ 11\t:body_begin=\u0026lt;body text=\u0026#39;#191970\u0026#39; bgcolor=\u0026#39;#f5f5dc\u0026#39; vlink=\u0026#39;gray\u0026#39;\u0026gt;:body_end=\u0026lt;/body\u0026gt;:\\ 12\t:table_begin=\u0026lt;table\u0026gt;:table_end=\u0026lt;/table\u0026gt;:\\ 13\t:title_begin=\u0026lt;h1\u0026gt;\u0026lt;font color=\u0026#39;#cc0000\u0026#39;\u0026gt;:title_end=\u0026lt;/font\u0026gt;\u0026lt;/h1\u0026gt;:\\ 14\t:comment_begin=\u0026lt;i\u0026gt;\u0026lt;font color=\u0026#39;green\u0026#39;\u0026gt;:comment_end=\u0026lt;/font\u0026gt;\u0026lt;/i\u0026gt;:\\ 15\t:sharp_begin=\u0026lt;font color=\u0026#39;darkred\u0026#39;\u0026gt;:sharp_end=\u0026lt;/font\u0026gt;:\\ 16\t:brace_begin=\u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;:brace_end=\u0026lt;/font\u0026gt;:\\ 17\t:warned_line_begin=\u0026lt;span style=\u0026#39;background-color\\:yellow\u0026#39;\u0026gt;:warned_line_end=\u0026lt;/span\u0026gt;:\\ 18\t:reserved_begin=\u0026lt;b\u0026gt;:reserved_end=\u0026lt;/b\u0026gt;:script_alias=/cgi-bin/:\\ 19\t:ncol#4:tabs#8:normal_suffix=html:gzipped_suffix=ghtml:\\ 20\t:definition_header=no: 21 22// .globalrc_cfg 23GPATH 24GTAGS 25GRTAGS 26dir/ 27*/dir2/ 28 29// 使用： 30 if [ -f $(pwd)/.globalrc ];then 31 # 32 readarray -t lines \u0026lt; $(pwd)/.globalrc_cfg 33 skip=\u0026#34; :skip=$(IFS=,; echo \u0026#34;${lines[*]}\u0026#34;):\u0026#34; 34 sed -i \u0026#34;5s|.*|${skip}|\u0026#34; $(pwd)/.globalrc 35 36 # 37 rm GPATH GRTAGS GTAGS 38 echo \u0026#34; $(pwd)/.globalrc \u0026#34; 39 export GTAGSCONF=$(pwd)/.globalrc 40 gtags -v \u0026amp;\u0026gt; .globalrc_txt 41 fi 异常：C++ Intellisense 升级到 C/C++，而两个同时安装，所以点击的时候有个相同的跳转地址\n快捷键 聚焦窗口 ctrl 0，ctrl 9，alt 0, ctrl alt p 删除一行 ctrl shift k 选中一行 ctrl l 替换小窗口ctrl h 快捷键 ctrl k ctrl s 删除前后 ctrl back ，ctrl del 插件同步 1找到当前server中的 ~/.vscode-server/extensions/extensions.json 记录 \u0026#34;id\u0026#34;:\u0026#34;twxs.cmake\u0026#34; , 找到需要的插件的id 2vscode 的终端中 whereis code 3code --install-extension twxs.cmake 4下载想要同步的插件 连接私钥配置 C:\\Users\\bob.ssh\\config_vscode 是vscode链接服务器的配置文件,内容如下 1Host test 2 HostName 192.168.68.2 3 User test 4 Port 22 5 IdentityFile D:\\dir1\\dir2\\id_rsa 关键需要设置D:\\dir1\\dir2\\id_rsa文件的属性（私钥id_rsa 不在 C:\\Users\\bob.ssh） 11. 右键属性-\u0026gt;安全-\u0026gt;编辑-\u0026gt;能删除的直接删除其他所有用户，只保留自己的用户名 22. 如果不能编辑的-\u0026gt;高级-\u0026gt;禁用继承-\u0026gt;从此对象删除所有已继承的权限-\u0026gt;确定-\u0026gt;编辑-\u0026gt;添加-\u0026gt;高级-\u0026gt;立即查找-\u0026gt;找到自己的用户名双击-\u0026gt;然后确定返回即可 33. 就能用vscode访问远程的服务器了 方案二： 如下管理员权限建立软连接，即可 mklink /D C:\\Users\\bob.ssh\\config_vscode E:\\xxxx\\myconfig\n汇编调试断点 设置里面勾选 \u0026ldquo;debug.allowBreakpointsEverywhere\u0026rdquo;: true , 前提是编译的时候加入 -g 调试信息\n文件窗口查找 快捷键：Ctrl+Alt+F ，定位查找文件 面包屑导航 \u0026ldquo;breadcrumbs.enabled\u0026rdquo;: true\nvim 选择复制 进入字符模式\n按 v (小写)键进入字符模式，可以逐字符地选择文本 进入行模式\n按 V (大写) 键进入行模式，可以逐行地选择文本。\n进入块模式\n按 Ctrl + v 进入块模式，可以选择一个矩形区域。\n复制选中的文本\n选择文本后，按 y 键（表示 \u0026ldquo;yank\u0026rdquo;）将选中的文本复制到剪贴板。\n粘贴文本\n可以在所需位置按 p 键（小写 p）粘贴文本。如果想粘贴在光标之前，可以按 P 键（大写 P）。\n插入 光标之前：i\n光标之后：a\n下一行插入：o\n上一行插入：shift + o\ndocker 安装使用 docker 获取镜像，创建容器，配合shell章节的自动补全，环境配置好只需要使用就行了，无感操作 详细可参考：https://www.runoob.com/docker/docker-container-usage.html\n1# 安装docker，终端输入 docker，ubuntu24.04会提示安装命令 2sudo apt install docker.io 3# 安装完成之后 docker 执行需要root权限， 把需要操作的用户加入docker即可 4sudo usermod -aG docker bob # 重启即可生效，其他方式如果ssh链接的，断开重连也会生效 5# 会显示用户在docker组 6id bob 7groups bob 8 9 10# 获取镜像 11docker pull ubuntu 12# 查看镜像 13docker images 14# 启动一个容器，镜像可以理解模版，容器是配置的不同的环境，可以一个镜像启动多个容器 15# 可以先用起来，一些概念用着用着就熟悉了解了 16docker run --privileged -it -d -v /home/bob:/home/bob --name my_nodejs ubuntu /bin/bash 17# 这里启动一个my_nodejs的容器（里面用户和主机用户一样，方便后续操作，默认用root用户进入，然后创建和主机一样的用户） 18# 前期可以直接 docker run --privileged -it -d --name my_nodejs ubuntu /bin/bash，直接用root操作 19docker exec -it my_nodejs /bin/bash 20# 如果主机 id bob 为 1000，进入docker cat /etc/passwd，如果有1000的用户，直接修改用户名 21# usermod -l bob -d /home/bob -m ubuntu 22# groupadd bob 23# usermod -g bob -G bob bob 24 25# 启动容器 26docker start my_nodejs 27# 关闭容器 28docker stop my_nodejs 29# 进入容器 30docker exec -it -u bob -w /home/bob my_nodejs /bin/bash 动态添加端口 https://blog.csdn.net/weixin_41148525/article/details/135675015\nhttps://www.baeldung.com/ops/assign-port-docker-container\n1systemctl stop docker 2docker info | grep Root 3# dir 4docker inspect xxx | grep Id 5# idxxxxxxxx 6cd /dir/idxxxxxxxx 7# 修改如下 1{ // hostconfig.json 2 ... 3 \u0026#34;PortBindings\u0026#34;: {\u0026#34;80/tcp\u0026#34;:[{\u0026#34;HostIp\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;HostPort\u0026#34;:\u0026#34;20082\u0026#34;}]}, 4 ... 5} 6{ // config.v2.json 7 \u0026#34;Config\u0026#34;: 8 { 9 ... 10 \u0026#34;ExposedPorts\u0026#34;: 11 { 12 \u0026#34;80/tcp\u0026#34;:{} 13 }, 14 ... 15 } 16} 1systemctl start docker 2docker start xxxx 3docker port xxxx 4# 80/tcp -\u0026gt; 0.0.0.0:20082 5# 80/tcp -\u0026gt; [::]:20082 6 7systemctl is-enabled docker Compose 插件 安装 compose\n1mkdir -p ~/.docker/cli-plugins 2curl -SL https://github.com/docker/compose/releases/download/v2.21.0/docker-compose-linux-x86_64 -o ~/.docker/cli-plugins/docker-compose 3chmod +x ~/.docker/cli-plugins/docker-compose 1docker inspect qinglong | grep Mounts -A 20 2 3修改 docker-compose.yml docker compose up -d 会自动创建/更新容器，无需删除旧容器 4 5启动容器\tdocker compose up\t前台运行容器，输出日志 6后台启动\tdocker compose up -d\t容器在后台运行 7停止容器\tdocker compose stop\t停止运行中的容器，但不删除 8删除容器\tdocker compose down\t停止并删除容器、网络，挂载卷不删 9 10 11列出容器\tdocker compose ps\t查看 Compose 管理的容器状态 12查看日志\tdocker compose logs\t显示所有服务的日志 13实时跟踪日志\tdocker compose logs -f\t类似 tail -f， docker compose logs -f qinglong 14 15 16构建镜像\tdocker compose build\t根据 Dockerfile 构建服务镜像 17拉取最新镜像\tdocker compose pull\t从镜像仓库拉取最新镜像 18更新服务\tdocker compose pull \u0026amp;\u0026amp; docker compose up -d\t拉取镜像并后台重建容器 19 20执行命令\tdocker compose exec \u0026lt;service\u0026gt; \u0026lt;command\u0026gt;\t在容器中执行命令，例如 docker compose exec qinglong bash 21进入容器\tdocker compose exec \u0026lt;service\u0026gt; sh\t打开容器终端 22重启服务\tdocker compose restart \u0026lt;service\u0026gt;\t重启某个服务或全部服务 23 24 25删除未使用的容器、网络\tdocker compose down --volumes\t同时删除挂载卷（慎用） 26删除构建缓存\tdocker compose build --no-cache\t清理镜像缓存重新构建 27 28docker compose down 29docker compose pull 30docker compose up -d 31 32npm ci --legacy-peer-deps 33pnpm install --store-dir /ql/data/dep_cache/node/global/5 --prefix /ql 配置代理 1{ 2 \u0026#34;proxies\u0026#34;: { 3 \u0026#34;http-proxy\u0026#34;: \u0026#34;socks5://127.0.0.1:1080\u0026#34;, 4 \u0026#34;https-proxy\u0026#34;: \u0026#34;socks5://127.0.0.1:1080\u0026#34;, 5 \u0026#34;no-proxy\u0026#34;: \u0026#34;http://example.com\u0026#34; 6 } 7} sudo systemctl daemon-reload sudo systemctl restart docker ubuntu软件安装 tmux分屏 https://zhuanlan.zhihu.com/p/58668651\nexport TMUX_TMPDIR=~/.tmux/tmp\n应用修改图标 cd /usr/share/applications vi xxx 中的 icon = xx.icon\nchrome谷歌浏览器 wget \u0026ndash;no-check-certificate https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\nvscode wget \u0026ndash;no-check-certificate https://code.visualstudio.com/sha/download?build=stable\u0026os=linux-deb-x64\nsougou 下载页面：https://shurufa.sogou.com/linux 安装指导：https://shurufa.sogou.com/linux/guide\nsudo apt -f install 系统设置-\u0026gt;区域和语言-\u0026gt;管理已安装的语言-\u0026gt;在“语言”tab下-\u0026gt;点击“添加或删除语言” -\u0026gt; fcitx 设置fcitx开机自启动 sudo cp /usr/share/applications/fcitx.desktop /etc/xdg/autostart/ 卸载系统ibus输入法框架 sudo apt purge ibus\n关闭繁简切换： 1vi ~/.config/sogoupinyin/conf/env.ini 2ShortCutFanJian=1 # 修改为 0 3vi ~/.config/fcitx/conf/fcitx-chttrans.config 4#Hotkey=CTRL_SHIFT_F # 修改为 Hotkey=CTRL_SHIFT_] 皮肤位置 1/opt/sogoupinyin/files/share/resources/skin/ nas挂载 1sudo apt-get install cifs-utils 2sudo mount -t cifs //192.168.1.1/share /home/bob/mydir -o username=bob,password=bob,iocharset=utf8 3# sudo mount -t cifs //192.168.1.1/share /home/bob/mydir -o username=bob,password=bob,iocharset=utf8,uid=1000,gid=1000,file_mode=0777,dir_mode=0777 截图工具 Snipaste : Snipaste-2.9.2-Beta-x86_64 电脑重启登录的时候，右下角设置图标选择 ubuntu on Xorg PixPin 功能更丰富，暂不支持linux, 通过wine曲线救国 鼠标手势 easystroke：功能上和windows上的 WGestures，还是差不少 手势设置：https://tianws.github.io/skill/2019/10/31/short-cut-ubuntu/\npdf阅读器 Okular：主要为了配置 back forward 快捷键 alt+left，alt+right Settings-\u0026gt;Configure Okular-\u0026gt;General-\u0026gt;Program Features-\u0026gt;Open new files in tabs\ngedit自定义快捷键 https://github.com/foolo/gedit_custom_keys/\n设置 gedit -\u0026gt; Preferences-\u0026gt; Plugins -\u0026gt; Custom Keyboard Shortcuts\n日历 显示周数\ngsettings set org.gnome.desktop.calendar show-weekdate true\n显示农历\nhttps://extensions.gnome.org/extension/675/lunar-calendar/\n安装扩展，chrome扩展配置，apt 连接器\n触摸板 https://extensions.gnome.org/extension/4033/x11-gestures/\nhttps://github.com/JoseExposito/touchegg\n支持自定义手势\nsudo apt install touchegg flatpak\nflatpak install flathub com.github.joseexposito.touche\nWine 管理安装配置 wine sudo apt install winetricks\n1# 下载：https://wiki.winehq.org/Download_zhcn 2# 安装 VeryCapture：https://verycapture.com/download.html 3 4# 安装快捷键转发 5sudo apt install xdotool 6# 配置 7#!/bin/bash 8 9if [ \u0026#34;${1}\u0026#34; == \u0026#34;PixPin\u0026#34; ];then 10 xdotool key --window $( xdotool search --limit 1 --all --pid $( pgrep PixPin.exe ) --name PixPin ) \u0026#34;F1\u0026#34; 11elif [ \u0026#34;${1}\u0026#34; == \u0026#34;VeryCapture\u0026#34; ];then 12 xdotool key --window $( xdotool search --limit 1 --all --pid $( pgrep VeryCapture.exe ) --name VeryCapture ) \u0026#34;shift+F1\u0026#34; 13fi 14 15# settings-\u0026gt; Keyboard -\u0026gt; Keyboard Shortcuts -\u0026gt; View and Customize Shortcuts -\u0026gt; Custom Shortcuts 安装 pixpin，需要下面两个运行库 winetricks vcrun2015 winetricks vcrun2017\npython pip安装\n1# python3 2curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py 3# python2 4https://bootstrap.pypa.io/pip/2.7/get-pip.py 5python get-pip.py pip配置：\n1python3 -m pip install pyelftools 2# http://mirrors.aliyun.com/pypi/simple/ 3# python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyelftools 4 5# 永久配置 ~/.pip/pip.conf 6[global] 7index-url = https://pypi.tuna.tsinghua.edu.cn/simple 8trusted-host = pypi.tuna.tsinghua.edu.cn # 可信主机，要不然可能报错 9disable-pip-version-check = true # 取消pip版本检查，排除每次都报最新的pip 10timeout = 120 11# ignore-installed = true # 忽略任何已经安装的系统包，强制安装指定的包，即使它可能与系统包冲突 12 13# ➡️ pyenv 进行多版本的python管理 pip下载模块：\n1# 自动下载其他的依赖模块 2python3 -m pip download pyelftools 3 4# requirements.txt 5# ./pyelftools-0.32-py3-none-any.whl 6 7pip install -r requirements.txt 8# pm2 1npm install -g pm2 2 npm root -g 全局安装的 npm 包所在目录 3pm2 list 4pm2 monit 5pm2 show appx 6pm2 logs appx 7pm2 start 8pm2 stop/delete appx / all 9pm2 kill 杀死 PM2 守护进程 10pm2 logs cat ~/.pm2/logs/ 11pm2 logs appx 12pm2 start app.js --name miGpt -- --env-file=.env 13pm2 start app.py --name wechat --interpreter python3 14pm2 save 15pm2 startup windows软件配置 chrome浏览器离线安装包 1https://www.google.com/intl/zh-CN/chrome/next-steps.html?platform=win64\u0026amp;standalone=1\u0026amp;statcb=0\u0026amp;installdataindex=empty\u0026amp;defaultbrowser=0 2 3https://dl.google.com/tag/s/appguid%3D%7B8A69D345-D564-463C-AFF1-A69D9E530F96%7D%26iid%3D%7BBD6E01DD-2315-DD04-9D6B-5A409199B5FF%7D%26lang%3Dzh-CN%26browser%3D4%26usagestats%3D0%26appname%3DGoogle%2520Chrome%26needsadmin%3Dprefers%26ap%3Dx64-stable-statsdef_1%26installdataindex%3Dempty/chrome/install/ChromeStandaloneSetup64.exe MyChrome.exe Portable version of Google Chrome\n1[Settings] 2AppVersion=3.8.1 3Language=Auto 4ChromePath=.\\chrome.exe 5UserDataDir=.\\mydata 6CacheDir=.\\mycache 7CacheSize=838860800 8Channel=Stable 9x86=0 10ChromeSource=Google 11LastCheckUpdate=2016/05/01 00:00:00 12UpdateInterval=-1 13ProxyType=SYSTEM 14UpdateProxy= 15UpdatePort= 16DownloadThreads=3 17Params= 18RunInBackground=0 19AppUpdate=0 20AppUpdateLastCheck=2023/07/24 18:23:26 21CheckDefaultBrowser=1 22ExApp= 23ExAppAutoExit=1 24ExApp2= 25Bosskey=!x 26BosskeyM= 27Hide2Tray=0 28MouseClick2CloseTab=7684 29Mouse2SwitchTab=8964|8962 30KeepLastTab=0 Beyond Compare魔法 1reg delete \u0026#34;HKEY_CURRENT_USER\\Software\\Scooter Software\\Beyond Compare 4\u0026#34; /v CacheID /f 关闭自启动 关闭应用自动启动 关闭任务计划程序无用的启动配置 关闭windows defender实时保护 关闭实时保护(通过策略组修改关闭） 1.按win+R，输入gpedit.msc -\u0026gt; 2.选择计算机配置–\u0026gt;管理模板–\u0026gt;Windows组件–\u0026gt;Microsoft Defender防病毒–\u0026gt;实时保护 -\u0026gt; 3.双击关闭实时保护，选择已启用 1.进入“Window安全中心” -\u0026gt;2. 进入“病毒和威胁防护” -\u0026gt;3. 进入“管理设置” -\u0026gt; 4.点击关闭即可\n关闭自动提交样本 关闭篡改防护 https://blog.csdn.net/azxc98765/article/details/120094030\nssh server 设置中可选功能可安装openssh server\nhttps://github.com/PowerShell/Win32-OpenSSH/releases 下载安装OpenSSH-Win64-v9.5.0.0.msi\n1:: 测试系统目录结构 2ssh bob@10.1.1.100 \u0026#34;pwd\u0026#34; 3ssh bob@10.1.1.100 \u0026#34;dir\u0026#34; 4 5:: 进入执行bash 6:: ssh bob@10.1.1.100 \u0026#34;/cygdrive/c/Program\\ Files/Git/bin/bash.exe -i\u0026#34; 7ssh -t bob@10.1.1.100 \u0026#34;C:/Progra~1/Git/bin/bash.exe\u0026#34; 8ssh -t bob@10.1.1.100 \u0026#34;\\\u0026#34;C:/Program Files/Git/bin/bash.exe\\\u0026#34;\u0026#34; 9ssh bob@10.1.1.100 \u0026#34;\\\u0026#34;C:/Progra~1/Git/bin/bash.exe\\\u0026#34; -c \\\u0026#34;cd /d/mytest \u0026amp;\u0026amp; git st \u0026amp;\u0026amp; git gr \u0026amp;\u0026amp; git lg -1\\\u0026#34;\u0026#34; 10ssh bob@10.1.1.100 \u0026#34;\\\u0026#34;C:/Program Files/Git/bin/bash.exe\\\u0026#34; -c \\\u0026#34;cd /d/mytest \u0026amp;\u0026amp; git st \u0026amp;\u0026amp; git gr \u0026amp;\u0026amp; git lg -1\\\u0026#34;\u0026#34; 11 12:: 文件复制 13:: scp test.txt bob@10.1.1.100:/cygdrive/d/mytest/ 14scp \u0026#39;bob@10.1.1.100:D:/mytest/test.txt\u0026#39; . 15scp test.txt \u0026#39;bob@10.1.1.100:D:/mytest/test.txt\u0026#39; 16:: git bash 17scp -P 233 bob@10.1.1.100:D:/mytest/EW*.00* . 1sshpass -p password ssh name@ip # \u0026#34;set path=C:\\Program Files\\Git\\bin;%path% \u0026amp;\u0026amp; bash.exe -i\u0026#34; 2 3sc stop sshd 4sc start sshd win获取ip地址 Python获取本机 IP/MAC（多网卡） – 二进制\n1import psutil 2def GetLocalIP(t=None): 3 ips = [] 4 iptype = \u0026#34;AF_INET\u0026#34; 5 if t == 6: 6 iptype = \u0026#34;AF_INET6\u0026#34; 7 8 dic = psutil.net_if_addrs() 9 for adapter in dic: 10 snicList = dic[adapter] 11 for snic in snicList: 12 if iptype in snic.family.name: 13 if t == 4 and \u0026#34;:\u0026#34; in snic.address: 14 continue 15 ips.append(snic.address) 16 return ips 1import socket 2def GetLocalIP(t=None): 3 ips = [] 4 addrs = socket.getaddrinfo(socket.gethostname(),None) 5 for item in addrs: 6 if t == 4 and \u0026#39;:\u0026#39; in item[4][0]: 7 continue 8 if t == 6 and \u0026#39;:\u0026#39; not in item[4][0]: 9 continue 10 ips.append(item[4][0]) 11 return ips 1import json 2import requests 3import time 4import socket 5import schedule 6import datetime 7import jenkins 8import psutil 9 10KEYSMILE=\u0026#39;.\u0026#39; 11 12def get_nodes_summary(username, password): 13 # https://blog.csdn.net/Sudley/article/details/103848127 14 #获取nodes节点的name、label、ip、status（连接状态） 15 16 try: 17 server = jenkins.Jenkins(\u0026#39;http://%s:%s@xxxx:8080\u0026#39;, username, password) 18 19 nodes = server.get_nodes() 20 21 win_slave = [x for x in nodes if x[\u0026#39;name\u0026#39;] == \u0026#39;win_Slave\u0026#39;] 22 # node_name = win_slave[0][\u0026#39;name\u0026#39;] 23 isonline = not win_slave[0][\u0026#39;offline\u0026#39;] 24 except Exception as e: 25 isonline = False 26 27 return isonline 28 29def GetLocalIPNew(t=None): 30 unwanted_interface = [\u0026#39;Eth_eth0\u0026#39;, \u0026#39;Loopback Pseudo-Interface 1\u0026#39;] # 不想要的网卡名 31 ips = [] 32 interfaces = psutil.net_if_addrs() 33 for name, net_addresses in interfaces.items(): 34 for net_address in net_addresses: 35 if (net_address.family == socket.AF_INET or net_address.family == socket.AF_INET6) and name not in unwanted_interface: 36 ips.append(net_address.address) 37 return ips 38 39def GetLocalIP(t=None): 40 ips = [] 41 addrs = socket.getaddrinfo(socket.gethostname(),None) 42 for item in addrs: 43 if t == 4 and \u0026#39;:\u0026#39; in item[4][0]: 44 continue 45 if t == 6 and \u0026#39;:\u0026#39; not in item[4][0]: 46 continue 47 ips.append(item[4][0]) 48 return ips 49 50def SendMessage(keyword, msg): 51 url = \u0026#39;bark.com\u0026#39; 52 HEADERS = { 53 \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json; charset=utf-8\u0026#34; 54 } 55 56 isonline = get_nodes_summary(\u0026#39;user\u0026#39;, \u0026#39;test123\u0026#39;) 57 if isonline is False: 58 msg += \u0026#34; , offine ~~~\u0026#34; 59 60 sendMsg = { 61 \u0026#34;msgtype\u0026#34;: \u0026#34;text\u0026#34;, 62 \u0026#34;text\u0026#34;: { 63 \u0026#34;content\u0026#34;: keyword + \u0026#39; \u0026#39; + msg 64 } 65 } 66 67 try: 68 requests.post(url, data=json.dumps(sendMsg), headers=HEADERS) 69 ret = True 70 except Exception as e: 71 ret = False 72 73 return ret 74 75def job(): 76 SendMessage(KEYSMILE, \u0026#34;Good Morning\u0026#34;) 77 78if __name__ == \u0026#39;__main__\u0026#39;: 79 print(datetime.datetime.now(), \u0026#34;start run now ...\u0026#34;) 80 schedule.every().day.at(\u0026#34;00:00\u0026#34;).do(job) 81 82 ips = [] 83 ipchanged = False 84 85 while True: 86 schedule.run_pending() 87 time.sleep(20) 88 89 if ips != GetLocalIPNew(): 90 ipchanged = True 91 ips = GetLocalIPNew() 92 print(datetime.datetime.now(), \u0026#34;warning ip changed: \u0026#34;, ips) 93 if ipchanged == True and \\ 94 SendMessage(KEYSMILE, \u0026#39;, \u0026#39;.join(ips)) == True: 95 ipchanged = False jlink下载 1@echo off 2 3:: Calculate the number of parameters 4set argC=0 5for %%x in (%*) do Set /A argC+=1 6 7if %argC% geq 3 ( 8 echo error, too many parameters 9 echo one param: %0 test1 10 echo two param: %0 [jlink.exe]_path test1 11 exit /b 1 12) else if %argC% == 2 ( 13 set jlinkpath=%1 14 set project=%2 15) else ( 16 set jlinkpath=\u0026#34;C:\\Program Files\\SEGGER\\JLink\\JLink.exe\u0026#34; 17 set project=%1 18) 19 20if [%project%] == [] ( 21 set project=test1 22) 23 24for /R \u0026#34;.\\build\\%project%\\obj\\bin\\\u0026#34; %%F in (*.hex) do set \u0026#34;hexfile=.\\build\\%project%\\obj\\bin\\%%~nxF\u0026#34; 25 26if not exist %jlinkpath% ( echo jlinkpath error : %jlinkpath% \u0026amp; exit /b 2 ) 27if not exist %hexfile% ( echo project error : %project% \u0026amp; exit /b 2 ) 28 29set commandfile=jinkConfig.txt 30@echo speed 4000 \u0026gt; %commandfile% 31@echo r \u0026gt;\u0026gt; %commandfile% 32@echo h \u0026gt;\u0026gt; %commandfile% 33@echo erase \u0026gt;\u0026gt; %commandfile% 34@echo loadfile %hexfile% \u0026gt;\u0026gt; %commandfile% 35@echo q \u0026gt;\u0026gt; %commandfile% 36 37%jlinkpath% -device STM32H743II -si swd -autoconnect 1 -nogui 1 -exitonerror 1 -commandfile %commandfile% 38set err=%errorlevel% 39if exist %commandfile% ( del %commandfile% ) 40 41if %err% neq 0 ( echo download error : %project% \u0026amp; exit /b %err% ) 42exit /b 0 process-explorer Process Explorer - Sysinternals\npslist PsList - Sysinternals\nHandle关联的句柄 Handle - Sysinternals\nproxy clash verge\n基于 Sing-box 通用代理工具: hiddify\nSumatraPDF 小巧免费PDF查看器：SumatraPDF\n1# 执行路径：SumatraPDF-settings.txt 2# https://www.sumatrapdfreader.org/docs/Commands 3Shortcuts [ 4\t[ 5\tCmd = CmdNextTab 6\tKey = Alt + e 7\t] 8\t[ 9\tCmd = CmdPrevTab 10\tKey = Alt + w 11\t] 12] 桌面置顶 PinWin\nMSYS2 下载安装：\nhttps://www.msys2.org/ https://github.com/msys2/msys2-installer/releases 可以使用https://gh-proxy.com/加速 1# 第一次使用 2pacman -Syu 3 4# MinGW 64-bit 安装 make，cmake 5pacman -S mingw-w64-x86_64-make mingw-w64-x86_64-cmake regdit Notepad++ 1Windows Registry Editor Version 5.00 2 3[HKEY_CLASSES_ROOT\\*\\shell\\NotePad++] 4@=\u0026#34;Notepad++\u0026#34; 5\u0026#34;Icon\u0026#34;=\u0026#34;D:\\\\Notepad++\\\\notepad++.exe,0\u0026#34; 6 7[HKEY_CLASSES_ROOT\\*\\shell\\NotePad++\\Command] 8@=\u0026#34;D:\\\\Notepad++\\\\notepad++.exe %1\u0026#34; 右键打开命令窗口 1Windows Registry Editor Version 5.00 2 3[HKEY_CLASSES_ROOT\\Directory\\shell\\OpenCmdHere] 4@=\u0026#34;在此处打开命令窗口\u0026#34; 5\u0026#34;Icon\u0026#34;=\u0026#34;cmd.exe\u0026#34; 6 7[HKEY_CLASSES_ROOT\\Directory\\shell\\OpenCmdHere\\command] 8@=\u0026#34;cmd.exe /s /k pushd \\\u0026#34;%V\\\u0026#34;\u0026#34; 9 10[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere] 11@=\u0026#34;在此处打开命令窗口\u0026#34; 12\u0026#34;Icon\u0026#34;=\u0026#34;cmd.exe\u0026#34; 13 14[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere\\command] 15@=\u0026#34;cmd.exe /s /k pushd \\\u0026#34;%V\\\u0026#34;\u0026#34; 16 17[HKEY_CLASSES_ROOT\\Drive\\shell\\OpenCmdHere] 18@=\u0026#34;在此处打开命令窗口\u0026#34; 19\u0026#34;Icon\u0026#34;=\u0026#34;cmd.exe\u0026#34; 20 21[HKEY_CLASSES_ROOT\\Drive\\shell\\OpenCmdHere\\command] 22@=\u0026#34;cmd.exe /s /k pushd \\\u0026#34;%V\\\u0026#34;\u0026#34; 23 24[HKEY_CLASSES_ROOT\\LibraryFolder\\background\\shell\\OpenCmdHere] 25@=\u0026#34;在此处打开命令窗口\u0026#34; 26\u0026#34;Icon\u0026#34;=\u0026#34;cmd.exe\u0026#34; 27 28[HKEY_CLASSES_ROOT\\LibraryFolder\\background\\shell\\OpenCmdHere\\command] 29@=\u0026#34;cmd.exe /s /k pushd \\\u0026#34;%V\\\u0026#34;\u0026#34; 30 31 32[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas] 33@=\u0026#34;以管理员身份运行CMD\u0026#34; 34\u0026#34;Icon\u0026#34;=\u0026#34;D:\\\\app\\\\ico\\\\t.ico\u0026#34; 35 36[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command] 37\u0026#34;ShowBasedOnVelocityId\u0026#34;=dword:00639bc8 38@=\u0026#34;cmd.exe /s /k pushd \\\u0026#34;%V\\\u0026#34;\u0026#34; 任务栏秒显示 1Windows Registry Editor Version 5.00 2 3[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced] 4\u0026#34;ShowSecondsInSystemClock\u0026#34;=dword:00000001 win11 右键展开 1# 终端执行，重启Explorer.exe 生效 2reg.exe add \u0026#34;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32\u0026#34; /f /ve 3 4# 恢复默认 5reg.exe delete \u0026#34;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32\u0026#34; /va /f powertoys win 共享鼠标键盘，太赞了\ninstall\n软件说明\n小工具 画笔工具 glnk\nxml查看工具\n工具站点 Notion Avatar 头像生成工具 丑陋头像 在线粘贴板 github cdn github加速 阿里云命令行下载工具 pdf翻译 pdf2zh 命令行版本比较好用 pip install uv uv tool install --python 3.12 pdf2zh uv tool list uv tool upgrade pdf2zh cmd : https://github.com/Byaidu/PDFMathTranslate?tab=readme-ov-file#41-advanced-options 删除Pdf密码 1import fitz # pip install PyMuPDF 2 3input_pdf_path = \u0026#39;xxx.pdf\u0026#39; 4output_pdf_path = \u0026#39;xxx_1.pdf\u0026#39; 5pdf_password = \u0026#39;test123\u0026#39; 6 7# 打开受密码保护的PDF文件 8pdf_document = fitz.open(input_pdf_path) 9 10# 检查PDF是否加密 11if pdf_document.is_encrypted: 12 # 尝试使用密码解密 13 if not pdf_document.authenticate(pdf_password): 14 print(\u0026#34;Invalid password. Cannot remove password from PDF.\u0026#34;) 15 pdf_document.close() 16 exit(1) 17 18# 保存一个新的无密码PDF文件 19pdf_document.save(output_pdf_path, encryption=fitz.PDF_ENCRYPT_NONE) 20pdf_document.close() 21 22print(\u0026#39;PDF password has been removed.\u0026#39;) PDF加书签 https://github.com/ifnoelse/pdf-bookmark.git\n由于网上download的ISO14229文档没有书签，故找了个小工具可以添加书签，留此记录。\nGitHub - chroming/pdfdir: PDF导航（大纲/目录）添加工具\n目录需要正则表达式匹配：\n二层 ^\\d\\d?.\\d\\d?\\s 三层 ^\\d\\d?.\\d\\d?.\\d\\d?\n1xyz=\u0026#39;\u0026#39;\u0026#39; 2Annex I (normative) Security access state chart 450 3Annex J (informative) Recommended implementation for multiple client environments 458 4Bibliography 464 5\u0026#39;\u0026#39;\u0026#39; 6lines = xyz.split(\u0026#39;\\n\u0026#39;) 7#print(lines) 8for line in lines: 9 matchObj = re.search( r\u0026#39;\\w+$\u0026#39;, line, re.M|re.I) 10 if matchObj: 11 x=int(matchObj.group())+12 12 print(re.sub(r\u0026#39;\\w+$\u0026#39;, str(x), line)) 13 # else: 14 # print( \u0026#34;No match!!\u0026#34;) 15#re.search( r\u0026#39;\\w+$\u0026#39;, line, re.M|re.I) python加解密 1 2# pip3 install pycryptodome pillow 3 4from Crypto.Cipher import AES, PKCS1_OAEP 5from Crypto.PublicKey import RSA 6import zipfile 7from PIL import Image 8from Crypto.Cipher import AES 9from Crypto.Random import get_random_bytes 10import os 11import io 12import tarfile 13 14def unpad(data): 15 pad_len = data[-1] 16 return data[:-pad_len] 17 18def decrypt_file(input_file, output_folder, private_key_file): 19 with open(private_key_file, \u0026#39;rb\u0026#39;) as f: 20 rsa_key = RSA.import_key(f.read()) 21 rsa_cipher = PKCS1_OAEP.new(rsa_key) 22 23 rsa_key_len_bytes = rsa_key.size_in_bits() // 8 # e.g. 4096 bits → 512 bytes 24 25 with open(input_file, \u0026#39;rb\u0026#39;) as f: 26 encrypted_key = f.read(rsa_key_len_bytes) 27 iv = f.read(16) 28 encrypted_data = f.read() 29 30 aes_key = rsa_cipher.decrypt(encrypted_key) 31 aes_cipher = AES.new(aes_key, AES.MODE_CBC, iv) 32 decrypted_data = unpad(aes_cipher.decrypt(encrypted_data)) 33 34 tar_buffer = io.BytesIO(decrypted_data) 35 with tarfile.open(fileobj=tar_buffer, mode=\u0026#34;r:xz\u0026#34;) as tar: 36 tar.extractall(output_folder) 37 38def get_prefix(a: str) -\u0026gt; str: 39 base = a.replace(\u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;).rstrip(\u0026#34;/\u0026#34;).split(\u0026#34;/\u0026#34;)[-1] 40 return os.path.splitext(base)[0] 41 42def decrypt_bin(input_bin:str, private_key=\u0026#39;private.pem\u0026#39;): 43 output_dir = get_prefix(input_bin) 44 decrypt_file(input_bin, output_dir, private_key) 45 46def zip_folder(folder_path, zip_path): 47 with zipfile.ZipFile(zip_path, \u0026#39;w\u0026#39;, zipfile.ZIP_DEFLATED) as zipf: 48 for root, _, files in os.walk(folder_path): 49 for file in files: 50 full_path = os.path.join(root, file) 51 arcname = os.path.relpath(full_path, folder_path) 52 zipf.write(full_path, arcname) 53 54def pad(data): 55 pad_len = 16 - len(data) % 16 56 return data + bytes([pad_len] * pad_len) 57 58def encrypt_data_and_write(data: bytes, output_file: str, public_key_file: str, aes_key_len: int = 32): 59 if aes_key_len not in (16, 24, 32): 60 raise ValueError(\u0026#34;AES key length must be 16, 24, or 32 bytes\u0026#34;) 61 62 rsa_key = RSA.import_key(open(public_key_file, \u0026#39;rb\u0026#39;).read()) 63 rsa_cipher = PKCS1_OAEP.new(rsa_key) 64 65 aes_key = get_random_bytes(aes_key_len) 66 iv = get_random_bytes(16) 67 68 encrypted_key = rsa_cipher.encrypt(aes_key) 69 cipher = AES.new(aes_key, AES.MODE_CBC, iv) 70 encrypted_data = cipher.encrypt(pad(data)) 71 72 with open(output_file, \u0026#39;wb\u0026#39;) as f: 73 f.write(encrypted_key) 74 f.write(iv) 75 f.write(encrypted_data) 76 77def encrypt_bin(input_dir:str, public_key=\u0026#39;public.pem\u0026#39;) -\u0026gt; str: 78 output_bin = f\u0026#39;{get_prefix(input_dir)}.bin\u0026#39; 79 buf = io.BytesIO() 80 with tarfile.open(fileobj=buf, mode=\u0026#34;w:xz\u0026#34;, preset=9) as tar: 81 tar.add(input_dir, arcname=os.path.basename(input_dir)) 82 encrypt_data_and_write(buf.getvalue(), output_bin, public_key, aes_key_len=32) # AES-256 83 return f\u0026#39;{output_bin}\u0026#39; 84 85def unpad(data): 86 pad_len = data[-1] 87 return data[:-pad_len] 88 89def extract_data_from_image(stego_path, output_bin_path, key, payload_len): 90 img = Image.open(stego_path).convert(\u0026#34;RGB\u0026#34;) 91 pixels = list(img.getdata()) 92 93 bit_idx = 0 94 byte = 0 95 data_bytes = bytearray() 96 for pixel in pixels: 97 for color in pixel: 98 bit = color \u0026amp; 1 99 byte = (byte \u0026lt;\u0026lt; 1) | bit 100 bit_idx += 1 101 if bit_idx == 8: 102 data_bytes.append(byte) 103 byte = 0 104 bit_idx = 0 105 if len(data_bytes) \u0026gt;= payload_len: 106 break 107 if len(data_bytes) \u0026gt;= payload_len: 108 break 109 110 iv = data_bytes[:16] 111 encrypted = data_bytes[16:] 112 113 cipher = AES.new(key, AES.MODE_CBC, iv) 114 decrypted = unpad(cipher.decrypt(encrypted)) 115 116 with open(output_bin_path, \u0026#39;wb\u0026#39;) as f: 117 f.write(decrypted) 118 119def decrypt_png(png_key_dlen_str:str) -\u0026gt; str: 120 input_png, key_hex, dlen_str = png_key_dlen_str.split(\u0026#34;:\u0026#34;) 121 output_bin = f\u0026#39;{get_prefix(input_png)}.bin\u0026#39; 122 extract_data_from_image(input_png, output_bin, bytes.fromhex(key_hex), int(dlen_str)) 123 return f\u0026#39;{output_bin}\u0026#39; 124 125def encrypt_data(data, key, iv): 126 cipher = AES.new(key, AES.MODE_CBC, iv) 127 return cipher.encrypt(pad(data)) 128 129def embed_data_to_image(image_path, bin_path, output_path, key): 130 iv = get_random_bytes(16) 131 with open(bin_path, \u0026#39;rb\u0026#39;) as f: 132 data = f.read() 133 encrypted = encrypt_data(data, key, iv) 134 payload = iv + encrypted 135 136 img = Image.open(image_path).convert(\u0026#34;RGB\u0026#34;) 137 pixels = list(img.getdata()) 138 139 bits = \u0026#39;\u0026#39;.join(f\u0026#39;{byte:08b}\u0026#39; for byte in payload) 140 if len(bits) \u0026gt; len(pixels) * 3: 141 raise ValueError(\u0026#34;数据太大，无法嵌入这张图片。\u0026#34;) 142 143 new_pixels = [] 144 bit_idx = 0 145 for pixel in pixels: 146 r, g, b = pixel 147 if bit_idx \u0026lt; len(bits): 148 r = (r \u0026amp; 0xFE) | int(bits[bit_idx]) 149 bit_idx += 1 150 if bit_idx \u0026lt; len(bits): 151 g = (g \u0026amp; 0xFE) | int(bits[bit_idx]) 152 bit_idx += 1 153 if bit_idx \u0026lt; len(bits): 154 b = (b \u0026amp; 0xFE) | int(bits[bit_idx]) 155 bit_idx += 1 156 new_pixels.append((r, g, b)) 157 158 img.putdata(new_pixels) 159 img.save(output_path) 160 # print(f\u0026#34;✅ ：{output_path}\u0026#34;) 161 162 return len(payload) 163 164def encrypt_png(input_png:str, input_bin:str, keylen:int = 32) -\u0026gt; str: #16-128 24-196 32-256 165 key = get_random_bytes(keylen) 166 prefix, ext = os.path.splitext(input_png) 167 payload_len = embed_data_to_image(input_png, input_bin, f\u0026#39;{prefix}_new{ext}\u0026#39;, key) 168 return f\u0026#39;{prefix}_new{ext}:{key.hex()}:{payload_len}\u0026#39; 169 170def generate(len=8192): 171 key = RSA.generate(len) 172 private_key = key.export_key() 173 public_key = key.publickey().export_key() 174 175 with open(\u0026#34;private.pem\u0026#34;, \u0026#34;wb\u0026#34;) as f: 176 f.write(private_key) 177 178 with open(\u0026#34;public.pem\u0026#34;, \u0026#34;wb\u0026#34;) as f: 179 f.write(public_key) 180 print(\u0026#34;🔑 密钥对已生成：private.pem / public.pem\u0026#34;) 181 182def main(): 183 print() 184 # generate() 185 # decrypt_bin(decrypt_png(encrypt_png(\u0026#39;t.png\u0026#39;, encrypt_bin(\u0026#39;a\u0026#39;)))) 186 187if __name__ == \u0026#39;__main__\u0026#39;: 188 os.chdir(os.path.join(os.path.dirname(os.path.abspath(__file__)))) 189 main() 青龙 faker2\njdpro\nandroid auto.js Android System WebView\n包名查看器 https://www.coolapk.com/apk/com.csdroid.pkg\n反编译: jadx\nlog查看:\nlognote CatSpy 1set path=C:\\Android\\openjdk\\jdk-17.0.8.101-hotspot\\bin;%path% 2java -jar CatSpy.jar 可启动U盘 可启动U盘: Ventoy\ngithub仓库 垃圾站点过滤：chinese-internet-is-dead\n一些技术pdf：develop-reference-data\nfreertos源码：FreeRTOS_Template\n小程序反汇编：wxapkg\nPDF编辑工具：Stirling-PDF\nOCR通用验证码离线本地识别：ddddocr\n通用的Ｃ基础库：gear-lib\nAutosar配置界面：Autosar-Configurator\n校园二手商城微信小程序云开发：used-book-secondhand\n开源网络流量监控工具：sniffnet\n防多次错误认证：fail2ban\nohmyzsh\n文件类型识别：Detect-It-Easy\nCPU监测：RunCat365\n编程相关书籍 free-programming-books-zh\nhttps://github.com/p-moon/develop-reference-data\n","date":"2025年7月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/doraemon/","series":[{"title":"懒人教程系列","url":"/series/%E6%87%92%E4%BA%BA%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97/"}],"smallImg":"","tags":[{"title":"工具箱","url":"/tags/%E5%B7%A5%E5%85%B7%E7%AE%B1/"},{"title":"ToolBox","url":"/tags/toolbox/"},{"title":"Linux","url":"/tags/linux/"},{"title":"Win","url":"/tags/win/"}],"timestamp":1751383982,"title":"懒人技术手册"},{"authors":[],"categories":[{"title":"懒人快捷键","url":"/categories/%E6%87%92%E4%BA%BA%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"content":"一、说明 Ctrl – k: 先按住 Ctrl 键，然后再按 k 键；\nAlt – k: 先按住 Alt 键，然后再按 k 键；\nM – k：先单击 Esc 键，然后再按 k 键。\n二、移动光标 Ctrl – a: 移到行首\nCtrl – e: 移到行尾\nCtrl – b: 往回(左)移动一个字符\nCtrl – f: 往后(右)移动一个字符\nAlt – b: 往回(左)移动一个单词\nAlt – f: 往后(右)移动一个单词\nCtrl – xx: 在命令行尾和光标之间移动\n三、编辑命令 Ctrl – h: 删除光标左方位置的字符\nCtrl – d: 删除光标右方位置的字符（注意：当前命令行没有任何字符时，会注销系统或结束终端）\nCtrl – w: 由光标位置开始，往左删除单词。往行首删\nAlt – d: 由光标位置开始，往右删除单词。往行尾删\nCtrl – k: 由光标所在位置开始，删除右方所有的字符，直到该行结束。\nCtrl – u: 由光标所在位置开始，删除左方所有的字符，直到该行开始。\nCtrl – y: 粘贴之前删除的内容到光标后。\nAlt + t: 交换光标处和之前两个字符的位置。\nAlt + .: 使用上一条命令的最后一个参数。\nCtrl – _: 回复之前的状态。撤销操作。\nCtrl -a + Ctrl -k 或 Ctrl -e + Ctrl -u 或 Ctrl -k + Ctrl -u 组合可删除整行。\n四、Bang(!)命令 !!: 执行上一条命令。\nfoobar: 把上一条命令里的foo替换为bar，并执行。\n!wget: 执行最近的以wget开头的命令。\n!wget:p: 仅打印最近的以wget开头的命令，不执行。\n!$: 上一条命令的最后一个参数， 与 Alt - . 和 $_ 相同。\n!*: 上一条命令的所有参数\n!*:p: 打印上一条命令是所有参数，也即 !*的内容。\n^abc: 删除上一条命令中的abc。\nfoobar: 将上一条命令中的 foo 替换为 bar\nfoobar^: 将上一条命令中的 foo 替换为 bar\n!-n: 执行前n条命令，执行上一条命令： !-1， 执行前5条命令的格式是： !-5\n五、查找历史命令 Ctrl – p: 显示当前命令的上一条历史命令\nCtrl – n: 显示当前命令的下一条历史命令\nCtrl – r: 搜索历史命令，随着输入会显示历史命令中的一条匹配命令，Enter键执行匹配命令；ESC键在命令行显示而不执行匹配命令。\nCtrl – g: 从历史搜索模式（Ctrl – r）退出。\n六、控制命令 Ctrl – l: 清除屏幕，然后，在最上面重新显示目前光标所在的这一行的内容。\nCtrl – o: 执行当前命令，并选择上一条命令。\nCtrl – s: 阻止屏幕输出\nCtrl – q: 允许屏幕输出\nCtrl – c: 终止命令\nCtrl – z: 挂起命令\n七、重复执行操作动作 M – 操作次数 操作动作: 指定操作次数，重复执行指定的操作。\n参考 linux 命令行 光标移动技巧\n","date":"2025年7月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/linux/shell/terminalshortcutkeys/","series":[{"title":"懒人教程系列","url":"/series/%E6%87%92%E4%BA%BA%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97/"}],"smallImg":"","tags":[{"title":"Terminal","url":"/tags/terminal/"},{"title":"Shell","url":"/tags/shell/"},{"title":"快捷键","url":"/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"timestamp":1751380576,"title":"终端快捷键"},{"authors":[],"categories":[{"title":"Trace32使用说明","url":"/categories/trace32%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"}],"content":"TC397xp下载脚本 tc397.bat 方便第一次启动trace32软件\n1@echo off 2rem 设置 Trace32 安装路径（根据你的实际安装目录修改） 3set TRACE32_PATH=C:\\T32 4 5rem 设置配置文件和启动脚本路径（根据实际路径修改） 6set CONFIG_FILE=%TRACE32_PATH%\\config.t32 7set CMM_SCRIPT=D:\\mycodedev\\project-tc397\\elf\\my-tc39x.cmm 8 9rem 启动 TRACE32 并加载脚本 10@REM start \u0026#34;\u0026#34; \u0026#34;%TRACE32_PATH%\\bin\\t32.exe\u0026#34; -c \u0026#34;%CONFIG_FILE%\u0026#34; -s \u0026#34;%CMM_SCRIPT%\u0026#34; 11start \u0026#34;\u0026#34; \u0026#34;%TRACE32_PATH%\\bin\\windows64\\t32mtc.exe\u0026#34; -c \u0026#34;%CONFIG_FILE%\u0026#34; -s \u0026#34;%CMM_SCRIPT%\u0026#34; value.cmm 可以在trace32软件上调整布局需要的窗口之后store windows，根据需求修改即可\n1// T32 Fri May 28 10:03:39 2023 2 3B:: 4 5TOOLBAR ON 6STATUSBAR ON 7FramePOS 39.432,15.216,,,Maximized 8WinPAGE.RESet 9 10WinPAGE.Create P000 11WinCLEAR 12 13WinPOS 33.729 35.83 51. 16. 0. 0. W004 14SYStem 15 16WinPOS 47.134 24.627 123. 21. 23. 1. W001 17WinTABS 13. 0. 0. 0. 0. 0. 0. 0. 0. 72. 18Break.List 19 20WinPOS 63.308 26.476 113. 26. 13. 1. W003 21WinTABS 10. 10. 25. 22List P:0x8021A074 23 24WinPOS 56.154 11.714 140. 37. 5. 0. W002 25Frame 26 27WinPOS 0.0 0.0 158. 64. 0. 0. W000 28Var.Watch 29 30; 根据需要添加变量 31Var.AddWatch testcnt 32 33WinPOS 93.375 25.786 96. 46. 13. 1. W004 34Data.dump Var.ADDRESS(\u0026#34;test_buf\u0026#34;) /DIALOG 35 36// b.set func_test 37b.set Mcu_PerformReset 38 39WinPAGE.select P000 40 41ENDDO my-tc39x.cmm 1; y.spath.srd D:\\mycodedev\\project-tc397 2; 注释标识符 3 4system.CPU.TC397Xp 5 6SYStem.DOWN 7SYStem.RESeT 8 9; 烧录下载 10do tc39x.cmm 11 12; 方便调试相关 13do value.cmm 14 15SYStem.Option.DUALPORT on 16 17SYStem.mode.down 18SYStem.mode.up 19SYStem.mode.go 20 21OS.LoadORTI \u0026#34;RTAOS.orti\u0026#34; 22// core.assign 1 2 3 4 5 6 tc39x.cmm 默认Flash刷写*.cmm脚本路径：安装路径\\demo\\tricore\\flash 如：C:\\T32\\demo\\tricore\\flash\\tc397xp.cmm\nTC397多核debug 帮助文档 C:\\T32\\pdf\\debugger_tricore.pdf\n烧录完成之后启动时core0，如果需要调试core1，此操作的断点只会在core1上生效\n1system.mode.NoDebug 2system.config.core 2 3system.mode.attach 4; break 5; go此操作的断点会在所有设置的核上生效\n1system.mode.NoDebug 2; 调试所有的6个核 3core.number 6 4; 只调试部分核 5core.assign 1 2 3 当前Core 0 和Core 1各自的寄存器信息 1Register /Core 0 2Register /Core 1 多窗口调试 Power Debug USB右键 add PowerView Instance，需要同时调试core0和core1 在core0窗口正常烧录下载，到core1窗口配置符号表调试\nData.LOAD.Elf test.elf /NoCODE 注：NoCODE ： Suppresses the code download. Only loads symbolic information. 参考：https://www2.lauterbach.com/pdf/general_ref_d.pdf\n配置core为1-\u0026gt;核0，core为2-\u0026gt;核1\n1Format: SYStem.CONFIG.CORE \u0026lt;core_index\u0026gt; \u0026lt;chip_index\u0026gt; 2 3\u0026lt;chip_index\u0026gt;: 1 … i 4\u0026lt;core_index\u0026gt;: 1 … k 参考：https://www2.lauterbach.com/pdf/debugger_mcore.pdf\n脚本加载 my-tc39x-core1.cmm\n1; y.spath.srd D:\\mycodedev\\project-tc397 2; 注释标识符 3 4Data.LOAD.Elf D:\\mycodedev\\project-tc397\\build\\test.elf /NoCODE 5 6system.CPU.TC397Xp 7 8SYStem.Mode.NoDebug 9 10system.CONFIG.CORE 2 11 12SYStem.Option.DUALPORT on 13 14TASK.ORTI \u0026#34;RTAOS.orti\u0026#34; 15 16do vlaue.cmm 17 18SYStem.Mode.Attach即拖拽my-tc39x.cmm到core0烧录运行debug，拖拽my-tc39x-core1.cmm到core1窗口debug\n其他 GHS-TC397编译器 配置 license, config/license.cfg GHS_LMHOST=ip:port\n帮助文档资料：通过helpview.exe进行查询\n如反汇编脚本：\n1@echo off 2 3set TARGET_DIR=build 4 5if exist \u0026#34;%TARGET_DIR%\u0026#34; ( 6 echo Deleting dir...: %TARGET_DIR% 7 @REM rmdir /s /q \u0026#34;%TARGET_DIR%\u0026#34; 8) 9 10set \u0026#34;currentDir=%CD%\u0026#34; 11 12set PATH=%currentDir%\\bin;C:\\ghs\\bin;%path% 13 14@REM enter build dir 15pushd build 16 17@REM build elf 18cctri.exe test.c -cpu=tc1v162 -half_precision_type -g -dual_debug -X5853 -Omax -Xtricore_opts_20181 -ansi_alias -delete -data_delete -Onoalign_functions -no_align_standalone_objects --no_vla -discard_zero_initializers --no_commons --gnu_asm -tricore_avoid_mem_trap -version_info -w -errmax=10 -passsource --c++14 --no_rtti --restrict --new_outside_of_constructor -globalcheck=normal -globalcheck_qualifiers --diag_warning=undefined_preproc_id --diag_warning=missing_type_specifier --no_wrap_diagnostics -nostartfiles -Mu -Mx -Ml -Mn -keepmap --preprocess_linker_directive_full -Wl,-no_append -nostartfiles -Mu -Mx -Ml -Mn -keepmap --preprocess_linker_directive_full -Wl,-no_append -o tc397.elf 19@REM Disassembly 20gdump.exe -asm -yd -yl -ylaball tc397.elf \u0026gt; relocations.txt 21 22popd 部分反汇编代码示例：\n1movh.a\ta2, 0xa000 2mov16\td15, 1 3st.b\t[a2]89, d15 4ret16 5 tttx1: 6 __ghs_eofn_t234x1: 7movh.a\ta2, 0xa000 8mov16\td15, 1 9st.b\t[a2]89, d15 10ret16 11 func1: 12 __ghs_eofn_tttx1: 13movh.a\ta2, 0xa000 14mov16\td15, 1 15st.b\t[a2]89, d15 16call\t.-22 (0xa000000c) 17ret16 18 func2: 19 __ghs_eofn_func1: 20mov16\td8, d4 21movh.a\ta2, 0xa000 22st.b\t[a2]90, d8 23ret16 24 __ghs_eofn_func2: 25 func3: 26movh.a\ta2, 0xa000 27ld.bu\td15, [a2]91 28extr.u\td2, d15, 0, 8 29ret16 30 __ghs_eofn_func3: 31 main: 32call\t.-66 (0xa0000000) 33call\t.-46 (0xa0000018) 34mov16\td4, 2 35call\t.-36 (0xa0000028) 36call\t.-28 (0xa0000034) 37mov16\td2, 0 38ret16 39 40da\t. DW_TAG_subprogram 41\tDW_AT_name(\u0026#34;func1\u0026#34;) 42\tDW_AT_decl_line(15) 43\tDW_AT_decl_column(6) 44\tDW_AT_decl_file(1) 45\tDW_AT_low_pc(0xa0000018) 46\tDW_AT_high_pc(0xa0000028) 47\tDW_AT_frame_base: reg26 48\tDW_AT_ghs_rsm(0) 49\tDW_AT_ghs_rso(0) 50\tDW_AT_ghs_frsm(4294967295) 51\tDW_AT_ghs_frames(0) 52\tDW_AT_ghs_subcpu(0) 53\tDW_AT_declaration(false) 54\tDW_AT_inline(DW_INL_not_inlined) 55\tDW_AT_external(true) 56\tDW_AT_accessibility(DW_ACCESS_public) 57\tDW_AT_virtuality(DW_VIRTUALITY_none) 58\tDW_AT_prototyped(false) 59 60fb\t. . TAG_lexical_block 61\tDW_AT_low_pc(0xa0000018) 62\tDW_AT_high_pc(0xa0000026) 参考 J-Link Multi-core debugging\nTc397freertos_lwip\narm栈回溯\n","date":"2025年7月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/trace32/","series":[{"title":"嵌入式调试","url":"/series/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%B0%83%E8%AF%95/"}],"smallImg":"","tags":[{"title":"Trace32","url":"/tags/trace32/"},{"title":"Debug","url":"/tags/debug/"}],"timestamp":1751379132,"title":"TRACE32使用教程"},{"authors":[],"categories":[{"title":"Markdown-Tutorial","url":"/categories/markdown-tutorial/"}],"content":"vscode远程粘贴图片 插件 Paste Image from local pc，项目地址：https://github.com/mushanshitiancai/vscode-paste-image\n1 win: ctrl+alt+v 2 # 如需修改粘贴目录 \u0026#34;pasteImage.path\u0026#34;: \u0026#34;images/${fileBasenameNoExtension}\u0026#34; 目录标题 直接输入1次#，并按下space后，将生成1级标题。 输入2次#，并按下space后，将生成2级标题。 以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。\n文本格式 强调文本 强调文本\n加粗文本 加粗文本\n==标记文本==\n删除文本\n引用文本\nH2O 是液体。 这是下标文本\n2^10^ 运算结果是 1024. 这是上标文本\n这是带下划线的文本\n1\u0026lt;pre\u0026gt; 2中间的文本保留换行，回车等格式 3\u0026lt;/pre\u0026gt; 链接与图片 链接: link.\n图片: 带尺寸的图片(HTML \u0026lt;img\u0026gt; 标签):30x30 只居中图片: 居中的图片且设置尺寸: 代码片 同样高亮的 代码片.\n1// An highlighted block 2var foo = \u0026#39;bar\u0026#39;; 列表 可通过在一行或多行文本前面加上 -、* 或 + 来创建一个无序列表\n项目 项目 项目 要对列表排序，请在每行前面添加一个编号\n项目1 项目2 项目3 First item Second item Third item Fourth item 任务列表, 请在列表项前加连字符和空格，后接 [ ]。 要将任务标记为完成，请使用 [x]\n计划任务 完成任务 表情符号 你可以通过键入 :EMOJICODE:（冒号后跟表情符号的名称）将表情符号添加到写作中。\n@octocat \u0026#x1f44d; This PR looks great - it\u0026rsquo;s ready to merge! \u0026#x1f600;\n有关可用表情符号和代码的完整列表，请参阅 Emoji-Cheat-Sheet\n脚注 Here is a simple footnote1.\n一个具有注脚的文本。2\n锚点 TEST\n00: 01: TEST脚注\n折叠块 展开表格 Field Bits Type Description C 31 rw Carry 默认展开 Field Bits Type Description C 31 rw Carry 表格 一个简单的表格是这么创建的：\n项目 Value 电脑 $1600 手机 $12 导管 $1 居中、居左、居右 使用:---------:居中 使用:----------居左 使用----------:居右\n第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 test test test SmartyPants SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：\nTYPE ASCII HTML Single backticks 'Isn't this fun?' \u0026lsquo;Isn\u0026rsquo;t this fun?\u0026rsquo; Quotes \u0026quot;Isn't this fun?\u0026quot; \u0026ldquo;Isn\u0026rsquo;t this fun?\u0026rdquo; Dashes -- is en-dash, --- is em-dash \u0026ndash; is en-dash, \u0026mdash; is em-dash 自定义列表? Markdown Text-to-HTML conversion tool Authors John Luke plantuml 需要调整hugo主题支持\n@startuml Bob -\u003e Alice : hello @enduml KaTeX数学公式 您可以使用渲染LaTeX数学表达式 KaTeX:\nGamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 是通过欧拉积分\n$$ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt,. $$\n你可以找到更多关于的信息 LaTeX 数学表达式here.\n甘特图 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表 可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：\nsequenceDiagram 张三 -\u0026gt;\u0026gt; 李四: 你好！李四, 最近怎么样? 李四--\u0026gt;\u0026gt;王五: 你最近怎么样，王五？ 李四--x 张三: 我很好，谢谢! 李四-x 王五: 我很好，谢谢! Note right of 王五: 李四想了很长时间, 文字太长了\u0026lt;br/\u0026gt;不适合放在一行. 李四--\u0026gt;\u0026gt;张三: 打量着王五... 张三-\u0026gt;\u0026gt;王五: 很好... 王五, 你怎么样? 这将产生一个流程图。:\ngraph LR A[长方形] -- 链接 --\u0026gt; B((圆)) A --\u0026gt; C(圆角长方形) B --\u0026gt; D{菱形} C --\u0026gt; D 关于 Mermaid 语法，参考 这儿, FLowchart流程图 我们依旧会支持flowchart的流程图：\nflowchart TD st([开始]) op[我的操作] cond{确认？} e([结束]) st --\u0026gt; op --\u0026gt; cond cond -- 是 --\u0026gt; e cond -- 否 --\u0026gt; op 关于 Flowchart流程图 语法，参考 这儿. 注释 1 \u0026lt;!-- TO DO: add more details about me later --\u0026gt; My reference.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n示例，注脚的解释\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025年6月29日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/markdown/markdown/","series":[{"title":"Markdown教程","url":"/series/markdown%E6%95%99%E7%A8%8B/"}],"smallImg":"","tags":[{"title":"Markdown","url":"/tags/markdown/"},{"title":"编辑器","url":"/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"title":"写作","url":"/tags/%E5%86%99%E4%BD%9C/"}],"timestamp":1751209871,"title":"Markdown"},{"authors":[],"categories":[{"title":"嵌入式架构","url":"/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9E%B6%E6%9E%84/"}],"content":"Arm Cortex-R52处理器提供高性能32位处理器，提供高效的代码密度，并结合任何Arm处理器的功能安全的最高水平的集成能力。Cortex-R52处理器满足了高级实时嵌入式系统日益增长的性能需求。作为第一款Armv8-R处理器，Cortex-R52引入了对虚拟机管理程序的支持，通过强大的分离简化了软件集成，以保护安全关键代码。\nArmv8-R Architecture Reference Manual ARM® Cortex®-A Series Programmer’s Guide for ARMv8-A Arm Architecture Reference Manual for A-profile architecture for A-profile architecture Arm Generic Interrupt Controller (GIC) Architecture Specification, v3 and v4\n参考链接 Arm® Cortex®-R52 Processor Technical Reference Manual\n","date":"2025年6月29日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/arm/cortex-r/cortex-r52/cortex-r52/","series":[{"title":"ARM 架构系列","url":"/series/arm-%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97/"}],"smallImg":"","tags":[{"title":"ARM","url":"/tags/arm/"},{"title":"Cortex-R52","url":"/tags/cortex-r52/"}],"timestamp":1751207233,"title":"Cortex-R52"},{"authors":[],"categories":[{"title":"网络通信","url":"/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"content":" 名词解释 缩略词 全称 详细解释 应用场景 WLP Writer Liveliness Protocol 用于检测发布者（Writer）存活状态的协议，通过定期发送心跳信号实现 故障检测、QoS中的LIVELINESS策略配置 CDR Common Data Representation DDS标准定义的数据编码格式，支持跨平台数据序列化（大端序/小端序自适应） 网络传输、持久化存储、跨语言（C++/Java等）数据交换 RTPS Real-Time Publish-Subscribe DDS底层通信协议，基于UDP实现实时发布订阅模式 设备发现、数据路由 QoS Quality of Service 服务质量策略集合（如可靠性、延迟约束等） 配置数据传输的可靠性(RELIABLE/BEST_EFFORT)、持久性(DURABILITY)等 GUID Global Unique Identifier 全局唯一标识符，格式：Prefix[12字节] + EntityId[4字节] 唯一标识DDS域中的参与者和终结点 DCPS Data-Centric Publish-Subscribe DDS核心API层，提供主题(Topic)、数据写入(DataWriter)/读取(DataReader)等抽象 应用程序开发接口 DDSI-RTPS DDS Interoperability Wire Protocol 保证不同DDS实现间互操作的网络协议规范 多厂商DDS系统集成（如RTI Connext与Fast DDS通信） IDL Interface Definition Language 一种用于定义接口、数据类型和常量的语言无关描述语言，常用于分布式系统（如CORBA）或生成C++、Java、Python等语言的代码 DDS 是什么 Data Distribution Service (DDS) 是一种由 Object Management Group (OMG) 制定的用于实时系统的数据分发标准，是一种中间件协议和 API，旨在实现高效、可靠、可扩展的机器对机器（M2M）通信。它基于发布-订阅(Publish-Subscribe) 模型，特别适用于需要实时、高性能、分布式数据交换的场景。\n出现背景 DDS 的开发始于 2001 年，OMG 在 2004 年发布了 DDS 1.0 版本，随后在 2005 年、2007 年和 2015 年分别发布了 1.1、1.2 和 1.4 版本。DDS 的出现是为了应对传统网络编程在复杂分布式系统中的挑战，尤其是在以下领域：\n实时性要求高：如航空航天、国防、自动驾驶、医疗设备、机器人和智能电网管理。 分布式系统复杂性：传统网络通信需要手动管理连接、地址配置和数据格式，开发复杂且易出错。\n高可靠性与可扩展性：传统中间件（如消息队列或基于 TCP 的通信）在高负载或动态网络环境中难以满足低延迟和高可靠性的需求。\n解决的问题 DDS 通过以下特性解决了分布式实时系统的核心问题：\n解耦发布者和订阅者：应用程序无需知道彼此的存在或位置，DDS 中间件自动处理消息传递，降低开发复杂性。 实时性与低延迟：基于 UDP 的 RTPS（Real-Time Publish-Subscribe）协议，延迟可低至数百微秒，适合实时应用。 可扩展性：支持从嵌入式设备到云端的大规模系统，动态发现新节点，适应网络变化。\n灵活的 QoS（服务质量）：通过丰富的 QoS 策略，满足不同场景对可靠性、优先级、延迟等的特定需求。 安全性：支持认证、加密和访问控制，适用于安全敏感场景。 数据中心化：DDS 关注数据本身，允许定义数据结构和类型，支持内容过滤，减少不必要的数据传输。 DDS 广泛应用于国防（雷达、导航系统）、航空（空中交通控制）、工业 IoT（风力发电场）、机器人（ROS 2 默认中间件）以及自动驾驶等领域。例如，NASA 在肯尼迪航天中心使用 DDS 进行发射控制，波音和空客将其用于航空系统。\n架构模型 DDS 的架构基于数据中心发布-订阅（Data-Centric Publish-Subscribe, DCPS）模型，核心理念是将数据组织在一个虚拟的全局数据空间（Global Data Space, GDS） 中，应用程序通过发布和订阅“主题（Topic）”交换数据。以下是关键概念：\nDomain（域） Domain 是 DDS 的逻辑通信范围，每个 Domain 由一个唯一的 Domain ID（整数） 标识。属于同一个 Domain 的参与者（Domain Participant）可以发现并通信，不同 Domain 之间的数据完全隔离。\n作用：\n用于划分不同的通信场景或系统实例，例如测试环境和生产环境可以用不同的 Domain ID。 Domain 是 DDS 中的“虚拟总线”，所有发布和订阅行为都发生在特定 Domain 内。 特点：\n一个应用程序可以加入多个 Domain。 同一个 Domain ID 的所有参与者共享发现信息和主题。 不同 Domain 之间天然隔离，提升安全性和模块化。 Participation（参与者） Domain Participant（域参与者）：DDS 中的顶级实体，表示一个应用程序参与 DDS 域（Domain）的实例。每个域由唯一的域 ID 标识，域是逻辑隔离的通信空间，域内参与者共享数据，域间数据不互通。\n作用：\n域参与者负责创建发布者（Publisher）、订阅者（Subscriber）、主题（Topic）等，是应用程序与 DDS 中间件的接口。 特点：\n支持动态发现，自动识别域内其他参与者，无需手动配置 IP 地址或端口。 端口（Port） DDS 通常基于 RTPS（Real-Time Publish-Subscribe） 协议，使用 UDP 传输。端口在 DDS 中主要用于：\n动态发现：通过特定的多播地址和端口（如默认 7400 端口）进行参与者和端点的发现。 数据传输：每个参与者分配一组端口用于发送和接收数据，端口号由域 ID 和参与者 ID 计算，遵循 RTPS 规范。 端口分配：RTPS 协议定义了端口映射规则，确保不同参与者、主题的数据通信不冲突。例如，参与者使用多播端口（如 239.255.0.1）进行发现，单播端口用于数据传输。 端口计算方式 基端口号（PB）：默认7400。 域增益（DG）：通常为250。 参与者增益（PG）：通常为2。 偏移（d0, d1, d2, d3）： 多播发现（d0:0） 单播发现（d1:10） 多播用户数据（d2:1） 单播用户数据（d3:11）。 对于Domain ID = 0，Participant ID = 0： 发现多播端口：PB + DG * Domain_ID + d0 = 7400 + 250 * 0 + 0 = 7400 发现单播端口：PB + DG * Domain_ID + d1 + PG * Participant_ID = 7400 + 250 * 0 + 10 + 2 * 0 = 7410 用户数据多播端口：PB + DG * Domain_ID + d2 = 7400 + 250 * 0 + 1 = 7401 用户数据单播端口：PB + DG * Domain_ID + d3 + PG * Participant_ID = 7400 + 250 * 0 + 11 + 2 * 0 = 7411 socket 配置 - Discovery traffic type - multicast - unicast - User traffic type - multicast - unicast mvbs中配置了三个socket：(不同的配置，对应不同的逻辑，比如组播socket只接收) 发现组播socket: 发送/接收组播 发现单播socket: 接收发现单播 数据单播socket: 发送/接收数据单播, 发送发现单播 内置 Topic（Built-in Topics） 定义：DDS 提供内置主题，用于管理元数据和系统状态，如参与者、发布者、订阅者的信息。\n作用：\n内置主题由 DDS 中间件自动发布和订阅，用于动态发现和管理。\n例如，Participant 主题记录域内所有参与者的信息，Topic 描述主题信息。 作用：\n支持动态发现、监控系统状态（如新节点加入或退出），确保系统无需手动配置即可运行。 服务发现 分布式系统中的参与者（Participants）通过特定的机制发现彼此的存在、Topic、DataWriter 和 DataReader，以便建立数据通信。DDS 使用 RTPS（Real-Time Publish-Subscribe）协议 来实现发现过程，主要包括两种发现机制：Participant Discovery（参与者发现） 和 Endpoint Discovery（端点发现）\nDDS 发现机制概述 DDS 的发现过程确保系统中的所有参与者能够动态地找到彼此并匹配发布者和订阅者的需求，而无需手动配置网络地址。发现过程分为两个阶段：\nParticipant Discovery Phase (PDP)： 目的：发现网络中的其他 DomainParticipant（域参与者）。 机制：每个 DomainParticipant 周期性地广播自己的信息（包括唯一标识 GUID、IP 地址、端口等）。 数据：通过 SPDP（Simple Participant Discovery Protocol） 发送 SPDPdiscoveredParticipantData 数据，包含参与者的元信息。 方式：通常使用多播（Multicast）或单播（Unicast）发送到预定义的地址（如 RTPS 默认的多播地址 239.255.0.1）。 Endpoint Discovery Phase (EDP)： 目的：发现其他参与者的 DataWriter 和 DataReader（统称为端点）。 机制：在 PDP 完成后，参与者交换其 DataWriter 和 DataReader 的信息（如 Topic 名称、数据类型、QoS 设置等）。 数据：通过 SEDP（Simple Endpoint Discovery Protocol） 发送端点信息，例如 DiscoveredWriterData 和 DiscoveredReaderData。 匹配：DataWriter 和 DataReader 根据 Topic 名称、数据类型和 QoS 兼容性进行匹配。 发送 Discovery 的过程 在 DDS 中，发送 Discovery 数据的具体流程如下：\n启动 DomainParticipant： 当一个应用启动并创建一个 DomainParticipant 时，它会加入一个特定的 Domain（域 ID）。 参与者会自动初始化内置的 DataWriter 和 DataReader，用于发送和接收发现数据。 发送 SPDP 数据（参与者发现）： 参与者通过内置的 SPDP DataWriter 周期性地发送 SPDPdiscoveredParticipantData。 数据内容包括： 参与者的 GUID（全局唯一标识符）。 网络地址（IP 和端口）。 QoS 设置（如租约持续时间 LeaseDuration）。 发送方式： 默认使用多播地址（239.255.0.1，端口由 Domain ID 和 RTPS 规则确定）。 如果多播不可用，可以配置为单播。 频率：根据 QoS 中的 LeaseDuration 设置，周期性发送以保持“存活”状态。 发送 SEDP 数据（端点发现）： 一旦两个参与者通过 SPDP 发现彼此，它们会通过内置的 SEDP DataWriter 发送各自的端点信息。 数据内容包括： DataWriter 的信息：Topic 名称、数据类型、QoS、是否带 Key（例如 Writer with Key 的 entityKind 为 0x02 或 0xc2）。 DataReader 的信息：类似的元数据。 匹配过程：接收方根据 Topic、数据类型和 QoS 检查是否匹配，匹配成功后建立通信。 持续更新： 发现数据会定期发送，以处理动态加入或离开的参与者。 如果某个参与者停止发送发现数据（超过 LeaseDuration），其他参与者会认为它已离线。 QoS(Quality of Service) QoS（服务质量） 是 DDS 的核心特性，允许开发者通过配置参数控制数据通信的行为。DDS 定义了约 23 种 QoS 策略，适用于域参与者、主题、发布者、订阅者、DataWriter 和 DataReader。以下是主要 QoS 策略：\n可靠性（Reliability）：\nRELIABLE：保证数据可靠送达，类似 TCP，适用于关键数据。 BEST_EFFORT：尽力而为，类似 UDP，适用于对延迟敏感的场景。 持久性（Durability）：\nVOLATILE：数据不存储，适用于瞬时数据。 TRANSIENT/PERSISTENT：支持晚加入的订阅者获取历史数据。 延迟预算（Latency Budget）：定义数据传输的期望延迟。\n优先级（Transport Priority）：为重要数据分配更高优先级。\n寿命（Lifespan）：设置数据有效期，过期数据自动丢弃。\n历史（History）：控制保留的数据样本数量（如 KEEP_LAST 或 KEEP_ALL）。\n安全性（Security）：支持认证、加密和访问控制。\nQoS 提供细粒度的控制，开发者可根据应用需求（如实时性、可靠性、资源限制）优化通信行为。例如，自动驾驶系统可能要求低延迟和高可靠性，而日志系统可能优先持久性。\nIDL DDS 的数据格式基于接口定义语言（IDL），用于定义主题的数据结构, 有如下特点:\n类型安全：通过 IDL 定义强类型数据（如结构体、枚举、数组），确保发布者和订阅者使用一致的格式。 可扩展性：DDS-XTypes 支持动态类型，允许运行时修改数据结构。 内容过滤：订阅者可通过 QoS 设置内容过滤器，仅接收感兴趣的数据，减少带宽浪费。 序列化格式：使用 CDR 标准，支持跨平台传输，兼容 C++、Java、Python 等语言。 示例 IDL：\nstruct SensorData { long id; float temperature; float humidity; }; 此 IDL 定义了一个主题 SensorData，包含传感器 ID、温度和湿度字段，发布者将其序列化为字节流，订阅者反序列化后使用。\nSerialization 为什么需要序列化 序列化是将数据对象转换为字节流以便在网络上传输的过程。DDS 使用序列化来：\n统一数据表示：DDS 支持跨平台（不同操作系统、编程语言、硬件架构）通信，序列化确保数据以标准格式传输。 高效传输：序列化后的字节流紧凑，减少网络带宽占用。 数据类型支持：DDS 使用接口定义语言（IDL）定义数据结构，序列化确保复杂数据类型（如结构体、数组）正确传递。 如果不使用序列化，可能面临以下问题：\n跨平台不兼容：不同系统的内存布局（如字节序）不同，数据无法正确解析。 传输效率低：未序列化的数据可能包含冗余信息，增加带宽消耗。 数据完整性问题：没有标准格式，可能导致数据丢失或错误解析。 开发复杂性：开发者需手动处理数据格式转换，增加编码和调试难度。 DDS 通过 CDR（Common Data Representation） 标准进行序列化，支持高效、跨平台的传输。DDS-XTypes 扩展进一步定义了动态类型系统，允许运行时调整数据结构。\n序列化与压缩算法 todo\nRTPS entityKind Kind of Entity User-defined Entity Built-in Entity unknown 0x00 0xc0 Participant N/A 0xc1 Writer (with Key) 0x02 0xc2 Writer (no Key) 0x03 0xc3 Reader (no Key) 0x04 0xc4 Reader (with Key) 0x07 0xc7 Writer Group 0x08 0xc8 Reader Group 0x09 0xc9 Predefined EntityIds\nEntity Corresponding value for entityId_t (NAME = value) participant ENTITYID_PARTICIPANT = {{00,00,01},c1} SEDPbuiltinTopicWriter ENTITYID_SEDP_BUILTIN_TOPICS_ANNOUNCER ={{00,00,02},c2} SEDPbuiltinTopicReader ENTITYID_SEDP_BUILTIN_TOPICS_DETECTOR ={{00,00,02},c7} SEDPbuiltinPublicationsWriter ENTITYID_SEDP_BUILTIN_PUBLICATIONS_ANNOUNCER ={{00,00,03},c2} SEDPbuiltinPublicationsReader ENTITYID_SEDP_BUILTIN_PUBLICATIONS_DETECTOR ={{00,00,03},c7} SEDPbuiltinSubscriptionsWriter ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_ANNOUNCER ={{00,00,04},c2} SEDPbuiltinSubscriptionsReader ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_DETECTOR ={{00,00,04},c7} SPDPbuiltinParticipantWriter ENTITYID_SPDP_BUILTIN_PARTICIPANT_ANNOUNCER ={{00,01,00},c2} SPDPbuiltinParticipantReader ENTITYID_SPDP_BUILTIN_PARTICIPANT_DETECTOR ={{00,01,00},c7} BuiltinParticipantMessageWriter ENTITYID_P2P_BUILTIN_PARTICIPANT_MESSAGE_WRITER ={{00,02,00},c2} BuiltinParticipantMessageReader ENTITYID_P2P_BUILTIN_PARTICIPANT_MESSAGE_READER = {{00,02,00},c7} SubmessageId Type val function RTPS_HE 0x00 HeaderExtension PAD 0x01 Pad ACKNACK 0x06 AckNack HEARTBEAT 0x07 Heartbeat GAP 0x08 Gap INFO_TS 0x09 InfoTimestamp INFO_SRC 0x0c InfoSource INFO_REPLY_IP4 0x0d InfoReplyIp4 INFO_DST 0x0e InfoDestination INFO_REPLY 0x0f InfoReply NACK_FRAG 0x12 NackFrag HEARTBEAT_FRAG 0x13 HeartbeatFrag DATA 0x15 Data DATA_FRAG 0x16 DataFrag ParameterID Name ID Type PID_PAD 0x0000 N/A PID_SENTINEL 0x0001 N/A PID_USER_DATA 0x002c UserDataQosPolicy PID_TOPIC_NAME 0x0005 string\u0026lt;256\u0026gt; PID_TYPE_NAME 0x0007 string\u0026lt;256\u0026gt; PID_GROUP_DATA 0x002d GroupDataQosPolicy PID_TOPIC_DATA 0x002e TopicDataQosPolicy PID_DURABILITY 0x001d DurabilityQosPolicy PID_DURABILITY_SERVICE 0x001e DurabilityServiceQosPolicy PID_DEADLINE 0x0023 DeadlineQosPolicy PID_LATENCY_BUDGET 0x0027 LatencyBudgetQosPolicy PID_LIVELINESS 0x001b LivelinessQosPolicy PID_RELIABILITY 0x001a ReliabilityQosPolicy3 PID_LIFESPAN 0x002b LifespanQosPolicy PID_DESTINATION_ORDER 0x0025 DestinationOrderQosPolicy PID_HISTORY 0x0040 HistoryQosPolicy PID_RESOURCE_LIMITS 0x0041 ResourceLimitsQosPolicy PID_OWNERSHIP 0x001f OwnershipQosPolicy PID_OWNERSHIP_STRENGTH 0x0006 OwnershipStrengthQosPolicy PID_PRESENTATION 0x0021 PresentationQosPolicy PID_PARTITION 0x0029 PartitionQosPolicy PID_TIME_BASED_FILTER 0x0004 TimeBasedFilterQosPolicy PID_TRANSPORT_PRIORITY 0x0049 TransportPriorityQoSPolicy PID__DOMAIN_ID 0x000f DomainId_t PID_DOMAIN_TAG 0x4014 string\u0026lt;256\u0026gt; PID_PROTOCOL_VERSION 0x0015 ProtocolVersion_t PID_VENDORID 0x0016 VendorId_t PID_UNICAST_LOCATOR 0x002f Locator_t PID_MULTICAST_LOCATOR 0x0030 Locator_t PID_DEFAULT_UNICAST_LOCATOR 0x0031 Locator_t PID_DEFAULT_MULTICAST_LOCATOR 0x0048 Locator_t PID_METATRAFFIC_UNICAST_LOCATOR 0x0032 Locator_t PID_METATRAFFIC_MULTICAST_LOCATOR 0x0033 Locator_t PID_EXPECTS_INLINE_QOS 0x0043 boolean PID_PARTICIPANT_MANUAL_LIVELINESS_COUNT 0x0034 Count_t PID_PARTICIPANT_LEASE_DURATION 0x0002 Duration_t PID_CONTENT_FILTER_PROPERTY 0x0035 ContentFilterProperty_t PID_PARTICIPANT_GUID 0x0050 GUID_t PID_GROUP_GUID 0x0052 GUID_t PID_GROUP_ENTITY_ID 0x0053 EntityId_t PID_BUILTIN_ENDPOINT_SET 0x0058 BuiltinEndpointSet_t PID_BUILTIN_ENDPOINT_QOS 0x0077 BuiltinEndpointQos_t PID_PROPERTY_LIST 0x0059 sequence PID_TYPE_MAX_SIZE_SERIALIZED 0x0060 long PID_ENTITY_NAME 0x0062 EntityName_t PID_ENDPOINT_GUID 0x005a GUID_t 网络报文 tcp头部 数据偏移：数据部分往后偏移，这是TCP的头部长度字段，代表有多少个32bit，即1代表32bit，2代表64bit。 一共4位最大为15，15×32=480b=60B。所以头部最大为60个字节，最小为20字节。TCP头部的长度可以变化，因此可以承载更多的数据。\n注意这里必须使用32位的数据，用来快速定位数据部分的位置，所以没有那么多数据的话需要在后面进行填充\nudp头部 UDP最小长度：即无数据的情况下，仅首部长度8字节。 数据部分最小长度：即无数据的情况下，0字节。 UDP最大长度：因长度字段16位限制，所以最大长度为2(16)-1=65535字节。 数据部分最大长度：即UDP最大长度-IP最小头部-UDP头部，2(16)-1-20-8=65507字节 ip头部 总长度： 指整个数据报的长度（以字节为单位）。占16bit，最大长度为65535字节。\n协议：标识了上层所使用的协议\n01 ICMP 02 IGMP 06 TCP 17 UDP 88 IGRP 89 OSPF 数据链路层头部 最小帧：64字节，这是根据CSMA/CD的标准推导出。 帧头部：14字节，6字节目的地址+6字节源地址+2字节长度/类型=14字节。 帧中最小数据：64字节-6字节目的地址-6字节源地址-2字节长度/类型-4字节FCS字段(CRC)=**46字节**。 最大数据：即MTU=1500字节。 最大帧：MTU+帧头部14字节+FCS4字节=1518字节。 以上均未考虑前导码。 有效数据长度 链路层传输字段的最小长度是64,链路协议占了18,64-18=46，即为最小数据长度\nMTU的长度：\nTCP最大数据长度：1500-20-20 = 1460（ipv4） 1440（ipv6）\nUDP最大数据长度：1500-20-8 = 1472（ipv4） 1452（ipv6）\n参考资料 Fast DDS v3.2.2\neclipse-cyclonedds/cyclonedds\ncmake -G \u0026ldquo;Unix Makefiles\u0026rdquo; -DBUILD_EXAMPLES=ON ..\nomg/dds\nomg/DDSI-RTPS\n车载消息中间件FastDDS 源码解析（一）FastDDS 介绍和使用 c++版本源码分析\n","date":"2025年6月29日","img":"https://6668688.xyz/images/DDS/2025-07-03-22-24-27.png","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/dds/dds/","series":[{"title":"DDS 学习系列","url":"/series/dds-%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"}],"smallImg":"","tags":[{"title":"DDS","url":"/tags/dds/"}],"timestamp":1751206443,"title":"DDS"},{"authors":[],"categories":[],"content":"Welcome to my world\n","date":"2025年6月29日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/hello/","series":[],"smallImg":"","tags":[{"title":"Hello","url":"/tags/hello/"}],"timestamp":1751203462,"title":"Hello"},{"authors":[],"categories":[],"content":"我是谁，我从哪里来，我到哪里去.\n","date":"2025年6月28日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/about/","series":[],"smallImg":"","tags":[],"timestamp":1751068800,"title":"关于我"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/onlinetools/json/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":""},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/onlinetools/qrcode/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"二维码生成"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"联系我们"}]
