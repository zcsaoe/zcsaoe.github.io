<!doctype html><html class=position-relative itemscope itemtype=https://schema.org/WebPage lang=zh-hans data-bs-theme=auto><head><script src=/assets/init/bundle.min.397129316ebf5d0138f2a6eb945afea462097722c2aadea2126a46958286b68a.js integrity="sha256-OXEpMW6/XQE48qbrlFr+pGIJdyLCqt6iEmpGlYKGtoo=" crossorigin=anonymous></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Tc397中断子系统 -</title><link rel=icon href=/favicon_hu_34f9c9faf91b627e.webp sizes=16x16 type=image/webp><link rel=icon href=/favicon_hu_39d7e2e00a977bd3.webp sizes=32x32 type=image/webp><link rel=icon href=/favicon_hu_3b58e88b4b286a78.webp sizes=150x150 type=image/webp><link rel=apple-touch-icon href=/favicon_hu_3598ad0641f7f3c3.webp sizes=180x180 type=image/webp><link rel=icon href=/favicon_hu_144910b52c989e57.webp sizes=192x192 type=image/webp><link rel=mask-icon href=/safari-pinned-tab.svg color=#6f42c1><meta name=keywords content="Hugo,Bootstrap,博客主题"><meta name=description content="
Tc397中断子系统"><meta name=robots content="index, follow"><meta name=twitter:card content="summary"><meta name=twitter:title content="Tc397中断子系统"><meta name=twitter:description content="Tc397中断子系统"><meta property="og:url" content="https://6668688.xyz/docs/cpu/tricore/tc397_interrupt/"><meta property="og:title" content="Tc397中断子系统"><meta property="og:description" content="Tc397中断子系统"><meta property="og:locale" content="zh_hans"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-07-08T22:56:07+08:00"><meta property="article:modified_time" content="2025-07-10T19:43:35+08:00"><meta property="article:tag" content="Tc397中断"><meta property="article:tag" content="中断管理"><meta property="og:see_also" content="https://6668688.xyz/docs/cpu/tricore/tc397/"><meta itemprop=name content="Tc397中断子系统"><meta itemprop=description content="Tc397中断子系统"><meta itemprop=datePublished content="2025-07-08T22:56:07+08:00"><meta itemprop=dateModified content="2025-07-10T19:43:35+08:00"><meta itemprop=wordCount content="21020"><meta itemprop=keywords content="Tc397中断,中断管理"><meta property="og:image" content="https://6668688.xyz/images/Mascot.webp"><meta name=twitter:image content="https://6668688.xyz/images/Mascot.webp"><meta property="og:image:alt" content="Tc397中断子系统"><meta name=twitter:image:alt content="Tc397中断子系统"><link rel=manifest href=/manifest.json><script async src="https://www.googletagmanager.com/gtag/js?id=G-M4F16E8H84"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-M4F16E8H84")}</script><link data-precache rel=stylesheet href="/assets/main/bundle.min.b93db73c8bbe98c6809942bb244feed670579e9d57e867eb7aa839798656bd9c.css" integrity="sha256-uT23PIu+mMaAmUK7JE/u1nBXnp1X6Gfreqg5eYZWvZw=" crossorigin=anonymous><link data-precache rel=stylesheet href=/assets/viewer/bundle.min.16d2c85c4cae39a98f8cb7a977e95e554b174f91a5484c32605637156f49ca6b.css integrity="sha256-FtLIXEyuOamPjLepd+leVUsXT5GlSEwyYFY3FW9Jyms=" crossorigin=anonymous></head><body><header class="mb-4 sticky-top"><nav class="top-app-bar shadow navbar navbar-expand-xxl"><div class=container><button class="navbar-toggler border-0" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDocsNav aria-expanded=false aria-label="Toggle docs navigation">
<i class="fas fa-bars"></i>
</button>
<a class="navbar-brand d-flex align-items-center flex-grow-1 flex-xxl-grow-0 justify-content-xxl-start justify-content-center ms-2 ms-xxl-0 mx-auto me-xxl-2" href=https://6668688.xyz/><picture><img class=logo alt=Logo src="https://6668688.xyz/images/Mascot.webp?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=400 height=400></picture></a><div class="offcanvas-xxl offcanvas-end flex-grow-1" data-bs-scroll=true tabindex=-1 id=navbarMenus aria-labelledby=navbarMenusLabel><div class="offcanvas-header px-4 pb-0"><div class="offcanvas-title h5" id=navbarMenusLabel></div><button type=button class="btn-close btn-close-white" data-bs-dismiss=offcanvas data-bs-target=#navbarMenus aria-label=Close></button></div><div class="offcanvas-body p-4 pt-0 p-xxl-0"><hr class=d-xxl-none><ul class="navbar-nav flex-row flex-wrap align-items-center me-auto"><li class="nav-item col-6 col-xxl-auto"><a class="nav-link py-2 px-0 px-xxl-2" href=https://6668688.xyz/onlinetools/>Online Tools</a></li></ul><hr class=d-xxl-none><form class="search-bar ms-auto my-auto" action=/search/ novalidate><div class="input-group align-items-center"><span class="btn btn-search disabled position-absolute left-0 border-0 px-1"><i class="fas fa-fw fa-search fa-lg"></i>
</span><input class="my-1 form-control border-white rounded-5 search-input bg-body" name=q type=search placeholder=搜索 aria-label=Search required>
<span class="search-shortcut position-absolute end-0 top-0 me-2"><kbd class="text-dark bg-white opacity-75 rounded-3 shadow border border-primary py-1 fw-bold">/</kbd></span></div></form><hr class=d-xxl-none><ul class="navbar-nav flex-row flex-wrap align-items-center ms-md-auto"><li class="nav-item py-2 py-xxl-1 col-12 col-xxl-auto"><nav class="social-links nav justify-content-center flex-row"><a class="nav-link social-link col-6 col-xxl-auto p-1" target=_blank href=https://github.com/zcsaoe title=GitHub rel=me><i class="fa-fw fab fa-github"></i>
<span class="ms-1 d-xxl-none">Github</span></a></nav></li><li class="nav-item py-2 py-xxl-1 col-12 col-xxl-auto"><div class="vr d-none d-xxl-flex h-100 mx-xxl-2 text-white"></div><hr class="d-xxl-none my-2"></li><li class="nav-item dropdown py-1 py-xxl-1 col-6 col-xxl-auto"><a class="nav-link px-0 px-xxl-1" href=# id=languageDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-globe"></i>
<span class=d-xxl-none>语言</span></a><ul class="language-dropdown-menu dropdown-menu dropdown-menu-end" aria-labelledby=languageDropdown><li><a class=dropdown-item href=/en/>English</a></li><li><a class="dropdown-item active" href=/>简体中文</a></li></ul></li><li class="nav-item py-1 col-12 col-xxl-auto"><div class="vr d-none d-xxl-flex h-100 mx-xxl-2 text-white"></div><hr class="d-xxl-none my-2"></li><li class="nav-item dropdown col-6 col-xxl-auto"><a class="nav-link px-0 py-2 px-xxl-1" href=# id=fontSizeDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-font"></i>
<span class=d-xxl-none>字体大小</span></a><ul class="font-size-dropdown-menu dropdown-menu dropdown-menu-end" aria-labelledby=fontSizeDropdown><li><button class="font-size-item dropdown-item" data-size=xs>
特小号</button></li><li><button class="font-size-item dropdown-item" data-size=sm>
小号</button></li><li><button class="font-size-item dropdown-item active" data-size=md>
中等</button></li><li><button class="font-size-item dropdown-item" data-size=lg>
大号</button></li><li><button class="font-size-item dropdown-item" data-size=xl>
特大号</button></li></ul></li><li class="nav-item dropdown col-6 col-xxl-auto"><a class="nav-link px-0 py-2 px-xxl-1" href=# id=paletteDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-palette"></i>
<span class=d-xxl-none>配色</span></a><ul class="palette-dropdown-menu dropdown-menu dropdown-menu-end px-2 row g-2" aria-labelledby=paletteDropdown><li class="col-4 my-1"><a role=button id=palette-blue aria-label=蓝色 class="btn btn-sm w-100 palette text-bg-blue" data-palette=blue></a></li><li class="col-4 my-1"><a role=button id=palette-blue-gray aria-label=蓝灰色 class="btn btn-sm w-100 palette text-bg-blue-gray" data-palette=blue-gray></a></li><li class="col-4 my-1"><a role=button id=palette-brown aria-label=棕色 class="btn btn-sm w-100 palette text-bg-brown" data-palette=brown></a></li><li class="col-4 my-1"><a role=button id=palette-cyan aria-label=青色 class="btn btn-sm w-100 palette text-bg-cyan" data-palette=cyan></a></li><li class="col-4 my-1"><a role=button id=palette-green aria-label=绿色 class="btn btn-sm w-100 palette text-bg-green" data-palette=green></a></li><li class="col-4 my-1"><a role=button id=palette-indigo aria-label=靛青色 class="btn btn-sm w-100 palette text-bg-indigo" data-palette=indigo></a></li><li class="col-4 my-1"><a role=button id=palette-orange aria-label=橙色 class="btn btn-sm w-100 palette text-bg-orange" data-palette=orange></a></li><li class="col-4 my-1"><a role=button id=palette-pink aria-label=粉色 class="btn btn-sm w-100 palette text-bg-pink" data-palette=pink></a></li><li class="col-4 my-1"><a role=button id=palette-purple aria-label=紫色 class="btn btn-sm w-100 palette text-bg-purple" data-palette=purple></a></li><li class="col-4 my-1"><a role=button id=palette-red aria-label=红色 class="btn btn-sm w-100 palette text-bg-red" data-palette=red></a></li><li class="col-4 my-1"><a role=button id=palette-teal aria-label=蓝绿色 class="btn btn-sm w-100 palette text-bg-teal" data-palette=teal></a></li><li class="col-4 my-1"><a role=button id=palette-yellow aria-label=黄色 class="btn btn-sm w-100 palette text-bg-yellow" data-palette=yellow></a></li></ul></li><li class="nav-item dropdown col-6 col-xxl-auto"><a class="nav-link px-0 py-2 px-xxl-1" href=# id=modeDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="mode-icon fas fa-fw fa-adjust" id=modeIcon></i>
<span class=d-xxl-none>模式</span></a><ul class="mode-dropdown-menu dropdown-menu dropdown-menu-end" aria-labelledby=modeDropdown><li class=mode-item data-color-mode=light data-icon=sun><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-sun"></i> 浅色</button></li><li class=mode-item data-color-mode=dark data-icon=moon><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-moon"></i> 深色</button></li><li class="mode-item active" data-color-mode=auto data-icon=adjust><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-adjust"></i> 自动</button></li></ul></li></ul></div></div><div class=d-flex><button class="navbar-toggler order-5 border-0" type=button data-bs-toggle=offcanvas data-bs-target=#navbarMenus aria-controls=navbarMenus aria-expanded=false aria-label="Toggle navigation">
<i class="fas fa-ellipsis-h"></i></button></div></div></nav></header><main class="container has-sidebar" data-kind=page><script data-precache src=/js/main-init.fd48d66afb2d9a122b72b40b25ebae1b1338abcace96dbd4220b429bd5f5541d.js integrity="sha256-/UjWavstmhIrcrQLJeuuGxM4q8rOltvUIgtCm9X1VB0=" crossorigin=anonymous></script><div class="row content"><noscript><div class="alert alert-danger" role=alert>你的浏览器不支持 JavaScript。</div></noscript><aside class="docs-nav col-xxl-2" tabindex=-1 data-bs-hide=focusout><div class="offcanvas-xxl offcanvas-start" id=offcanvasDocsNav aria-labelledby=offcanvasDocsNavLabel><div class="offcanvas-header border-bottom"><div class="offcanvas-title h5" id=offcanvasDocsNavLabel>浏览文档</div><button type=button class=btn-close data-bs-dismiss=offcanvas aria-label=Close data-bs-target=#offcanvasDocsNav></button></div><div class="offcanvas-body pt-2 flex-column"><ul class="list-unstyled mb-2 w-100"><li class="mb-2 py-1" tabindex=-1><a class="docs-nav-link d-flex align-items-center" href=/docs/autosar/autosar/><span class=docs-nav-title>Autosar</span></a></li><li class="mb-2 py-1" tabindex=-1><a class="docs-nav-link d-flex align-items-center" href=/docs/cpu/arm/cortex-r/cortex-r52/cortex-r52/><span class=docs-nav-title>Cortex-R52</span></a></li><li class="mb-2 py-1" tabindex=-1><a class="docs-nav-link d-flex align-items-center" href=/docs/dds/dds/><span class=docs-nav-title>DDS</span></a></li><li class="mb-2 py-1" tabindex=-1><a class="docs-nav-link d-flex align-items-center" href=/docs/hello/><span class=docs-nav-title>Hello</span></a></li><li class="mb-2 py-1" tabindex=-1><a class="docs-nav-link d-flex align-items-center" href=/docs/cpu/arm/j6m/><span class=docs-nav-title>J6M</span></a></li><li class="mb-2 py-1" tabindex=-1><a class="docs-nav-link d-flex align-items-center" href=/docs/markdown/markdown/><span class=docs-nav-title>Markdown</span></a></li><li class="mb-2 py-1" tabindex=-1><a class="docs-nav-link d-flex align-items-center" href=/docs/cpu/tricore/tc397/><span class=docs-nav-title>Tc397</span></a></li><li class="mb-2 py-1 text-primary" tabindex=-1><a class="docs-nav-link d-flex align-items-center" href=/docs/cpu/tricore/tc397_interrupt/><span class=docs-nav-title>Tc397中断子系统</span></a></li><li class="mb-2 py-1" tabindex=-1><a class="docs-nav-link d-flex align-items-center" href=/docs/cpu/debug/trace32/><span class=docs-nav-title>TRACE32使用教程</span></a></li><li class="mb-2 py-1" tabindex=-1><a class="docs-nav-link d-flex align-items-center" href=/docs/investment/funds/><span class=docs-nav-title>货币基金</span></a></li><li class="mb-2 py-1" tabindex=-1><a class="docs-nav-link d-flex align-items-center" href=/docs/doraemon/><span class=docs-nav-title>懒人技术手册</span></a></li><li class="mb-2 py-1" tabindex=-1><a class="docs-nav-link d-flex align-items-center" href=/docs/linux/shell/terminalshortcutkeys/><span class=docs-nav-title>终端快捷键</span></a></li></ul></div></div></aside><div class="col ms-auto content-docs"><div class=container-fluid><nav class="row card component" aria-label=breadcrumb><div class="card-body pb-0"><ol class="hbs-breadcrumb breadcrumb flex-nowrap"><li class="breadcrumb-item text-surface"><a href=/>主页</a></li><li class="breadcrumb-item text-surface"><a href=/docs/>docs</a></li><li class="breadcrumb-item active">Tc397中断子系统</li></ol></div></nav><div class="post-panel-wrapper position-relative d-flex justify-content-center"><div class="d-flex flex-row justify-content-center rounded-5 border post-panel position-fixed px-3 py-1 surface shadow-1"><a class="action action-toc d-block d-xxl-none" href=#post-toc-container role=button title=目录><i class="fas fa-fw fa-list-alt"></i>
</a><a class="action action-copyright" href=#post-copyright role=button aria-label=Copyright title=版权><i class="fas fa-fw fa-copyright"></i>
</a><a class="action action-post-comments" href=#post-comments role=button aria-label=Comments title=评论><i class="fas fa-fw fa-comments"></i>
</a><a id=sidebarToggler class="action action-sidebar-toggler d-none d-xxl-block" role=button title=切换侧边栏><i class="fas fa-fw fa-expand-alt" data-fa-transform=rotate-45></i></a></div></div><article class="row card component mb-4 post"><div class=card-header><h1 class="card-title post-title my-2">Tc397中断子系统</h1></div><div class=card-body><div class="post-meta mb-3"><span class="post-date me-1 mb-1" title="创建于 2025-07-08 14:56:07 +0000 UTC，更新于 2025-07-10 11:43:35 +0000 UTC。">2025年7月8日</span><span class="post-reading-time me-1 mb-1">42 分钟阅读</span>
<span class="post-lastmod me-1 mb-1 text-muted">更新于 2025年7月10日
</span><a href=/categories/tricore%E4%B8%AD%E6%96%AD/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-category"><i class="fas fa-fw fa-folder me-1"></i>Tricore中断</a><a href=/series/tc397-%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-series">
<i class="fas fa-fw fa-columns me-1"></i>Tc397 架构系列</a><a href=/tags/tc397%E4%B8%AD%E6%96%AD/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-tag">Tc397中断</a><a href=/tags/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-tag">中断管理</a></div><div class="mt-2 mb-3 d-block d-xxl-none"><h2 class="text-surface mb-3">目录</h2><div id=post-toc-container></div><hr class=text-secondary></div><div class="post-content mb-3" data-bs-spy=scroll data-bs-target=#TableOfContents tabindex=0><div id=post-content-body><blockquote><p>Tc397中断子系统</p></blockquote><h1 id=3-通用寄存器和系统寄存器 data-numberify>3. 通用寄存器和系统寄存器<a class="anchor ms-1" href=#3-通用寄存器和系统寄存器></a></h1><p>核心寄存器有两种类型：通用寄存器（GPRs）和核心特殊功能寄存器（CSFRs）。GPRs包括16个通用数据寄存器和16个通用地址寄存器。CSFRs用于控制核心的操作并提供关于核心的状态信息。</p><ul><li>通用寄存器</li><li>系统寄存器（PSW，PC，PCXI）</li><li>栈管理寄存器（A[10] 和 ISP）</li><li>SYSCON和CPU_ID寄存器</li><li>陷阱寄存器 (Trap registers)</li><li>上下文管理寄存器</li><li>内存保护寄存器</li><li>内存管理寄存器</li><li>调试寄存器</li><li>浮点寄存器</li><li>与核心相关的特殊功能寄存器</li></ul><h2 id=复位值 data-numberify>复位值<a class="anchor ms-1" href=#复位值></a></h2><p>应注意，由于本手册描述的是TriCore®架构，而不是该架构的具体实现，因此某些复位值未给出。未提供的复位值是具体实现相关的。</p><h2 id=endinit保护 data-numberify>ENDINIT保护<a class="anchor ms-1" href=#endinit保护></a></h2><p>该架构支持在操作状态之前的初始化状态的概念。</p><p>在初始化状态下，所有核心特殊功能寄存器（CSFRs）都可以使用MTCR指令进行修改。在操作状态下，只有部分CSFRs可以通过这种方式修改。其他功能在这两种状态下保持相同。</p><p>在初始化状态下只能写入的CSFRs被描述为ENDINIT保护的。</p><p>初始化状态和操作状态之间的转换由系统实现控制。此功能通过仅允许在初始化状态下更改关键CSFRs，增加了额外的保护级别。</p><p>以下寄存器受ENDINIT保护：</p><ul><li>BTV, BIV, ISP, PMA0, PMA1, PMA2, PCON0, DCON0, SEGEN</li></ul><p>提供了一个专为安全设计的ENDINIT保护版本。以下寄存器受SAFETY_ENDINIT保护：</p><ul><li>SMACON, SYSCON, COMPAT, TPS_EXTIM_ENTRY_LVAL, TPS_EXTIM_EXIT_LVAL</li></ul><h1 id=4-任务和功能 data-numberify>4. 任务和功能<a class="anchor ms-1" href=#4-任务和功能></a></h1><p>大多数嵌入式和实时控制系统都是根据一个模型设计的，该模型中中断处理程序和软件管理的任务各自被视为在自己的“虚拟”微控制器上执行。这种模型通常由实时执行体或实时操作系统（RTOS）的服务支持，这些服务位于底层机器架构的特性和功能之上。</p><p>在TriCore™架构中，RTOS层可以非常“薄”，硬件可以高效地处理一个任务与另一个任务之间的切换。同时，该架构允许在所使用的任务模型中具有相当的灵活性。系统设计者可以选择最适合其应用需求的实时执行体和软件设计方法，架构施加的限制相对较少。</p><h1 id=5-中断系统 data-numberify>5. 中断系统<a class="anchor ms-1" href=#5-中断系统></a></h1><p>在TriCoreTM系统中，多个源（如外围设备或外部中断）可以向<strong>CPU或DMA通道</strong>等中断服务提供者发出中断请求。本章描述了CPU的中断处理能力，包括<strong>中断优先级方案</strong>和对<strong>向量表</strong>的访问。</p><h2 id=51-一般操作 data-numberify>5.1 一般操作<a class="anchor ms-1" href=#51-一般操作></a></h2><p>每个中断源都会被分配一个唯一的中断优先级编号，称为服务请求优先级编号（SRPN）。在接收到来自中断源的中断请求后，SRPN会被中断控制单元（ICU）用来在多个并发中断请求之间进行优先级排序。获胜请求的SRPN作为挂起中断优先级编号（PIPN）与请求触发一起传递给CPU。CPU通过将PIPN与当前CPU优先级编号（CCPN）进行比较，决定是否接受请求的中断。如果CPU决定接受请求的中断，它会以中断确认响应，并返回已接收中断的优先级编号。随后ICU将清除请求中断的源。</p><h3 id=511-icu中断控制寄存器icr data-numberify>5.1.1 ICU中断控制寄存器（ICR）<a class="anchor ms-1" href=#511-icu中断控制寄存器icr></a></h3><p>ICU中断控制寄存器（ICR）包含当前CPU优先级编号（CCPN）、全局中断启用/禁用位（IE）和当前挂起中断优先级编号（PIPN）。</p><h3 id=512-cpu对中断请求的操作 data-numberify>5.1.2 CPU对中断请求的操作<a class="anchor ms-1" href=#512-cpu对中断请求的操作></a></h3><p>CPU检查全局中断启用位ICR.IE的状态，并将当前CPU优先级编号ICR.CCPN与PIPN进行比较。只有当ICR.IE == 1并且PIPN大于CCPN时，CPU才会被中断。如果满足条件，CPU可以进入服务例程。PIPN用于确定中断向量表的入口点，并向ICU确认，ICU随后会向挂起的中断请求发送确认。</p><p>几种情况可能会阻止CPU立即响应由ICU生成的中断请求，这些情况包括：</p><ul><li>中断系统被全局禁用（ICR.IE == 0）。</li><li>当前CPU优先级（CCPN）等于或高于挂起中断优先级编号（PIPN）。</li><li>CPU正在进入中断或陷阱服务例程的过程中。</li><li>CPU正在执行不可中断的陷阱服务。</li><li>CPU正在执行多周期指令。</li><li>CPU正在执行修改ICR的指令。</li></ul><p>只有当这些条件不再成立时，CPU才会响应中断请求。</p><h3 id=513-进入中断服务例程isr data-numberify>5.1.3 进入中断服务例程（ISR）<a class="anchor ms-1" href=#513-进入中断服务例程isr></a></h3><p>当 CPU 满足所有条件来处理中断请求时，将执行以下操作以进入中断服务程序 (ISR)：：</p><ul><li>当前任务的上文被保存。</li><li>当前PC保存到返回地址（A[11]）中。</li><li>如果处理器之前没有使用中断栈（PSW.IS = 0），则A[10]栈指针会被设置为中断栈指针（ISP）。随后栈指针位被设置为使用中断栈：PSW.IS = 1。</li><li>I/O模式设置为Supervisor模式，这意味着所有权限被启用：PSW.IO = 10B。</li><li>当前的保护寄存器集被设置为0：PSW.PRS = 000B。</li><li>调用深度计数器（PSW.CDC）被清除，调用深度限制选择器被设置为64：PSW.CDC = 0000000B。</li><li>调用深度计数器已启用，PSW.CDE = 1。</li><li>PSW安全位设置为SYSCON寄存器中定义的值：PSW.S = SYSCON.IS。</li><li>禁止对全局寄存器A[0]、A[1]、A[8]、A[9]的写入权限：PSW.GW = 0。</li><li>中断系统被全局禁用：ICR.IE = 0。旧的ICR.IE被保存到PCXI.PIE中。</li><li>当前CPU优先级编号（ICR.CCPN）被保存到前一个CPU优先级编号（PCXI.PCPN）字段中。</li><li>挂起中断优先级编号（ICR.PIPN）被保存到当前CPU优先级编号（ICR.CCPN）字段中。</li><li>访问中断向量表以获取ISR的第一条指令。</li></ul><blockquote><p><strong>注意</strong> : 每当进入中断服务例程或陷阱处理程序时，都会禁用全局寄存器写入权限（PSW.GW == 0）。这确保所有陷阱和中断默认情况下都假设它们没有写入受PSW.GW控制的寄存器的权限。</p></blockquote><p>进入中断服务例程，中断系统全局禁用，当前 CPU 优先级 (CCPN) 设置为正在服务的中断的优先级 (PIPN)。用户需要自行再次启用中断系统，并可以选择修改优先级编号CCPN，以实现中断优先级级别或处理特殊情况。有关详细信息，请参见《使用TriCore中断系统》。</p><p>开启中断的方式如：</p><p>ENABLE指令，ENABLE将ICR.IE设置为1（中断系统启用）。</p><p>BISR（Begin Interrupt Service Routine）指令也会启用中断系统，将ICR.CCPN设置为新值，并保存被中断任务的下文。</p><p>MTCR（Move To Core Register）指令修改中断启用位（ICR.IE）和当前CPU优先级编号（ICR.CCPN）。</p><p>ENABLE、BISR和DISABLE（禁用中断）指令都是在 <strong>CPU完全执行完这些指令后才允许接受中断请求的</strong> 。这避免了流水线副作用，并消除了在这些指令之后使用ISYNC（同步指令流）的需要。<strong>MTCR是个例外，必须在之后跟随ISYNC指令。</strong></p><h2 id=52-退出中断服务例程isr data-numberify>5.2 退出中断服务例程（ISR）<a class="anchor ms-1" href=#52-退出中断服务例程isr></a></h2><p>当ISR通过RFE（Return From Exception）指令退出时，硬件会自动恢复上文。上文包括保存前一个CPU优先级编号（PCXI.PCPN）和前一个全局中断启用位（PCXI.PIE）。这些相应位中的值将如下使用：</p><ul><li>将PCXI.PCPN写入ICR.CCPN，以将CPU优先级编号恢复为中断前的值。</li><li>将PCXI.PIE写入ICR.IE，以恢复该位的状态。</li></ul><p>被中断的例程随后将继续执行。</p><h2 id=53-中断向量表 data-numberify>5.3 中断向量表<a class="anchor ms-1" href=#53-中断向量表></a></h2><p>中断服务例程（ISR）通过中断向量表与特定优先级的中断关联。中断向量表是中断服务例程（ISR）入口点的数组。中断向量表存储在内存中。</p><p>当CPU响应中断时，它会计算一个中断向量表中的地址，该地址与中断的优先级（ICR.PIPN位字段）相对应。此地址被加载到PC中，CPU开始执行此地址的指令。此地址的代码是所选中断服务例程（ISR）的起始部分。根据ISR的代码大小，中断向量表可能只存储ISR的初始部分，例如将CPU引导到ISR其余部分的跳转指令，这些部分可能存储在内存的其他地方。</p><p><strong>中断向量表基地址寄存器</strong> （BIV）存储中断向量表的基地址。中断向量在表中按优先级递增的顺序排列。在启用中断之前进行, BIV寄存器可以在系统初始化阶段使用MTCR指令进行修改（BIV受ENDINIT保护）。通过这种方式，可以使用多个中断向量表，并通过更改BIV寄存器的内容在它们之间切换。</p><p>当发生中断时，CPU从ICU.PIPN和BIV寄存器的计算出相应中断服务例程的入口点。有 <strong>两种向量表配置可用，向量之间的间隔分别为32字节或8字节</strong> 。间隔由BIV寄存器的向量大小选择（BIV.VSS）位选择。</p><p>为了生成中断向量表中的指针，PIPN向左移位五位（VSS=0）或三位（VSS=1），然后与BIV寄存器中的地址进行“或”运算，以生成指向中断向量表的指针。ISR的执行从这个地址开始。由于这种操作，建议BIV寄存器的[14:5]位（VSS=0）或[12:3]位（VSS=1）设置为0。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=ln>1</span><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>BIV</span><span class=p>.</span><span class=n>VSS</span> <span class=o>==</span> <span class=mi>1</span><span class=err>’</span><span class=n>b0</span><span class=p>)</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>    <span class=n>ISR_Entry_PC</span> <span class=o>=</span> <span class=p>{</span><span class=n>BIV</span><span class=p>[</span><span class=mi>31</span><span class=o>:</span><span class=mi>1</span><span class=p>],</span><span class=mi>1</span><span class=err>’</span><span class=n>b0</span><span class=p>}</span> <span class=o>|</span> <span class=p>{</span><span class=n>PIPN</span><span class=o>&lt;&lt;</span><span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    <span class=n>ISR_Entry_PC</span> <span class=o>=</span> <span class=p>{</span><span class=n>BIV</span><span class=p>[</span><span class=mi>31</span><span class=o>:</span><span class=mi>1</span><span class=p>],</span><span class=mi>1</span><span class=err>’</span><span class=n>b0</span><span class=p>}</span> <span class=o>|</span> <span class=p>{</span><span class=n>PIPN</span><span class=o>&lt;&lt;</span><span class=mi>3</span><span class=p>};</span>
</span></span></code></pre></div><p>如果一个中断处理程序非常短，它可能完全适合在向量代码段中提供的指令字内。否则，存储在入口位置的代码可以跨越多个向量条目，或者包含一些初始指令，然后跳转到处理程序的其余部分。有关跨越向量条目的中断服务例程的详细信息，请参见“跨越向量条目的中断服务例程”。</p><p><picture><img class=img-fluid alt=YjFiYzM2Nzc5M src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/YjFiYzM2Nzc5M.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1049 height=960></picture></p><p>BIV寄存器允许中断向量表位于可用代码内存的任何位置。上电时的默认值取决于具体的实现。可以在系统初始化阶段使用MTCR指令写入BIV寄存器，这通常是在启用中断之前进行。还可以通过修改BIV寄存器的内容，实现多个中断向量表之间的切换。</p><h2 id=54-使用tricore中断系统 data-numberify>5.4 使用TriCore中断系统<a class="anchor ms-1" href=#54-使用tricore中断系统></a></h2><p>以下部分包含一些示例，展示了如何使用TriCore架构灵活的中断系统来解决典型和特殊应用的需求。</p><h4 id=541-跨向量条目扩展中断服务例程isrs data-numberify>5.4.1 跨向量条目扩展中断服务例程（ISRs）<a class="anchor ms-1" href=#541-跨向量条目扩展中断服务例程isrs></a></h4><p>由于向量条目并未与中断源直接绑定，因此很容易跨越多个向量条目位置来扩展中断服务例程，如之前图22所示。如果中断处理程序的剩余部分无法容纳在入口位置之间的八个字内，则扩展可消除跳转到中断处理程序剩余部分的需要。。</p><p>要注意的是，与跨越服务例程相关的条目所对应的优先级号，不能用于请求同一服务提供者服务的活动服务请求节点（SRNs）。</p><p>在图22中，向量位置三和四被第二条目的服务例程覆盖。因此，这些优先级号不能分配给请求CPU服务的SRNs，虽然它们可以用于请求其他服务提供者。接下来的可用向量条目是条目五。</p><p>使用这种技术会增加系统中所需的优先级号码范围，但需要相应调整向量表的大小。</p><h4 id=542-中断优先级组 data-numberify>5.4.2 中断优先级组<a class="anchor ms-1" href=#542-中断优先级组></a></h4><p>中断优先级组描述了一组中断，这些中断的服务例程不能相互中断。这些组可以通过TriCore中断系统架构轻松创建。</p><p>当CPU开始服务某个中断时，中断系统会全局禁用，并且CPU优先级CCPN设置为正在服务的中断的优先级。这将阻止所有对其他中断的处理，直到通过软件重新启用中断系统，或通过RFE（异常返回）指令终止服务例程。</p><blockquote><p>注意： <strong>RFE指令会自动恢复ICR.IE位的先前状态。这将是1（ICR.IE = 1），否则该中断就不会被处理</strong> 。</p></blockquote><p>当中断服务例程（ISR）软件在不改变CCPN的情况下重新开启中断（设置ICR.IE），其效果是，所有优先级等于或低于CCPN的中断请求仍然被阻止服务。这包括当前中断的再次发生；即它不能中断此服务。</p><p>然而，具有比CCPN更高优先级号码的每个请求都会中断此ISR。一个潜在的问题（在TriCore架构中可以轻松克服）是，应用程序需求通常要求相似重要性的中断请求被分组在一起，使得该组中的任何请求都不能中断同组其他成员的ISR。</p><p>在中断系统中创建这些中断优先级组非常容易。对于定义的一组中断请求，其相应服务例程的软件在再次启用中断系统之前，将CCPN设置为该组中使用的最高SRPN的号码。如图23所示。</p><p><picture><img class=img-fluid alt=OTIxYmQxOTQ4O src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/OTIxYmQxOTQ4O.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1588 height=971></picture></p><p>优先级号为11和12的中断请求构成一个组，而优先级号为14到17（包括14和17）的中断请求构成另一个组。每次在处理第一个组中的一个中断时，服务例程会将CCPN设置为该组中的最高优先级号12，然后再重新启用中断系统。每次处理第二个组中的一个中断时，服务例程会将CCPN设置为17，然后再重新启用中断系统。例如，如果处理了中断14，它只能被优先级高于17的请求中断，而不会被来自其自身优先级组的请求或优先级较低的请求中断。</p><p>可以看出该系统的灵活性及其优于固定优先级系统的地方。在上述示例中，优先级号为13的中断请求形成了一个单独的“组”。 <strong>在每个服务例程中将CCPN设置为最大值255的效果与不重新启用中断系统的效果相同</strong> ；即所有中断请求都可以被视为属于同一个组。</p><p>中断优先级水平的灵活性范围从所有中断在一个组内，到每个中断请求形成自己的组，以及所有介于两者之间的可能组合。</p><h4 id=543-将isr分为不同的优先级 data-numberify>5.4.3 将ISR分为不同的优先级<a class="anchor ms-1" href=#543-将isr分为不同的优先级></a></h4><p><strong>中断服务例程（ISR）可以很容易地分为不同优先级的部分</strong> 。例如，一个中断被设置为非常高的优先级，因为对事件的响应时间和反应非常关键，但该服务例程中的进一步操作可以在较低优先级上运行。在这种情况下，服务例程将被分为两个部分，一部分包含关键操作，另一部分包含较不关键的操作。</p><p>首先将中断节点的优先级设置为高优先级，以便当中断发生时，立即执行必要的操作。然后将该中断的优先级降低，并在仍处于服务例程中时通过软件再次设置中断请求位（表示有待处理的中断）。返回被中断的程序将终止高优先级的服务例程。当CPU的优先级低于挂起中断的优先级时，该待处理中断将被服务。进入服务例程后（此时服务例程在程序存储器的不同地址），执行剩余的低优先级中断操作。</p><p>在其他情况下，服务请求的优先级可能较低，因为对事件的响应时间并不关键，但一旦获得服务则不应被中断。为了防止任何中断，TriCore架构允许在ISR内提高服务请求的优先级，并且允许完全禁用中断。</p><blockquote><p>即对于同一个isr，进入中断handler前后设置不同的优先级</p></blockquote><h3 id=544-使用不同的优先级处理相同的中断源 data-numberify>5.4.4 使用不同的优先级处理相同的中断源<a class="anchor ms-1" href=#544-使用不同的优先级处理相同的中断源></a></h3><p>对于某些应用程序，中断请求的优先级相对于其他请求并不是固定的，而是取决于系统的当前情况。这可以通过在不同时间为中断源分配不同的服务请求优先级号码（SRPNs）来实现，以满足应用程序的需求。通常，针对该中断的ISR会根据优先级执行不同的代码。</p><p>在传统的中断系统中，ISR必须检查当前中断请求的优先级，并根据优先级执行适当的代码部分，这可能导致对请求的响应延迟。然而，在TriCore系统中，中断会自动为不同的优先级提供不同的向量条目。因此，不需要在ISR中进行额外的检查和跳转，从而减少了中断延迟。</p><p>如果ISR与中断的优先级无关，则需要在该中断的每个向量条目上跳转到通用ISR代码。</p><blockquote><p>为一个中断使用不同优先级号码时，在创建向量表时需要考虑这一点。</p></blockquote><h3 id=545-中断控制寄存器 data-numberify>5.4.5 中断控制寄存器<a class="anchor ms-1" href=#545-中断控制寄存器></a></h3><h4 id=icr-icu-interrupt-control-register--中断控制寄存器 data-numberify>ICR： ICU Interrupt Control Register 中断控制寄存器<a class="anchor ms-1" href=#icr-icu-interrupt-control-register--中断控制寄存器></a></h4><p>ICR.PIPN [23:16] : 挂起的中断优先级号</p><p>0：无效，1：最低，0xff:最高</p><p>ICR.IE [15] : 中断系统使能/禁用位</p><p>ICR.CCPN [7:0] : 当前 CPU 优先级号</p><h4 id=biv-base-interrupt-vector-table-pointer--基本中断向量表指针 data-numberify>BIV： Base Interrupt Vector Table Pointer 基本中断向量表指针<a class="anchor ms-1" href=#biv-base-interrupt-vector-table-pointer--基本中断向量表指针></a></h4><p>ICR.BIV [31:1] : 中断向量表的基地址</p><p>ICR.VSS [0] : 向量间距选择</p><p>0 -> 32byte, 1 -> 8byte</p><h1 id=16-中断路由器-interrupt-router-ir data-numberify>16. 中断路由器 (Interrupt Router, IR)<a class="anchor ms-1" href=#16-中断路由器-interrupt-router-ir></a></h1><p>本章描述了中断路由器模块，该模块将来自外部资源、内部资源和软件的中断（在此称为 <strong>服务请求</strong> ）调度到CPU和DMA模块（在此称为 <strong>服务提供者</strong> ）。</p><h2 id=本文档的范围 data-numberify>本文档的范围<a class="anchor ms-1" href=#本文档的范围></a></h2><p>本文档适用于TC3xx，并涵盖以下主题：</p><ul><li>中断系统架构</li><li>中断系统配置</li><li>中断路由器操作</li></ul><h2 id=161-功能列表 data-numberify>16.1 功能列表<a class="anchor ms-1" href=#161-功能列表></a></h2><p>以下列表显示了中断路由器模块的主要功能：</p><ul><li>支持最多<strong>1024个服务请求</strong>的中断系统</li><li>每个ICU1) / 服务提供者支持多达<strong>255个服务请求优先级别</strong></li><li>支持多达 <strong>8个ICU / 服务提供者 （</strong> 397有只有7个**）**</li><li>每个实现的CPU / DMA模块（服务提供者）都有一个专用ICU</li><li><strong>低延迟仲裁</strong> - 从接收到服务请求到发送给服务提供者，耗时仅为三到四个时钟周期</li><li>每个外设中断都有一个专用的服务请求节点（SRN）</li><li>每个SRN都有一个可编程的8位优先级向量</li><li>每个SRN可以映射到一个已实现的ICU / 服务提供者</li><li>当配置的服务提供者确认中断时，SRN将由硬件自动清除</li><li>支持完整性保护的中断系统</li><li>每个CPU有8个通用服务请求（GPSR），可用作软件中断（不分配给外设或外部中断）</li><li>服务请求广播寄存器（SRB），可同时向多个服务提供者发出通用服务请求（软件中断）</li><li>服务请求的优先级依赖屏蔽（针对CPU，相关控制寄存器包含在CPU中）</li><li>具有滤波模式和触发模式（如下降沿、上升沿、高电平或低电平）的外部中断。模式可在运行时配置3)</li><li>CPU唤醒支持（当CPUx处于IDLE状态时，将服务请求信号发送至SCU以唤醒CPUx）</li></ul><h2 id=162-与tc2xx的差异 data-numberify>16.2 与TC2xx的差异<a class="anchor ms-1" href=#162-与tc2xx的差异></a></h2><p>以下功能变化是从Aurix到TC3xx引入的：</p><ul><li>通用服务请求组：每组服务请求节点的数量从4个变更为8个SRN（详见 16.7 “通用服务请求，服务请求广播”）</li><li>广播寄存器：广播寄存器的位图已适应新的GPSR SRN数量（详见 16.7 “通用服务请求，服务请求广播”）。</li><li>广播寄存器：每个广播寄存器现在都有一个专用的ACCEN寄存器（详见 16.7.3 “SRBx寄存器的访问保护（ACCEN_SRBx）”）。</li><li>SRCx：引入了SRCx[31:0]的访问保护（每个实现的TOS编码/ICU都有一个ACCEN寄存器，详见 16.4.1.3 “SRC寄存器的保护”）。</li><li>SRC.ECC：ECC位字段的大小从6位更改为5位（详见 16.4.1.1 “通用服务请求控制寄存器格式”）。</li><li>SRC.TOS：TOS位字段的大小更改为3位（详见 16.4.1.1 “通用服务请求控制寄存器格式”）。</li><li>SRC偏移和索引编号方案更改：SRC被映射到1024 * 32位范围内。索引编号（0-1023）等于SRC的32位偏移量（详见 16.4.1.1 “通用服务请求控制寄存器格式”）。</li><li>检测到信号到保留TOS的服务请求时，会向SMU发出警报。</li><li>SRC寄存器映射到IR地址映射已重新设计。</li></ul><h2 id=163-概述 data-numberify>16.3 概述<a class="anchor ms-1" href=#163-概述></a></h2><p><strong>中断请求可以由CPU或DMA模块服务</strong> 。本文档中使用“服务请求”而非“中断请求”，因为它们可以由任一服务提供者服务。</p><p>中断系统在中断路由器模块中实现，该模块包括服务请求节点（SRNs : Service Request Nodes ）、中断控制单元（ICU : Interrupt Control Units ）以及支持软件开发的附加功能。</p><p>如图173所示，每个能够生成服务请求的模块都连接到中央中断路由器模块中的一个或多个服务请求节点（SRN）。中断路由器模块还包括多个通用服务请求节点（SRN），这些节点可用于软件（SW）触发的服务请求。</p><p>每个SRN包含一个服务请求控制寄存器（SRC），用于配置服务请求，例如优先级、映射到一个可用的服务提供者。</p><p>每个SRN连接到中断路由器模块中的所有ICU，在那里，SRN的控制寄存器设置定义了目标服务提供者和服务请求的优先级。</p><p>每个ICU处理来自映射到该ICU的SRN的竞争服务请求之间的中断仲裁。</p><p>每个ICU连接到一个服务提供者（CPU或DMA模块），在仲裁轮中，ICU向服务提供者提供有效的获胜服务请求/SRN，并且服务提供者在处理服务请求时向ICU发回信号。</p><p><picture><img class=img-fluid alt=ZDdlOGFiNDQ5N src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/ZDdlOGFiNDQ5N.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1340 height=1082></picture></p><h2 id=164-服务请求节点-srn data-numberify>16.4 服务请求节点 (SRN)<a class="anchor ms-1" href=#164-服务请求节点-srn></a></h2><p>中断路由器模块中的每个服务请求节点（SRN）包含一个服务请求控制（SRC）寄存器和接口逻辑，该接口逻辑将其连接到中断路由器模块外部的触发单元以及中断路由器内部的中断仲裁总线（参见图173）。</p><h4 id=1641-服务请求控制寄存器 data-numberify>16.4.1 服务请求控制寄存器<a class="anchor ms-1" href=#1641-服务请求控制寄存器></a></h4><p>中断路由器模块中的所有服务请求控制寄存器格式相同。通常，这些寄存器包含以下信息：</p><ul><li>启用/禁用信息（SRE，第9页）</li><li>服务请求设置位和服务请求清除位（SETR，CLRR，第9页）</li><li>软件粘滞位（SWS），用于指示软件发起的服务请求（SWS，第12页）</li><li>服务请求优先级向量（SRPN，第10页）</li><li>服务请求目标/服务提供者（TOS，第9页）</li><li>服务请求状态位（SRR，第9页）</li><li>向安全管理单元（SMU）信号完整性错误（第11页）</li><li>中断溢出位（IOV，第11页）</li></ul><p>除了可以通过硬件由相关的触发单元激活外，每个SRN还可以通过软件通过两个软件发起的服务请求控制位进行设置或重置。</p><h5 id=16411-通用服务请求控制寄存器格式 data-numberify>16.4.1.1 通用服务请求控制寄存器格式<a class="anchor ms-1" href=#16411-通用服务请求控制寄存器格式></a></h5><h6 id=164111-服务请求控制寄存器src--service-request-control-register- data-numberify>16.4.1.1.1 服务请求控制寄存器（SRC ： Service Request Control Register ）<a class="anchor ms-1" href=#164111-服务请求控制寄存器src--service-request-control-register-></a></h6><p>本章描述了服务请求控制寄存器（SRC）的特性。</p><p>请注意：一些模块在模块级别有额外的中断相关控制寄存器（例如，中断状态、设置清除或启用寄存器）。这些模块寄存器在相应模块章节中描述。</p><p>服务请求控制寄存器 i ，SRCi (i=0-1023)，(00000H + i*4)</p><p>SRC.SRPN [7:0] : 服务请求优先级</p><p>0：最低，0xff：最高；cpu的最小值为1，dma最小值0</p><p>SRC.SRE [10] : 服务请求使能/禁用位</p><p>SRC.TOS [13:11] : 服务请求类型</p><p>0：cpu0，1：DMA，2-6：cpu1-5</p><p>SRC.ECC [20:16] : 错误纠正码</p><p>SRC.SRR [24] : 服务请求挂起标志位</p><p>SRC.CLRR [25] : clear SRR 清楚服务挂起位</p><p>SRC.SETR [26] : set SRR 设置服务器请求位</p><p>SRC.IOV [27] : hw中断触发溢出标志位</p><p>SRC.IOVCLR [28] : clear IOV</p><p>SRC.SWS [29] : 软件中断标志位</p><p>SRC.SWSCLR [30] : clear SWS</p><h5 id=16412-更改srn配置 data-numberify>16.4.1.2 更改SRN配置<a class="anchor ms-1" href=#16412-更改srn配置></a></h5><p>默认情况下，所有服务请求节点（SRN）均被禁用。要使用服务请求节点，必须通过将SRC.SRE位设置为 <code>1</code>来配置并启用它。</p><p>服务请求节点可以针对中断服务提供者目标（SRC.TOS）和服务请求优先级编号（SRC.SRPN）进行配置。启用SRN后，可以通过以下步骤更改TOS和/或SRPN位字段：</p><ol><li>禁用SRN（设置SRC.SRE= <code>0</code>）。</li><li>检查SRN是否已禁用（读回SRC.SRE并检查SRE= <code>0</code>）。</li><li>检查寄存器LWSRx（最后的获胜服务请求，读取/轮询LWSRx，参见下述说明）：<ol><li>如果LWSRx.STAT= <code>0</code>或LWSRx.SRPN或LWSRx.ECC不再等于旧的SRC值，则继续进行下一步（更改SRC值）。</li><li>如果LWSRx.STAT= <code>1</code>且LWSRx.SRPN和LWSRx.ECC等于（旧的）SRC值，则再次检查LWSRx。</li></ol></li><li>更改SRC.TOS和/或SRC.SRPN位字段。</li><li>启用SRN（SRC.SRE= <code>1</code>，写入SRC.SRE）。</li></ol><p>如果需要重新配置的服务请求在禁用时处于挂起状态，可能该服务请求已被仲裁并提供给中断服务提供者（CPU或DMA）。在这种情况下，应延迟启用重新配置的SRN，直到上述LWSRx轮询算法完成，以确保刚禁用的SRN配置不再存在于中断系统中。如果禁用的服务请求节点映射到TriCore，读取/轮询序列的时间是非确定性的。如果ISP是DMA模块，则进入和确认在同一周期内发出。LWSRx中的 <code>x</code>表示需要检查与TOS设置相关的LWSR寄存器（TOS=0 -> LWSR0，TOS=1 -> LWSR1，&mldr;）。</p><h5 id=16413-src寄存器的保护 data-numberify>16.4.1.3 SRC寄存器的保护<a class="anchor ms-1" href=#16413-src寄存器的保护></a></h5><p>SRC寄存器通过片上总线主控TAG-ID保护（详见第16.8.1章）进行写保护。此保护由中断路由器控制寄存器ACCEN_CONFIG和ACCEN_TOSx控制。</p><ul><li>SRC[31:16]：受ACCEN_TOSx（x = SRC.TOS）写保护。</li><li>SRC[15:0]：受ACCEN_CONFIG写保护。</li></ul><p>将SRC写保护划分为SRC[31:16]和SRC[15:0]的不同写保护寄存器，允许为所有服务请求节点的配置（通常在运行时是静态的）和在运行时由相关软件任务作为正常应用程序一部分使用的服务请求节点控制寄存器定义不同的保护配置（例如软件中断）。</p><p><strong>对SRC[31:16]进行写访问时发生访问保护违规</strong></p><p>当使用32位数据访问写入SRC寄存器时，仅更新未发生ACCEN保护违规的SRC寄存器部分：</p><ul><li>对SRC[31:16]（ACCEN_TOSx）和SRC[15:0]（ACCEN_CONFIG）的违规</li><li>不更新SRC寄存器，向SMU发送警报。</li><li>对SRC[31:16]（ACCEN_TOSx）的违规：</li><li>不更新SRC[31:16]，更新SRC[15:0]，向SMU发送警报。</li><li>对SRC[15:0]（ACCEN_CONFIG）的违规：</li><li>更新SRC[31:16]，不更新SRC[15:0]，向SMU发送警报。</li></ul><p><strong>SRC配置的访问保护（SRC[15:0]）</strong></p><p>所有SRC寄存器的下半部分SRCx[15:0]通过ACCEN_CONFIG寄存器进行写保护。这意味着，ACCEN_CONFIG的配置定义了哪些TAG ID被允许写入所有已实现的SRC寄存器的下半部分。需要注意的是，对SRC.TOS、SRC.SRE、SRC.SRPN（均映射在SRC[15:0]）的修改也会间接修改SRC.ECC位字段。</p><p><strong>背景 / 用例（ACCEN_CONFIG保护的SRC[15:0]）</strong></p><p>SRCx[15:0]包括服务请求节点的配置位/位字段，通常：</p><ul><li>在启动期间配置</li><li>在运行时是静态的</li><li>不应由非安全软件任务修改</li></ul><p>ACCEN_CONFIG允许配置仅特定的TAG ID可以重新配置SRC配置，例如CPUx.DMI安全TAG ID。</p><p><strong>SRC控制位的访问保护（SRC[31:16]）</strong></p><p>SRC寄存器的上半部分SRC[31:16]通过一个ACCEN_SRC_TOSx寄存器进行写保护。保护SRN的ACCEN_SRC_TOSx寄存器由SRN的SRC.TOS配置选择：</p><ul><li>SRCx.TOS = 0 -> SRC寄存器通过ACCEN_SRC_TOS0进行写保护</li><li>SRCx.TOS = 1 -> SRC寄存器通过ACCEN_SRC_TOS1进行写保护</li><li>SRCx.TOS = 2 -> SRC寄存器通过ACCEN_SRC_TOS2进行写保护</li><li>&mldr;</li></ul><blockquote><p>对于“保留”TOS编码，没有实现ACCEN_SRC_TOSx寄存器。这意味着，对于配置了保留TOS编码的SRCy，SRCy始终可以写入。服务请求到未实现的ISP（SRC.TOS=保留）将作为警报发送到SMU。</p></blockquote><p><strong>背景 / 用例（ACCEN_SRC_TOSx保护的SRC[31:16]）</strong></p><p>SRCx[31:16]包括服务请求节点的控制位/位字段，可用于在运行时：</p><ul><li>设置服务请求（软件中断）</li><li>清除服务请求</li><li>清除中断溢出或粘滞位</li><li>通过SRC.ECC位字段注入ECC错误</li></ul><p>如果没有这个机制，任何CPU任务和任何具有主功能的片上总线IP都可以生成对任何CPU的SW中断和/或清除任何中断。该机制使系统能够以“每CPU”为粒度封装软件任务，并限制不正确软件的副作用仅影响执行该软件的CPU。</p><p>例如：所有映射到CPU0的SRNs（TOS=0）都通过ACCEN_SRC_TOS0进行写保护。这意味着，通过ACCEN_SRC_TOS0的配置，定义了哪些TAG ID被允许向CPU0设置或清除服务请求。ACCEN_SRC_TOS0可以配置为仅允许CPU0任务向CPU0设置软件中断。这确保了任何其他CPU或DMA通道上的损坏软件不会通过永久软件中断影响CPU0。</p><blockquote><p>在这种情况下，如果发生访问保护错误，写入操作将被静默忽略，并向SMU发送错误信号。除向SMU发出信号外，不会生成其他错误、中断或陷阱。</p></blockquote><h5 id=16414-请求设置和清除位setrclrr data-numberify>16.4.1.4 请求设置和清除位（SETR，CLRR）<a class="anchor ms-1" href=#16414-请求设置和清除位setrclrr></a></h5><ul><li>SETR位：写入1会将SRR位设置为1。</li><li>CLRR位：写入1会将SRR位清除为0。</li><li>同时写入1到SETR和CLRR时，SRR位不会改变。</li><li>写入SETR或CLRR的值不会被存储。</li><li>写入0对这些位没有影响。</li><li>读取这些位时总是返回0。</li></ul><h5 id=16415-使能位sre data-numberify>16.4.1.5 使能位（SRE）<a class="anchor ms-1" href=#16415-使能位sre></a></h5><p>SRE位允许中断参与选定服务提供者的仲裁。它不会启用或禁用请求标志SRR的设置；请求标志可以通过硬件或软件（通过SETR）独立于SRE位的状态进行设置。这使得服务请求可以通过硬件自动处理或通过软件轮询处理。</p><ul><li>SRE = 1：
如果SRE = 1，待处理的服务请求将传递给指定的服务提供者进行中断仲裁。当服务请求被服务提供者确认时，硬件会自动将SRR位重置为0。在这种情况下，建议软件不要修改SRR位，以避免由于硬件控制该位导致的意外行为。</li><li>SRE = 0：
如果SRE = 0，待处理的服务请求不会传递给服务提供者。软件可以轮询SRR位以检查是否有服务请求待处理。要确认服务请求，SRR位必须通过软件写入1到CLRR来重置。</li></ul><blockquote><p>在本文档中，“active source”指的是其请求使能位SRE设置为1，以允许其服务请求参与中断仲裁的SRN。</p></blockquote><h5 id=16416-服务请求标志srr data-numberify>16.4.1.6 服务请求标志（SRR）<a class="anchor ms-1" href=#16416-服务请求标志srr></a></h5><ul><li>当设置时，SRR标志表示有一个服务请求待处理。它可以通过硬件直接设置或重置，或通过软件使用SETR和CLRR位间接设置或重置。通过软件直接写入该位没有效果。</li><li>SRR可以由硬件或软件设置或清除，无论SRE位的状态如何。然而，只有当SRE位设置为1时，请求才会被转发进行服务。如果SRE = 1，待处理的服务请求将参与设备TOS位字段选择的服务提供者的中断仲裁。如果SRE = 0，待处理的服务请求将被排除在中断仲裁之外。</li><li>当服务请求被确认并服务后，硬件会自动重置SRR。软件可以轮询SRR以检查待处理的服务请求。在这种情况下，SRR必须通过软件写入1到CLRR来重置。</li></ul><blockquote><p>清除待处理的服务请求标志SRR和启用相应的服务请求节点（SRN）应分两步/两次写入：首先清除SRR标志（SRC.CLRR），然后启用（SRC.SRE）。</p></blockquote><h5 id=16417-类型服务控制-tos data-numberify>16.4.1.7 类型服务控制 (TOS)<a class="anchor ms-1" href=#16417-类型服务控制-tos></a></h5><p>每个 TriCore CPU 和每个系统 DMA 实例都可以作为中断服务提供者（ISP）。服务请求节点（SRN）可以通过 TOS 位字段映射到一个确切的 ISP。</p><p>TOS 配置将服务请求映射到：</p><ul><li>中断服务提供者（CPUx，DMA）</li><li>与 ISP 相关的中断路由器内部中断控制单元（ICUx），例如 TOS=0 映射到 ICU0，TOS=1 映射到 ICU1，&mldr;</li><li>一个 ACCEN_SRC_TOSx 写保护寄存器，例如 TOS=0 映射到 ACCEN_SRC_TOS0，&mldr;</li></ul><blockquote><p>如果 SRN 启用且配置为保留 TOS 编码，HW 或 SW 触发该 SRN 将通过警报发送到 SMU，不会有进一步的操作。</p></blockquote><h5 id=16418-服务请求优先级号-srpn data-numberify>16.4.1.8 服务请求优先级号 (SRPN)<a class="anchor ms-1" href=#16418-服务请求优先级号-srpn></a></h5><p>SRPN 定义了服务请求相对于同一服务提供者的其他请求源的优先级，以及相对于服务提供者本身的优先级。</p><p>对于映射到相同服务提供者（相同 TOS 配置）的每个活动 SRN：</p><ul><li>可以具有唯一的 SRPN 值</li><li>可以具有非唯一的 SRPN，以赋予一组服务请求相同的优先级</li><li>对于具有相同 SRPN 的服务请求组，执行顺序无法定义</li><li>如果 SRN 未激活（即 SRE 位为 0），则 SRPN 配置没有限制</li></ul><p>服务提供者是 CPU：</p><ul><li>服务请求通过位于每个 CPU 的中断向量表与服务请求优先级号相关联。这意味着 ** CPU 中断向量表按优先级号排序** 。这与传统的中断 CPU 架构不同，传统架构的中断向量表按中断源排序。CPU 中断向量表允许单个外设为不同目的设置多个优先级。</li></ul><blockquote><p>对于 CPU，SRPN 值 0000H 是一个特殊值。SRPN 为 0000H 的服务请求将被 CPU 忽略。CPU 不会确认该请求，相关的服务请求节点将因此不会被清除。由于优先级 0 是最低的服务请求优先级，它不会阻塞中断路由器仲裁。</p><p>TriCore CPU 提供灵活的中断表对齐，可配置 8 字节或 32 字节的向量间距。另请参阅 CPU chapter</p></blockquote><p>服务提供者是 DMA：</p><ul><li>服务请求通过服务请求优先级号与 DMA 通道号相关联：<ul><li>SRPN=x 将触发 DMA 通道 x（如果 DMA 通道 x 已实现）</li><li>仅 SRPN 号在 0 到最大通道号之间会触发相关的 DMA 通道。SRPN 号大于最大通道号的请求将作为其他待处理服务请求处理，但不会触发 DMA 通道。</li></ul></li></ul><p>示例：</p><ul><li>对于一个 16 通道的 DMA 模块，SRPN 号 00H 将触发通道 0，07H 将触发通道 7。所有 SRPN 大于 0FH 的请求将作为其他服务请求处理，但不会触发通道。</li><li>对于一个 64 通道的 DMA 模块，SRPN 号 00H 将触发通道 0，17H 将触发通道 23，3FH 将触发通道 64。所有 SRPN 大于 3FH 的请求将作为其他服务请求处理，但不会触发通道。</li><li>损坏的 SRC 配置会触发不存在的 DMA（由于 TOS、SRPN 或SRE 损坏），ICU EDC 检查（第 16.4.1.9 章）会检测到该配置损坏的服务请求，并在中断服务提供商（此处为：DMA）确认该服务请求后立即向 ICU 发出信号。</li><li>由于 TOS，SRPN 或 SRE 的损坏而触发不存在的 DMA 的损坏 SRC 配置，将由 ICU EDC 检查检测，并在服务请求被服务提供者（DMA）确认后向 ICU 发送警报。</li></ul><h5 id=16419-ecc-编码-ecc data-numberify>16.4.1.9 ECC 编码 (ECC)<a class="anchor ms-1" href=#16419-ecc-编码-ecc></a></h5><p>SRC.ECC 位字段会在以下情况下由服务请求节点（SRN）更新：</p><ul><li>对 SRC[31:0] 进行写操作或读-修改-写操作。</li><li>对 SRC[15:0] 进行写操作（16 位写入）。</li><li>对 SRC[15:8] 或 SRC[7:0] 进行写操作（字节写入）。</li></ul><p>在执行 32 位写入或读-修改-写入操作时，ECC 位字段将使用计算出的 ECC 更新，写入到 ECC 位字段的数据将被忽略。</p><p>ECC 编码涵盖：</p><ul><li>SRC.SRPN，SRC.TOS，SRC.SRE 的新值，以及写入的 SRN 的内部 10 位索引号。</li></ul><p>ECC 没有永久性的检查。每当挂起的服务请求被选定的（TOS）服务提供者接受为下一个处理的服务请求时，ECC 将进行检查。</p><p>ECC 错误检测机制：</p><ul><li>ECC 错误可以通过以下方式插入（修改 ECC 位字段）：<ul><li>写入 SRC[23:16]（字节写入）</li><li>写入 SRC[31:16]（16 位写入）</li></ul></li></ul><blockquote><p>在当前实现中，ECC 代码仅用于错误检测。检测到的错误会报告给 SMU，但不会进行纠正。</p></blockquote><p>ECC 代码：</p><p>用于中断路由器错误检测机制的 ECC 代码是 Hsiao 22_5 代码，具有双重错误检测（DED）能力：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-VHDL data-lang=VHDL><span class=line><span class=ln> 1</span><span class=cl>
</span></span><span class=line><span class=ln> 2</span><span class=cl><span class=n>GEN_ENC22_5</span> <span class=o>:</span> <span class=k>if</span> <span class=p>(</span><span class=n>word_width_g</span><span class=o>/</span><span class=p>(</span><span class=n>nb_mems_g</span><span class=o>*</span><span class=n>ecc_granularity_g</span><span class=p>))</span> <span class=o>=</span> <span class=mi>22</span> <span class=k>and</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=p>(</span><span class=n>nb_check_bits_g</span> <span class=o>=</span> <span class=mi>5</span><span class=p>)</span> <span class=k>generate</span>  <span class=nc>cmr22_5</span><span class=o>:</span> <span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>nb_check_bits_g</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>generate</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl><span class=n>CODE_MATRIX_ROWS</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>  <span class=o>&lt;=</span> <span class=n>code_rows_22_5</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>  <span class=k>end</span> <span class=k>generate</span><span class=p>;</span> <span class=k>end</span> <span class=k>generate</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>
</span></span><span class=line><span class=ln> 6</span><span class=cl><span class=k>type</span> <span class=n>rows_22_5_t</span> <span class=k>is</span> <span class=k>array</span> <span class=p>(</span><span class=mi>4</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>)</span> <span class=k>of</span> <span class=kt>std_ulogic_vector</span><span class=p>(</span><span class=mi>21</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>);</span>  <span class=k>constant</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl><span class=n>code_rows_22_5</span> <span class=o>:</span> <span class=n>rows_22_5_t</span> <span class=o>:=</span> <span class=p>(</span><span class=s>&#34;0001001011001011011011&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl><span class=s>&#34;0010010101010101101101&#34;</span><span class=p>,</span>   <span class=s>&#34;0100100110100110110110&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl><span class=s>&#34;1000111000111000111111&#34;</span><span class=p>,</span>   <span class=s>&#34;1111000000111111000111&#34;</span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=p>);</span>
</span></span></code></pre></div><h5 id=164110-中断触发溢出位-iov data-numberify>16.4.1.10 中断触发溢出位 (IOV)<a class="anchor ms-1" href=#164110-中断触发溢出位-iov></a></h5><p>IOV 位由硬件设置，当以下两个条件都为真时：</p><ul><li>服务请求处于挂起状态。</li><li>新的服务请求通过中断触发或 SETR 位触发。</li></ul><h5 id=164111-中断触发溢出清除位-iovclr data-numberify>16.4.1.11 中断触发溢出清除位 (IOVCLR)<a class="anchor ms-1" href=#164111-中断触发溢出清除位-iovclr></a></h5><p>中断触发溢出清除位（IOVCLR）用于清除 IOV 位。通过向 IOVCLR 位写入 1，可以清除 IOV 位。</p><h5 id=164112-软件粘滞位-sws data-numberify>16.4.1.12 软件粘滞位 (SWS)<a class="anchor ms-1" href=#164112-软件粘滞位-sws></a></h5><p>当 SETR（请求设置位）被写入 1 时，软件粘滞位（SWS）将被设置。</p><h5 id=164113-软件粘滞清除位-swsclr data-numberify>16.4.1.13 软件粘滞清除位 (SWSCLR)<a class="anchor ms-1" href=#164113-软件粘滞清除位-swsclr></a></h5><p>软件粘滞清除位（SWSCLR）用于清除 SWS 位。通过向 SWSCLR 位写入 1，可以清除 SWS 位。</p><h4 id=165-模块中断请求触发到服务请求节点-srn-的映射 data-numberify>16.5 模块中断请求触发到服务请求节点 (SRN) 的映射<a class="anchor ms-1" href=#165-模块中断请求触发到服务请求节点-srn-的映射></a></h4><p>所有模块中断请求都映射到中断路由器中的服务请求节点（SRN）。每个模块中断请求都有一个专用的服务请求节点（SRN）。</p><p>每个 SRN 在中断路由器模块内都有一个唯一的 SRN 索引号。索引号并不是中断路由器模块本身功能所必须的。索引号可以用于通过 OTGM 功能选择一个服务请求节点进行观察。</p><p>服务请求控制（SRC）寄存器的索引号可以直接从其在 SRC 地址范围内的地址偏移量中计算出来，详见第 16.5.1 章。</p><p>中断路由器模块有一个 1024 个中断触发输入向量。每个中断触发输入向量位 [x] 与 SRN 索引号 x 的一个 SRN 相关联。这意味着在中断触发输入向量位 [x] 上的触发脉冲将触发 SRN [x]。</p><blockquote><p>中断触发信号的正边沿被解释为中断触发。详见第 16.5.3 章。</p></blockquote><p><picture><img class=img-fluid alt=ODc3NjljZmYxZ src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/ODc3NjljZmYxZ.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1256 height=965></picture></p><h5 id=1651-src-索引号 data-numberify>16.5.1 SRC 索引号<a class="anchor ms-1" href=#1651-src-索引号></a></h5><p>每个服务请求节点（SRN）都可以通过其专用的服务请求控制寄存器（SRC）进行配置和控制</p><p><picture><img class=img-fluid alt=NDA4Nzk3ODlmZ src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/NDA4Nzk3ODlmZ.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1322 height=151></picture></p><p><picture><img class=img-fluid alt=MWM1YzM5MmJjM src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/MWM1YzM5MmJjM.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1567 height=222></picture></p><p>与某个模块实例相关的 SRC 寄存器的地址在整个 Aurix 系列中都是相同的（例如，QSPI0 的中断）。</p><p>每个 SRC 在中断路由器模块中都有一个唯一的索引号。</p><p>服务请求控制（SRC）的索引号可以直接通过其在 SRC 地址范围内的地址偏移量来计算：</p><ul><li>索引号(SRC) = &lt;SRC 地址偏移量> / 4</li></ul><p>示例：</p><ul><li>SRC_BCU_SPB 的偏移量为 20Hex（见第 16.13 章）</li><li>索引号(SRC_BCU_SPB) = 20Hex / 4 = 8</li></ul><h5 id=1652-与调试复位相关的中断 data-numberify>16.5.2 与调试复位相关的中断<a class="anchor ms-1" href=#1652-与调试复位相关的中断></a></h5><p>为了软件调试的目的，AURIX 设备需要一些仅与调试复位相关的服务请求节点（SRN）。这些 SRN 在非调试复位（例如应用复位）情况下保持其 SRC 寄存器内容和挂起的服务请求状态。结合其他与调试复位相关的调试逻辑（例如断点逻辑），这允许用户软件在应用复位后调试导致应用复位的情况。</p><h5 id=1653-服务请求触发信号的时序特性 data-numberify>16.5.3 服务请求触发信号的时序特性<a class="anchor ms-1" href=#1653-服务请求触发信号的时序特性></a></h5><p>中断路由器由系统外围总线（SPB）时钟驱动。对于模块中断/服务请求触发信号到中断路由器的规则如下：</p><ul><li>触发信号必须与 SPB 时钟同步</li><li>中断路由器的触发输入是边沿敏感的（对正时钟边沿敏感）</li><li>触发信号脉冲的最小高电平长度为一个 SPB 时钟周期，高电平脉冲长度可以大于 1 个 SPB 时钟周期</li><li>与调试相关的触发信号脉冲应由相关模块保持高电平，直到触发被处理</li></ul><h4 id=166-中断控制单元-icu data-numberify>16.6 中断控制单元 (ICU)<a class="anchor ms-1" href=#166-中断控制单元-icu></a></h4><p>中断路由器模块包括每个服务提供者（如 CPU 和 DMA 模块）对应的一个中断控制单元 (ICU)，每个 ICU 与一个服务提供者相关联。服务请求节点 (SRN) 可以通过 SRN 的 SRCx.TOS 寄存器位字段映射到其中一个 ICU（参见图 173）。</p><p>ICU 的功能包括：</p><ul><li>管理映射到 ICU 的 SRN 之间竞争的服务请求的仲裁。</li><li>向服务提供者提供仲裁轮次的胜利者。</li><li>接收来自服务提供者的信息，表明哪个服务请求被接受。</li><li>检查被接受的服务请求信息（ECC 检查）。</li><li>向安全管理单元 (SMU) 发出完整性错误信号。</li><li>管理相关 SRN 中被确认的服务请求的清除。</li></ul><blockquote><p>当前实现中，ECC 代码仅用于错误检测。检测到的错误会报告给 SMU，但不会被纠正。</p></blockquote><h5 id=1661-icu-与-isp-的接口 data-numberify>16.6.1 ICU 与 ISP 的接口<a class="anchor ms-1" href=#1661-icu-与-isp-的接口></a></h5><p>ICU 和连接的 ISP 之间的接口由中断路由器的 EDC 保护覆盖。为了增强接口的稳健性，在没有服务请求信号发送给 ISP 或 ISP 未确认服务请求给 ICU 的情况下，ICU 和 ISP 输出会被设置为默认值。</p><p>当 VALID 信号发生卡住在高电平的错误时，CPU 将忽略默认信息（SRPN=8&rsquo; h00），而 DMA 将触发通道并确认默认信息给 ICU，ICU 会通过 EDC 保护检测到此情况并向 SMU 发送警报。</p><p>当 ACKNOWLEDGE 信号发生卡住在高电平的错误时，ICU 会采用默认值并检测到 EDC 错误。</p><p>只要 ICU 未向连接的 ISP 发送服务请求（VALID=0），ICU 输出信号将设置为以下默认值：</p><ul><li>IDX = 10&rsquo;h 000</li><li>PIPN/SRPN = 8&rsquo;h 00</li><li>ECC = 5&rsquo;h 00</li></ul><p>只要 ISP 未确认服务请求给相关的 ICU（ACKNOWLEDGE=0），ICU 输出信号将设置为以下默认值：</p><ul><li>IDX = 10&rsquo;h 000</li><li>PIPN/SRPN = 8&rsquo;h 00</li><li>ECC = 5&rsquo;h 00</li></ul><h4 id=1662-icu-控制寄存器 data-numberify>16.6.2 ICU 控制寄存器<a class="anchor ms-1" href=#1662-icu-控制寄存器></a></h4><p>本节描述中断控制单元 (ICU) 寄存器。每个 ICU 包含两个控制寄存器：</p><ul><li>LWSR：最新获胜服务请求寄存器（第 16 页）提供有关上一次服务请求仲裁轮次的获胜者的信息。</li><li>最后确认服务请求寄存器（第 17 页）提供有关被服务提供者接受的最后一个服务请求的信息。</li><li>错误捕获寄存器（第 17 页）在 ICU 检测到 ECC 错误时捕获最后确认服务请求寄存器的内容。</li></ul><h5 id=16621--lwsr最新获胜服务请求寄存器 data-numberify>16.6.2.1 LWSR：最新获胜服务请求寄存器<a class="anchor ms-1" href=#16621--lwsr最新获胜服务请求寄存器></a></h5><p>最新获胜服务请求寄存器 x，与 ICUx 相关。</p><p>该寄存器提供有关上一次仲裁轮次获胜者的信息。寄存器位字段表示 ICU 向中断服务提供者提供的内容。</p><p>LWSRx (x=0-7) 最新获胜服务请求寄存器 x，与 ICUx 相关 (0200H+x*10H)，default：0</p><p>LWSR.PN [7:0] : <strong>Latest Winner Priority Number</strong></p><p>LWSR.ECC [14:10] : Latest Winner ECC</p><p>LWSR.ID [25:16] : Latest Winner Index Number of SRN</p><p>LWSR.STAT [31] : LWSR Register Status，是否有效</p><h5 id=16622-lasr最后确认的服务请求寄存器 data-numberify>16.6.2.2 LASR：最后确认的服务请求寄存器<a class="anchor ms-1" href=#16622-lasr最后确认的服务请求寄存器></a></h5><p>最后确认的服务请求寄存器 x，与 ICUx 相关。</p><p>最后确认的服务请求寄存器提供了有关被中断服务提供者 (ISP) 确认的最后一个服务请求的信息。寄存器位字段显示了中断服务提供者与最新确认一起发送的内容。</p><p>LASRx (x=0-7) 最后确认的服务请求寄存器 x，与 ICUx 相关 (0204H + x*10H)，复位值: 0</p><p>LASR.PN [7:0] : Last Acknowledged Service Request Priority Number</p><p>LASR.ECC [14:10] : Latest Acknowledged Interrupt ECC</p><p>LASR.ID [25:16] : Last Acknowledged Interrupt SRN ID</p><h5 id=16623-ecr错误捕获寄存器 data-numberify>16.6.2.3 ECR：错误捕获寄存器<a class="anchor ms-1" href=#16623-ecr错误捕获寄存器></a></h5><p>错误捕获寄存器 x，与 ICUx 相关。</p><p>在检测到 ECC 错误时，错误捕获寄存器 (ECRx) 会捕获相关的服务请求信息。这是通过在检测到 ECC 错误时，将最后确认的服务请求 (LASRx) 寄存器的内容更新到 ECR 来实现的。ECR 始终显示检测到 ECC 错误时的最后一次 ECR 内容。</p><p>软件可以通过写入 ECRx 来清除 ECR 位字段中的 PN，ECC，ID。错误状态 (STAT) 和错误溢出 (EOV) 位可以用作错误处理机制，并指示错误信息的丢失。如果 ECR.EOV 被软件清除，则 ECR.EOV 必须与 ECR.STAT 一起清除。如果在 ECR.EOV 清除的同时检测到新的错误，硬件会再次设置 ECR.EOV，而 ECR.STAT 则被清除。</p><p>注意: 在当前的实现中，ECC 代码仅用于错误检测。检测到的错误会报告给 SMU，但不会被纠正。</p><p>ECRx (x=0-7)</p><p>错误捕获寄存器 x，与 ICUx 相关 (0208H + x*10H)，复位值: 0</p><p>ECR.PN [7:0] : Service Request Priority Number</p><p>ECR.ECC [14:10] : Service Request ECC</p><p>ECR.ID [25:16] : Service Request Node ID</p><p>ECR.EOVCLR [28] : Error Overflow Bit</p><p>ECR.STATCLR [29] : Error Status Bit</p><p>ECR.EOV [30] : Error Overflow Bit</p><p>ECR.STAT [31] : Error Status Bit，错误检测标志位</p><h4 id=167-通用服务请求服务请求广播 data-numberify>16.7 通用服务请求，服务请求广播<a class="anchor ms-1" href=#167-通用服务请求服务请求广播></a></h4><p>INT 模块提供了多个通用服务请求 (GPSR) 组，以及通过软件并行触发 GPSR 组中多个服务请求的机制（见 16.7.2 章节）。</p><p>通用服务请求主要用于软件中断，因为它们并未映射到硬件中断触发事件</p><p><picture><img class=img-fluid alt=ZjZlODgwYWRmN src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/ZjZlODgwYWRmN.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1079 height=716></picture></p><h5 id=1671-通用服务请求-gpsrxy data-numberify>16.7.1 通用服务请求 (GPSRxy)<a class="anchor ms-1" href=#1671-通用服务请求-gpsrxy></a></h5><p>INT 模块提供了多个通用服务请求组：</p><ul><li>每个通用服务请求组包含八个服务请求节点 (SRN)。</li><li>通用服务请求命名为 SRC_GPSRxy。</li></ul><blockquote><p>x = 组号; y= 组内的中断号, y=0:7</p></blockquote><ul><li>GPSR 主要用于软件中断（未映射到硬件服务请求触发器）。</li><li>GPSR 只能通过向相关的 SRC_GPSRxy.SETR 位写入 <code>1</code> 或通过向相关的服务请求广播寄存器 SRBx[y] 写入 <code>1</code> 来触发。</li></ul><h5 id=1672-服务请求广播寄存器-srbx data-numberify>16.7.2 服务请求广播寄存器 (SRBx)<a class="anchor ms-1" href=#1672-服务请求广播寄存器-srbx></a></h5><p>服务请求广播寄存器 (SRBx) 可用于并行向多个服务提供者（CPU 或 DMA）发送服务请求。</p><ul><li>每个通用服务请求组 (GPSRxy) 对应一个服务请求广播寄存器 (SRBx)。</li><li>SRBx 可用于并行触发 SRC_GPSRx 组内的多个服务请求。</li><li>SRBx 总是读取为 0。</li><li>向 SRBx[y] 写入 <code>1</code> 触发服务请求 GPXRxy。</li><li>向 SRBx[31:6] 写入 <code>1</code> 无效。</li></ul><h5 id=1673-srbx-寄存器的访问保护-accen_srbx data-numberify>16.7.3 SRBx 寄存器的访问保护 (ACCEN_SRBx)<a class="anchor ms-1" href=#1673-srbx-寄存器的访问保护-accen_srbx></a></h5><p>每个 SRBx 寄存器通过专用的 ACCEN_SRx0 / ACCEN_SRBx1 寄存器组进行写保护：</p><ul><li>每个 SRBx 寄存器都有一个相关的 ACCEN_SRBx 寄存器。</li><li>ACCEN_SRBx 的配置定义了哪个 TAG ID 可以写入相关的 SRBx 寄存器。</li><li>如果发生访问保护违规，写操作将被静默忽略，并向 SMU 报告错误。除此之外，不会生成其他错误、中断或陷阱。</li></ul><h4 id=168-系统寄存器 data-numberify>16.8 系统寄存器<a class="anchor ms-1" href=#168-系统寄存器></a></h4><p>中断路由器模块不支持 CLC, OCS 和 KRSTx 寄存器。中断路由器支持多组访问启用 (ACCEN) 寄存器：</p><ul><li>INT_ACCENx：寄存器访问保护通过标准 ACCEN 寄存器实现，但包括 ACCEN_CONFIG0/1、ACCEN_SRBx0/1 和 ACCEN_SRC_TOSx0/1。</li><li>INT_CLC：中断路由器模块不支持时钟控制 (CLC) 功能。</li><li>INT_KRSTx：中断路由器模块不支持模块内核重置功能。</li><li>OCS：中断路由器不支持 OCDS 控制和状态寄存器。</li></ul><h5 id=1681-中断路由器寄存器的写保护 data-numberify>16.8.1 中断路由器寄存器的写保护<a class="anchor ms-1" href=#1681-中断路由器寄存器的写保护></a></h5><p>中断路由器模块提供基于主 TAG ID 的写访问保护，作为 AURIX 安全概念的一部分。每个具有直接或间接总线主控能力的片上资源都有一个唯一的主 TAG ID，可用于标识片上总线事务的主控。</p><p><picture><img class=img-fluid alt=YjEzMWJmOTIwY src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/YjEzMWJmOTIwY.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1574 height=901></picture></p><p>中断路由器模块通过三个访问启用寄存器/寄存器组提供控制寄存器的写保护：</p><ol><li><strong>服务请求广播寄存器的访问保护 (ACCEN_SRBx0/1)：</strong><ol><li>中断路由器模块提供一个或多个通用服务请求组 (GPSRx)。</li><li>每个 GPSRx 组都有一个专用的服务请求广播寄存器 (SRBx)，可用于并行设置组中的多个服务请求节点。</li></ol></li><li><strong>静态控制寄存器的访问保护 (ACCEN_CONFIG0/1)：</strong><ol><li>ACCEN_CONFIG 提供对以下寄存器的写访问保护：<ul><li>所有 SRC 寄存器的低 15 位 (SRCx[15:0])，包括 TOS、SRE 和 SRPN 位字段。</li><li>所有 ICU 错误捕获寄存器 (ECRx)。</li></ul></li></ol></li><li><strong>SRC 控制寄存器的访问保护 (ACCEN_SRC_TOSy)：</strong><ol><li>ACCEN_SRC_TOSy 提供对 SRCx[31:16] 的写访问保护。</li></ol></li></ol><h4 id=1682-内核复位寄存器-krst10-krstclr data-numberify>16.8.2 内核复位寄存器 (KRST1/0, KRSTCLR)<a class="anchor ms-1" href=#1682-内核复位寄存器-krst10-krstclr></a></h4><p>INT 模块不包括内核复位寄存器 (KRST1, KRST0, KRSTCLR)。</p><p>注意： 中断路由器模块不支持模块内核复位。</p><h4 id=1683-时钟控制寄存器-clc data-numberify>16.8.3 时钟控制寄存器 (CLC)<a class="anchor ms-1" href=#1683-时钟控制寄存器-clc></a></h4><p>INT 模块不包括模块时钟控制 (CLC)。</p><p>注意： 中断路由器模块不支持时钟控制寄存器功能，这意味着不能通过 CLC 寄存器禁用中断路由器模块的时钟。</p><h4 id=1684-ocds-控制和状态寄存器-ocs data-numberify>16.8.4 OCDS 控制和状态寄存器 (OCS)<a class="anchor ms-1" href=#1684-ocds-控制和状态寄存器-ocs></a></h4><p>INT 模块不包括 OCDS 控制和状态 (OCS) 寄存器。</p><p>注意： 中断路由器模块不支持 OCS 寄存器功能。</p><h4 id=169-仲裁过程 data-numberify>16.9 仲裁过程<a class="anchor ms-1" href=#169-仲裁过程></a></h4><p>在中断模块中，每个 ICU 都有其自己的中断总线。每个服务请求节点 (SRN) 都可以通过将 SRC.TOS 位字段设置映射到相关的 ICU / 中断总线，将其定向到一个服务提供者。</p><p><picture><img class=img-fluid alt=MTJmNjdmMWEzY src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/MTJmNjdmMWEzY.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1570 height=1122></picture></p><p>当有第一个待处理的服务请求时，相关的中断总线将开始第一次仲裁过程。相关的中断控制单元 (ICU) 将提供在上一次仲裁过程中获胜的服务请求。</p><p>仲裁过程使用 3-4 个系统外围总线 (SPB) 时钟周期来确定具有最高优先级编号 (SRPN) 的待处理服务请求。确切的实现方式在模块实现章节中有所描述。</p><p>在仲裁过程中，中断总线会比较所有映射到该中断总线的待处理服务请求节点 (SRN) 的 SRC.SRPN 位字段。仲裁过程中，具有最高优先级编号的待处理服务请求被确定为获胜者，并将相关的 SRN 服务请求控制寄存器位字段值 (SRPN, ECC 和 SRN 的索引) 提供给 ICU。 ICU 将这些信息 (SRPN, ECC, SRN 索引) 提供给服务提供者。当服务提供者返回确认信息时，ICU 将进行 ECC 校验。ECC 校验使用接收到的值：ECC, SRPN, SRN 索引号，假定为 <code>1</code> 的 SRE 位 (SRN 启用) 以及 ICU 的 TOS 编号。</p><p>中断路由器模块会将检测到的错误信号发送到安全管理单元 (SMU)（SMU 中的一位，涵盖所有 SRN 和 ICU 的错误）。</p><blockquote><p>当前实现中，ECC 代码仅用于错误检测，检测到的错误会报告给 SMU，但不会进行纠正。</p></blockquote><h5 id=1691-每个仲裁过程的时钟周期数 data-numberify>16.9.1 每个仲裁过程的时钟周期数<a class="anchor ms-1" href=#1691-每个仲裁过程的时钟周期数></a></h5><p>中断路由器的实现可以根据以下方面进行配置：</p><ul><li>支持的服务请求数量 (Service Request Nodes, SRN，最多可达 1024)</li><li>SRPN 位大小 (8 位)</li><li>支持的服务提供者数量 (中断控制单元，ICU)</li><li>每个服务请求仲裁的时钟周期数 (3-4 个 SPB 时钟周期)</li></ul><p>在 AURIX 产品中实现的中断路由器模块的特性在模块实现子章节中有所描述。</p><p><picture><img class=img-fluid alt=YjllZjgyZDBlZ src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/YjllZjgyZDBlZ.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1544 height=727></picture></p><p>第178图显示了一个中断路由器在3周期仲裁过程中的中断时序。</p><p>Cycle 1: ICU没有待处理的服务请求（因此没有仲裁轮次）。</p><p>Cycle 2: 一个模块通过向中断路由器模块中的相关服务请求节点（SRN）发送一个脉冲来触发一个服务请求。</p><p>Cycle 3-5: 在所有发送给ICU的待处理服务请求之间进行仲裁，比较所有待处理请求的服务请求优先级编号（SRPN），并确定最高优先级的请求为获胜请求。</p><p>Cycle 6: ICU将获胜的服务请求提供给服务提供者，包括SRPN，ECC和SRN索引。</p><p>Cycle 7 &ndash; n-1: ICU重新仲裁，当有另一个SRN的新服务请求挂起时，如果该新请求具有更高的SRPN（更高优先级），则提供新的获胜服务请求给ICU。</p><p>Cycle 6 &ndash; n-1: 中断服务提供者接收最新的获胜SRN的信息（Enter）。</p><p>Cycle n: 服务提供者确认服务请求，提供已确认的服务请求的SRPN、ECC、SRN索引信息。同时，ICU在同一个时钟周期内将信号更改为“无有效服务请求”。</p><p>Cycle n+1: ICU对确认信息进行ECC检查，包括SRPN，ECC，SRN索引、SRE=‘1’（SRN已启用）、ICU的TOS编号。如果出现不匹配，则向SMU报告完整性错误，SRPN、ECC和索引会被捕获到ECR中。硬件将清除已确认的SRN索引号的服务请求。</p><p>Cycle n+2: 如果ICU中至少有一个服务请求待处理，则在所有待处理服务请求之间进行新的仲裁。</p><h5 id=1692-服务请求有效性-service-request-valid data-numberify>16.9.2 服务请求有效性 (Service Request Valid)<a class="anchor ms-1" href=#1692-服务请求有效性-service-request-valid></a></h5><p>ICU 通过断言 Valid 信号向 ISP 提供仲裁获胜的待处理服务请求的信息。在 ISP 断言 Enter 信号之前，将继续重新仲裁。</p><h5 id=1693-服务请求进入-service-request-enter data-numberify>16.9.3 服务请求进入 (Service Request Enter)<a class="anchor ms-1" href=#1693-服务请求进入-service-request-enter></a></h5><p>当中断服务提供者 (ISP) 接收到服务请求的有效信息后，向 ICU 发送 Enter 信号，表示它已开始准备执行相关的中断服务例程 (ISR)。ISP 可以通过 Acknowledge 信号（表示中断服务例程已经开始执行，ICU 将清除相关的 SRN）或在没有 Acknowledge 信号的情况下重置 Enter 信号（例如，当 CPU 在能够开始 ISR 之前陷入陷阱或异常时，ICU 将不会清除相关的 SRN）。</p><h5 id=1694-服务请求确认-service-request-acknowledge data-numberify>16.9.4 服务请求确认 (Service Request Acknowledge)<a class="anchor ms-1" href=#1694-服务请求确认-service-request-acknowledge></a></h5><p>当服务提供者开始执行 ICU 提供的服务请求时，服务提供者会向 ICU 发送确认信号 (Acknowledge)。同时，服务提供者会将已执行的服务请求的信息 (SRPN, ECC, SRN 索引号) 发送回 ICU。在同一时钟周期内，服务提供者发送确认信号，ICU 将状态更改为“没有可用的服务请求”：ICU 不会再向服务提供者提供仲裁获胜者。ICU 的这种行为确保在 SRN 被重置之前，已确认的服务请求不会再次被提供（参见图 178）。</p><h5 id=1695-处理检测到的-ecc-错误 data-numberify>16.9.5 处理检测到的 ECC 错误<a class="anchor ms-1" href=#1695-处理检测到的-ecc-错误></a></h5><p>ICU 会对其从服务提供者接收到的确认信息 (TOS, SRPN, Index 和 ECC) 以及 ICU 本身的 TOS 编号进行错误检测校验。SRE 位假定为 <code>1</code>（SRN 已启用）。SRN 中的 ECC 覆盖了 SRC 位字段的值：SRC.SRPN, SRC.SRN 索引, SRC.SRE 和 SRC.TOS（参见图 178）。</p><blockquote><p>在当前实现中，ECC 代码仅用于错误检测，检测到的错误会报告给 SMU，但不会进行纠正。</p></blockquote><p>如果 ICU 检测到 ECC 错误：</p><ul><li>ICU 会在错误捕获寄存器 (ECRx) 中捕获显示 ECC 错误的 ECC, SRPN 和索引，设置 ECRx.STAT 位，并在 STAT 位仍然设置时设置 ECRx.EOV 位。</li><li>ICU 通过中断路由器错误信号向 AURIX TM TC3xx 平台安全管理单元 (SMU) 发出错误信号。SMU 将此信息转发给 CPU（如果启用）。</li><li>ICU 清除 SRN 中的服务请求（由索引选择）。</li><li>收到“中断路由器中检测到 ECC 错误”信息的 CPU 可以通过错误状态位 (ECRx.STAT= <code>1</code>) 识别 ICU，读取相关服务请求信息，并通过写入 <code>1</code> 清除 ECRx.STAT 位。CPU 还可以通过错误溢出位 (ECRx.EOV= <code>1</code>) 确定是否检测到一个或多个 ECC 错误。</li></ul><h4 id=1610-中断系统的使用 data-numberify>16.10 中断系统的使用<a class="anchor ms-1" href=#1610-中断系统的使用></a></h4><p>以下部分简要介绍了服务提供者与中断路由器 ICU 的接口。</p><blockquote><p>中断路由器中的所有 ICU 子模块具有相同的功能。</p></blockquote><h5 id=16101-cpu-到-icu-接口 data-numberify>16.10.1 CPU 到 ICU 接口<a class="anchor ms-1" href=#16101-cpu-到-icu-接口></a></h5><p>中断路由器模块为每个 CPU 和 DMA 模块提供了一个专用的中断控制单元 (ICU)。CPU ICU 接口由一组寄存器组成，CPU 在其中接收 ICU 提供的服务请求信息（SRPN, SRN 索引, ECC）。当 CPU 确认服务请求时，这些信息将被发送回 ICU（参见 16.4.1.8 章节）。</p><p>CPU ICU 接口包含一个中断控制寄存器 (ICR)，该寄存器包含当前 CPU 优先级编号 (CCPN)、全局中断启用/禁用位 (IE) 和挂起中断优先级编号 (PIPN)。CPU ICU 接口的进一步细节以及 CPU 处理中断的方式可以在 CPU 章节中找到。</p><h5 id=16102-dma-到-icu-接口 data-numberify>16.10.2 DMA 到 ICU 接口<a class="anchor ms-1" href=#16102-dma-到-icu-接口></a></h5><p>中断路由器模块为每个 DMA 模块提供了专用的中断控制单元 (ICU)。DMA 接管来自 ICU 的服务请求信息，触发相关的 DMA 通道，并立即向 ICU 确认，随后相关的 SRN 被清除。</p><p>DMA 到 ICU 接口由一组寄存器组成，其中它接管 ICU 提供的服务请求信息（SRPN, SRN 索引, ECC）。DMA 在下一个时钟周期内向 ICU 发送确认（参见 16.4.1.8 章节）。</p><p>DMA 通道的优先级方案与 SRPN 优先级方案相同：</p><ul><li>DMA 内的最低优先级：通道 0</li><li>最低优先级：SRPN = 0</li></ul><h5 id=16103-软件触发的中断-software-initiated-interrupts data-numberify>16.10.3 软件触发的中断 (Software-Initiated Interrupts)<a class="anchor ms-1" href=#16103-软件触发的中断-software-initiated-interrupts></a></h5><p>任何服务请求节点 (SRN) 都可以用作软件中断。软件可以通过写入服务请求控制寄存器 (SRC) 中的服务请求位 (SRR)，在任何 SRN 中设置服务请求位，从而触发服务请求。这些服务请求将通过与硬件触发的服务请求相同的机制处理。一旦在 SRN 中设置了 SRR 位，软件触发的服务请求和硬件触发的服务请求将无法区分。因此，软件应该仅使用未用于硬件触发服务请求的 SRNs 和中断优先级编号。</p><p>设备为每个 TriCore CPU 提供了一组通用服务请求 SRNs，每个组包括 8 个 SRNs，这些 SRNs 不连接到内部或外部的硬件触发信号，因此只能用作软件中断或软件触发的服务请求。这些 SRNs 被称为通用服务请求节点 (SRC_GPSRxy, x=组号, y=0-7)。</p><p>此外，任何未使用的 SRN 也可以用于生成软件中断。</p><h5 id=16104-外部中断-external-interrupts data-numberify>16.10.4 外部中断 (External Interrupts)<a class="anchor ms-1" href=#16104-外部中断-external-interrupts></a></h5><p>有 8 个 SRNs (Int_SCUSRC[7:0]) 保留用于处理外部中断。外部 GPIO 端口输入信号（例如边沿触发或电平触发）的设置，包括中断请求的触发方式，受外部请求单元 (ERU) 控制。ERU 的功能在 SCU 章节中有详细描述。</p><h4 id=1611-使用案例-use-case-examples data-numberify>16.11 使用案例 (Use Case Examples)<a class="anchor ms-1" href=#1611-使用案例-use-case-examples></a></h4><p>本节展示了中断系统的使用案例和 OTGS 的使用案例。</p><h5 id=16111-中断处理程序的使用案例-use-case-example-interrupt-handler data-numberify>16.11.1 中断处理程序的使用案例 (Use Case Example Interrupt Handler)<a class="anchor ms-1" href=#16111-中断处理程序的使用案例-use-case-example-interrupt-handler></a></h5><p>本节解释了如何组织 TriCore 中断向量表。当 TriCore 接受中断时，中断向量表的入口地址由 TriCore 寄存器 BIV（基中断向量表指针）和该中断的优先级编号 (PIPN) 计算得出。TriCore TC1.6P 和 TC1.6E 架构提供了配置向量表条目间距的可能性，可以设置为 32 字节（参见下图 a（图 179））或 8 字节（参见下图 b（图 179））。第三种选择是通过屏蔽 PIPN 将向量表缩减为单个条目（参见下图 c（图 179））。</p><p><picture><img class=img-fluid alt=NzRiOGY0NzJjY src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/NzRiOGY0NzJjY.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1566 height=1224></picture></p><blockquote><p>c): 单入口地址，软件区分中断handler</p></blockquote><p>通过使用32字节配置，小型中断程序可以直接在向量表中实现。它们甚至可以跨多个向量条目实现（参见TriCore架构手册）。如果向量表可以位于 TriCore 程序端内存中，这种快速中断处理就很有用。8字节配置减少了向量表的大小。每个向量条目仅包含一个跳转指令或一个调用和返回作为16位操作码指令。 <strong>TriCore编译器通过关键字或函数支持这种类型的中断向量表生成</strong> 。如果BIV屏蔽了PIPN，使得任何中断地址计算结果相同，则可以配置最小的向量表。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=ln>1</span><span class=cl><span class=nf>__mtcr</span><span class=p>(</span><span class=n>BIV</span><span class=p>,</span><span class=mh>0x80000001</span> <span class=o>|</span> <span class=mh>0xFF</span><span class=o>&lt;&lt;</span><span class=mi>3</span><span class=p>);</span> <span class=c1>// 将值写入核心寄存器BIV
</span></span></span></code></pre></div><p>这将BIV寄存器配置为使用一个通用的单个条目，其中函数 <code>interruptHandler</code>位于此处，通过使用函数指针数组分支到特定的中断例程。如果使用一个指向数组的指针，该数组可以快速切换。</p><p><strong>初始化和安装中断的步骤描述</strong></p><ol><li>定义ISR指针数组：最多可以有255个中断。</li><li>定义指向ISR指针数组起始位置的指针。</li><li>开始编写 <code>interruptHandlerInstall</code>函数：此函数用于在数组中安装中断。所需信息是中断优先级和ISR入口地址。</li><li>将ISR入口地址存储在数组中。</li><li>编写 <code>interruptHandler</code>函数：在中断发生后立即调用此函数，并分支到特定的中断例程。</li><li>分支到特定的中断例程。</li><li>在ISR处理完毕后执行返回命令。</li></ol><p><strong>初始化和安装中断的C代码示例</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=ln>1</span><span class=cl><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>isr_pointer_array</span><span class=p>[</span><span class=mi>256</span><span class=p>])(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=kt>void</span> <span class=p>(</span><span class=o>**</span><span class=n>isr</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=n>isr_pointer_array</span><span class=p>;</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=kt>void</span> <span class=nf>interruptHandlerInstall</span><span class=p>(</span><span class=kt>long</span> <span class=kt>int</span> <span class=n>SRprio</span><span class=p>,</span> <span class=kt>long</span> <span class=kt>int</span> <span class=n>addr</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=p>(</span><span class=mi>4</span><span class=p>)</span>   <span class=o>*</span><span class=n>isr_pointer_array</span><span class=p>[</span><span class=n>SRprio</span><span class=p>]</span> <span class=o>=</span> <span class=n>addr</span><span class=p>;</span> 
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=ln>6</span><span class=cl><span class=p>(</span><span class=mi>5</span><span class=p>)</span> <span class=kt>void</span> <span class=nf>interruptHandler</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=ln>7</span><span class=cl><span class=p>(</span><span class=mi>6</span><span class=p>)</span>   <span class=n>isr</span><span class=p>[</span><span class=nf>__mfcr</span><span class=p>(</span><span class=n>ICR</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xFF</span><span class=p>]();</span> 
</span></span><span class=line><span class=ln>8</span><span class=cl><span class=p>(</span><span class=mi>7</span><span class=p>)</span>   <span class=k>asm</span> <span class=p>(</span><span class=s>&#34;rfe&#34;</span><span class=p>);</span> <span class=c1>// 从事件返回 
</span></span></span><span class=line><span class=ln>9</span><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>在这个例子中，中断入口地址存储在数据数组中，而不是将值编码到指令中。<code>interruptHandlerInstall</code>函数负责组织在该数组中安装中断（参见在STM章节中的模块用例示例）。这种向量表生成方式有时比8字节配置更灵活，并且不需要编译器对中断的特定支持。</p><blockquote><p>在中断能够发生之前，必须全局启用中断系统。中断控制寄存器（ICR）包含全局中断使能位（ICR.IE），该位启用CPU服务请求系统。大多数编译器支持使用类似以下的属性：__enable(); 来设置此位。详细信息请参见架构手册。</p></blockquote><h4 id=1612-模块实现 data-numberify>16.12 模块实现<a class="anchor ms-1" href=#1612-模块实现></a></h4><h5 id=16121-中断路由器模块的特性 data-numberify>16.12.1 中断路由器模块的特性<a class="anchor ms-1" href=#16121-中断路由器模块的特性></a></h5><p>表553显示了不同TC3xx设备中实现的中断路由器配置。共享仲裁按ICUx对实现，从ICU0开始（ICU0/ICU1，ICU2/ICU3，&mldr;&mldr;）。</p><p><picture><img class=img-fluid alt=NjhmNjMxN2MyZ src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/NjhmNjMxN2MyZ.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1562 height=493></picture></p><h3 id=1613-中断路由器系统和模块寄存器 data-numberify>16.13 中断路由器系统和模块寄存器<a class="anchor ms-1" href=#1613-中断路由器系统和模块寄存器></a></h3><p>图180显示了设备中与中断路由器模块相关的所有寄存器。中断路由器分配了两个地址范围：</p><p>2 * 256字节地址范围：覆盖中断路由器系统寄存器、ICU控制寄存器和OTGM寄存器。</p><p>8 KB地址范围：覆盖服务请求控制寄存器。</p><p><picture><img class=img-fluid alt=ZThiNzc1YjIzM src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/ZThiNzc1YjIzM.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1541 height=387></picture></p><h3 id=使用的访问保护寄存器缩写列表 data-numberify>使用的访问保护寄存器缩写列表<a class="anchor ms-1" href=#使用的访问保护寄存器缩写列表></a></h3><ul><li>P0 -> <code>ACCEN_SRBx</code>：相关SRBx寄存器的写保护。服务请求广播寄存器（SRB）的数量和相关的ACCEN_SRB寄存器的数量与已实现的TriCore CPU数量相等。</li><li>P1 -> <code>ACCEN_CONFIG</code>：写保护所有SRCx[15:0]和ICUx错误捕获寄存器（ECRx）。</li><li>P2 -> <code>ACCEN_SRC_TOSx</code>：写保护所有映射到TOSx的SRC的位[31:16]（SCR.TOS=x）。对于每个已实现的中断控制单元，实现一个ACCEN_SRC_TOSx寄存器。</li></ul><blockquote><p>访问保护的违规行为不会被执行（例如，通过具有禁用的主标记ID的SPB访问写入到受 <code>Px</code>/ACCEN保护的寄存器）。在这种情况下，访问保护错误将被信号发送到SMU。除了向SMU发出信号外，不会产生其他错误、中断或陷阱。</p></blockquote><p><picture><img class=img-fluid alt=YjEwZDQ4NjQ1Y src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/YjEwZDQ4NjQ1Y.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1589 height=1041></picture></p><p><picture><img class=img-fluid alt=MDE1NDI4OGFlN src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/MDE1NDI4OGFlN.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1176 height=1090></picture></p><p><picture><img class=img-fluid alt=NzYzYjU2ZjdlN src="https://6668688.xyz/docs/cpu/tricore/images/tc397_Interrupt/NzYzYjU2ZjdlN.png?v=bd994137d6ec72d357cb4f9c079d36ad" loading=lazy width=1199 height=175></picture></p><h1 id=system-control-unit-scu-chapter-external-request-unit data-numberify>System Control Unit (SCU) chapter, External Request Unit<a class="anchor ms-1" href=#system-control-unit-scu-chapter-external-request-unit></a></h1><p>(ERU)</p><h1 id=stm章节 data-numberify>STM章节<a class="anchor ms-1" href=#stm章节></a></h1><p>tc397中断 与 arm gic中断区别</p></div></div></div><div class=card-footer><div class="post-navs d-flex justify-content-evenly"><div class="post-nav post-prev"><i class="fas fa-fw fa-chevron-down post-prev-icon me-1" data-fa-transform=rotate-90></i>
<a href=/docs/cpu/tricore/tc397/>Tc397</a></div><div class="post-nav post-next"><a href=/docs/cpu/debug/trace32/>TRACE32使用教程</a>
<i class="fas fa-fw fa-chevron-down post-next-icon ms-1" data-fa-transform=rotate-270></i></div></div></div></article><div class="post-copyright mb-3 row card component" id=post-copyright><div class=card-header><h2 class="card-title fs-4 my-2 text-surface">版权</h2></div><div class=card-body></div></div><div class="card component row post-comments" id=post-comments><div class=card-header><h2 class="card-title my-2 fs-4 text-surface">评论</h2></div><div class=card-body><div class=giscus></div></div></div></div></div><aside class="sidebar d-flex docs-sidebar col-xxl-3 position-sticky order-xxl-5"><div class=container><div class="accordion post-toc d-none d-lg-block"><div class="accordion-item row mb-4 card component" id=postTOC><div class="card-header accordion-header"><h2 class="card-title fs-4 my-2 text-surface d-none d-lg-block">目录</h2><a class="accordion-button d-lg-none mb-1 collapsed shadow-none p-0 bg-transparent" role=button data-bs-toggle=collapse href=#post-toc aria-expanded=false aria-controls=post-toc>目录</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=post-toc><nav id=TableOfContents><ul><li><a href=#复位值>复位值</a></li><li><a href=#endinit保护>ENDINIT保护</a></li></ul><ul><li><a href=#51-一般操作>5.1 一般操作</a><ul><li><a href=#511-icu中断控制寄存器icr>5.1.1 ICU中断控制寄存器（ICR）</a></li><li><a href=#512-cpu对中断请求的操作>5.1.2 CPU对中断请求的操作</a></li><li><a href=#513-进入中断服务例程isr>5.1.3 进入中断服务例程（ISR）</a></li></ul></li><li><a href=#52-退出中断服务例程isr>5.2 退出中断服务例程（ISR）</a></li><li><a href=#53-中断向量表>5.3 中断向量表</a></li><li><a href=#54-使用tricore中断系统>5.4 使用TriCore中断系统</a><ul><li></li><li><a href=#544-使用不同的优先级处理相同的中断源>5.4.4 使用不同的优先级处理相同的中断源</a></li><li><a href=#545-中断控制寄存器>5.4.5 中断控制寄存器</a></li></ul></li></ul><ul><li><a href=#本文档的范围>本文档的范围</a></li><li><a href=#161-功能列表>16.1 功能列表</a></li><li><a href=#162-与tc2xx的差异>16.2 与TC2xx的差异</a></li><li><a href=#163-概述>16.3 概述</a></li><li><a href=#164-服务请求节点-srn>16.4 服务请求节点 (SRN)</a><ul><li></li><li><a href=#1613-中断路由器系统和模块寄存器>16.13 中断路由器系统和模块寄存器</a></li><li><a href=#使用的访问保护寄存器缩写列表>使用的访问保护寄存器缩写列表</a></li></ul></li></ul></nav></div></div></div></div></aside></div></main><footer class="footer mt-auto py-3 text-center container"><div class="offcanvas offcanvas-bottom h-auto" tabindex=-1 id=offcanvasActionsPanel aria-labelledby=offcanvasActionsPanelLabel><div class=offcanvas-header><div class="offcanvas-title h5" id=offcanvasActionsPanelLabel><i class="fas fa-fw fa-th-large me-1"></i>
操作</div><button type=button class="btn-close ms-auto" data-bs-dismiss=offcanvas data-bs-target=offcanvasActionsPanel aria-label=Close></button></div><div class="offcanvas-body mt-2"><div class="social-share mb-4 d-flex overflow-auto"><a class="btn-social-share d-flex flex-column align-items-center me-3" rel="noopener noreferrer" aria-label="X Share Button" target=_blank href="https://x.com/intent/tweet?title=Tc397%e4%b8%ad%e6%96%ad%e5%ad%90%e7%b3%bb%e7%bb%9f&url=https%3a%2f%2f6668688.xyz%2fdocs%2fcpu%2ftricore%2ftc397_interrupt%2f"><i class="fab fa-2x fa-fw fa-x-twitter mb-2"></i> X
</a><a class="btn-social-share d-flex flex-column align-items-center me-3" rel="noopener noreferrer" aria-label="Facebook Share Button" target=_blank href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2f6668688.xyz%2fdocs%2fcpu%2ftricore%2ftc397_interrupt%2f"><i class="fab fa-2x fa-fw fa-facebook-f mb-2"></i> Facebook</a></div><hr class=mb-4><div class="actions d-flex overflow-auto align-items-center"><a role=button class="action action-go-back d-flex flex-column align-items-center me-3" href="javascript: window.history.back();"><span class="action-icon mb-2"><i class="fas fa-2x fa-chevron-circle-down" data-fa-transform=rotate-90></i></span> 返回
</a><a role=button class="action action-reload-page d-flex flex-column align-items-center me-3"><span class="action-icon mb-2"><i class="fas fa-2x fa-redo-alt"></i></span> 刷新
</a><a role=button class="action action-copy-url d-flex flex-column align-items-center me-3"><span class="action-icon mb-2"><i class="fas fa-2x fa-link"></i></span> 复制链接</a></div></div></div><div class="row text-center"><div class="col-12 mt-2"><p class=mb-2></p><p class="text-secondary mb-2"><small></small></p><div class="copyright mb-2 text-secondary"><small>Copyright © 2025-2025 zcsaoe. All Rights Reserved.</small></div><div class="powered-by mb-2 text-secondary"><small></small></div><nav class="social-links nav justify-content-center mb-2 mt-3"><a class="nav-link social-link p-0 me-1 mb-2" href=mailto:appleeeeo@protonmail.com title=电子邮箱><i class="fas fa-fw fa-2x fa-envelope" style=color:#0963ac></i>
</a><a class="nav-link social-link p-0 me-1 mb-2" target=_blank href=https://github.com/zcsaoe title=GitHub rel=me><i class="fa-fw fa-2x fab fa-github"></i></a></nav></div><div class="col-12 col-lg-8 offset-0 offset-lg-1"></div></div></footer><script data-precache src=/assets/main/bundle.min.308b9e94cdf6f582d972dced59d1ae76c2f26d6c0bc4f02dfa8f9cbcc182cd33.js integrity="sha256-MIuelM329YLZctztWdGudsLybWwLxPAt+o+cvMGCzTM=" crossorigin=anonymous async></script><script data-precache src=/assets/icons/bundle.min.c97d69b111f6a09609591bb9a37c799bba2cae89ca786b5729e53ce6113cb90c.js integrity="sha256-yX1psRH2oJYJWRu5o3x5m7osronKeGtXKeU85hE8uQw=" crossorigin=anonymous defer></script><script data-precache src=/assets/viewer/bundle.min.945567884be417f2aa4a3f7fb0171fc00a214c3c63dd586d110fc7b77d4d6077.js integrity="sha256-lFVniEvkF/KqSj9/sBcfwAohTDxj3VhtEQ/Ht31NYHc=" crossorigin=anonymous defer></script><script src=/js/sw-register.js defer></script><script src=https://giscus.app/client.js data-repo=zcsaoe/zcsaoe.github.io data-repo-id=R_kgDOPDagAg data-category=General data-category-id=DIC_kwDOPDagAs4CsLxl data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous defer></script></body></html>