[{"authors":[],"categories":[],"content":" 基于armv7的设备，在qemu下启动，裸机运行\n文档资料 imx6ull 官方资料链接 Arm官方文档：\nARM Architecture Reference Manual ARMv7-A and ARMv7-R edition\nARM Cortex-A Series Programmer\u0026rsquo;s Guide for ARMv7-A\nArm A-profile Architecture Registers\nArm A-profile A32/T32 Instruction Set Architecture\nArm A-profile A64 Instruction Set Architecture\narm_compiler_user_guide_100748_6.22_00_en\nArm Architecture Reference Manual for A-profile architecture : (AArch64)\ngcc-arm-10.3-2021.07-x86_64-arm-none-eabi.tar.xz https://developer.arm.com/downloads/-/gnu-a\ngcc-arm-none-eabi-10.3-2021.10-x86_64-linux.tar.bz2 https://developer.arm.com/downloads/-/gnu-rm\nqemu环境搭建 qemu源码下载 100ask修改版qemu源码下载 100ask 6ullqemu # 本文运行方式，使用官方的qemu也能正常运行，只使用imx6ull的功能 git clone https://e.coding.net/weidongshan/ubuntu-18.04_imx6ul_qemu_system.git 6ull裸机开发资料 git clone https://e.coding.net/weidongshan/01_all_series_quickstart.git git clone https://e.coding.net/weidongshan/noos/cortexA7_windows_tools.git git clone https://e.coding.net/weidongshan/hardware/doc_and_source_for_hardware.git git clone https://e.coding.net/weidongshan/noos/doc_and_source_for_mcu_mpu.git编译器下载:arm-none-linux-gnueabihf\n# ，用 aria2c 比 wget 实在是快太多了 https://armkeil.blob.core.windows.net/developer/Files/downloads/gnu/13.2.rel1/binrel/arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-linux-gnueabihf.tar.xz armv7架构 寄存器 异常处理 lr的地址调整：关于ARM的PC指针 ==疑问：== armv7进入异常的时候根据规范描述是可以选择进入arm，或者thumb状态的？那么如果可以选择thumb编译的时候要按照thumb的格式编译\nA3：Application Level Memory Model 三种属性的设备： Normal Device Strongly-ordered 猜测：和 mmu，或者乱序执行有关？\nGeneral Timer 产生timer中断信号必须同时满足以下两个条件：\nCompareValue或者TimerValue计时时间到 timer必须enable且是unmask 消除timer中断信号只需要满是下面的其中一个条件即可：\n重新设置CompareValue或TimerValue寄存器，使其两个定时条件都不满足 使用timer掩码（CNTP_CTL.IMASK） 禁用timer（CNTP_CTL.ENABLE, 不再产出中断信号） 主要操作寄存器： CNTFRQ：读取设置频率\nCNTPCT：读取定时器的计数值（64位的）\nCNTP_CTL：控制寄存器（是否使能屏蔽定时器中断，状态指示是否发生中断）\nCNTP_CVAL：设置定时器的计时时间（64位，向上加）\n用法如：setTimer(getSystemTick()+delayTick)\nCNTP_TVAL：设置定时器的计时时间（32位有符号，向下减）\n用法如：setTimer(delayTick)\nCortex A7 gic 中断源ID： Software Generated Interrupts：0-15\nPrivate Peripheral Interrupts：16-31\n安全物理定时器ID：29\n非安全物理定时器ID：30\nShared Peripheral Interrupts ：32-1019，支持480个 （cortexa7,179）\n特殊中断ID GIC memory-map Memory regions used for these registers must be marked as Device or Strongly-ordered in the translation tables.\nMemory regions marked as Normal Memory cannot access any of the GIC registers, instead access caches or external memory as required ？？\n优先级：32级 GICC_BPR -\u0026gt;0,所有支持抢占，-\u0026gt;7，所有非抢占模式\ngic寄存器 0x000: RW: GICD_CTLR: 控制寄存器，是否使能 gic distributor\n0x004: RO: GICD_TYPER: bit5-7,支持的cpu数量+1，bit0-4,gic支持的中断个数x32\n0x008: RO: GICD_IIDR: bit24-31，ProductId，bit16-19,产品编号？bit12-15,revision num, [bit0-6,0x3b,bit7,0,bit8-11,0x4]\n0x080: RW: GICD_IGROUPRn: 0,Group0,1,Group1, 0x080+(n\u0026raquo;5)\u0026laquo;2, n\u0026amp;0x1F\n0x100: RW: GICD_ISENABLERn: 0,interrupt is disabled, 1,interrupt is enable; 写1-\u0026gt;1\n0x180: RW: GICD_ICENABLERn: 禁中断 0,disabled, 1,enabled; 写1-\u0026gt;0\n0x200: RW: GICD_ISPENDRn: 0,no pending,1,ppi/swi pending on this cpu, spi pending any cpu\n写1, edge: inactive-\u0026gt;pending; acitve-\u0026gt;active and pending; pending-\u0026gt;pending\nlevel: inactive-\u0026gt;pending; active-\u0026gt;active and pending; pending-\u0026gt;pending\n0x280: RW: GICD_ICPENDRn: 0,no pending,1,ppi/swi pending on this cpu, spi pending any cpu\n写1, edge: pending-\u0026gt;inactive; active and pending-\u0026gt;active\nlevel: pending-\u0026gt;inactive; active and pending-\u0026gt;active ? todo\n0x300: RW: GICD_ISACTIVERn: 0, not active, 1,active; 写1-\u0026gt;1\n0x380: RW: GICD_ICACTIVERn: 0, not active, 1,active; 写1-\u0026gt;0\n0x400: RW: GICD_IPRIORITYRn: 设置优先级 0, proiority0,1,2,3 0x400+(m\u0026raquo;2)\u0026laquo;2 (m\u0026amp;0x3)*8\n0x800: RW: GICD_ITARGETSRn: 绑定cpu，0, target cpu, byte0,1,2,3, each byte:cpu/isr\nGICD_ITARGETSR0-7,只读的（id0-31，swi中断）其他spi可写\n0xc00: RW: GICD_ICFGRn: low,0,N-N,1,1-N; high, 0,level,1,edge 0xc00+(m\u0026raquo;4)*4 (m\u0026amp;0xf)*2\n0xe00: RW: GICD_NSACRn: 0,no-secure\n0xf00: RO：GICD_SGIR: 软件参数中断，bit24-25,0,CPUTargeList，1，其他cpu，2，to self，bit16-23,target cpu,bit-cpu;\nbit15,0,SGIINTID,Group0,1,Group1;bit0-3,Interrupt id 0-15\n0xf10: RW: GICD_CPENDSGIRn: byte0,1,2,3; 0,not pending, 1,pending; write 1, remove pending ?\n0xf20: RW: GICD_SPENDSGIRn: byte0,1,2,3; 0,not pending, 1,pending; write 1, add pending ?\n0x0000: RW: GICC_CTLR: bit0:0,禁用中断信号，1使能中断信号\n0x0004: RW: GICC_PMR: 中断优先级掩码 bit0-7,bit0:128 bit0-1:64 bit0-2:32 bit0-3:16\n0x0008: RW: GICC_BPR：中断group分割点 bit0-2\n0x000c: RO: GICC_IAR: 响应的中断号，bit10-12,swi请求中断的cpu，bit0-9，中断id\n0x0010：WO：GICC_EOIR：中断处理完成，bit10-12,同上，同上\n0x0014: RO: GICC_RPR: bit0-7，当前运行的中断优先级\n0x0018: RO: GICC_HPPIR: 最高pending的优先级，bit10-12，swi产生中断的cpu，bit0-9：最高pending中断id\n0x001c: RW: GICC_ABPR:\n0x0020: RO: GICC_AIAR:\n0x0024: WO: GICC_AEOIR:\n0x0028: RO: GICC_AHPPIR:\n0x00d0: RW: GICC_APRn:\n0x00e0: RW: GICC_NSAPRn:\n0x00fc: RO: GICC_IIDR：读取productid, gic版本\n0x1000：WO：GICC_DIR:\n操作方法：\nGICD_TYPER：获取支持的中断信息 GICD_ICENABLERn：禁止中断转发 GICC_PMR：设置中断掩码 GICC_BPR：设置group，Subpriority（0,全抢占，7，禁止抢占） GICD_CTLR：使能 GICC_CTLR：使能 MMU相关 多核之间的操作全局变量的问题？\n如何保证数据是最新的，手动刷缓存？\na . memory type中有三种概念，是不是把全局变量定位到device区域，就不需要考虑缓存的问题了 硬件支持，只要写全局变量，自动处理，用户无感？ arm寄存器 cpsr N, bit[31] Negative condition flag. Z, bit[30] Zero condition flag. C, bit[29] Carry condition flag. V, bit[28] Overflow condition flag. A, bit[8] Asynchronous abort mask bit. I, bit[7] IRQ mask bit. F, bit[6] FIQ mask bit. 0 Exception not masked. 1 Exception masked T, bit[5] Thumb execution state bit J\tT 0\t0\tARM 0\t1\tThubm 1\t0 Jazelle 1\t1 ThumbEE M[4:0], bits[4:0] Mode field User\t10000 FIQ\t10001 IRQ\t10010 Supervisor\t10011 Monitor\t10110 Abort\t10111 Hyp\t11010 Undefined\t11011 System\t11111 汇编指令 c嵌汇编 ( Mixing C and assembly code ) ARM64基础4：在C语言中嵌入ARM64汇编代码\n__asm__ [__volatile__] ( assembler template : [output operand list] /* optional */ : [input operand list] /* optional */ : [clobbered register list] /* optional */ ); 伪指令 global：别的文件可以调用当前汇编文件里的函数\nextern：当前汇编可以调用别的文件的函数\nthumb: 指令来指明接下来的代码应以 Thumb 模式进行汇编\n条件执行 A8.3 Conditional execution msr srs rfe 编译链接 ARM链接脚本详解\nlinker script ld链接脚本语法简介\nGCC Arm 12.2编译提示 LOAD segment with RWX permissions 警告\n–start-group 和 –end-group 功能作用 做了哪些工作 设置异常向量表 设置模式下的sp，关mmu、icache、dcache 初始化gic（distribution，cpuifterface） 设置arch time 初始化串口 两个task进行任务切换，实现中。。。 qemu启动，task调度代码 使能arch timer 初始化 uart，支持printf打印 支持添加task，task循环调度，上下文切换，任务栈保存恢复 tree ├── build.sh # 编译执行，可能需要调整编译器路径 ├── CMakeLists.txt ├── lib │ ├── gic.c │ ├── gic.h │ ├── timer.c │ ├── timer.h │ ├── uart.c │ └── uart.h ├── out ├── qemu.sh # qemu执行脚本 └── src ├── link.ld ├── main.c ├── my_printf.c ├── my_printf.h ├── start.S └── task_test.c 参考文章 在线脑图工具 processon\nqemu嵌入式arm快速体验\nQEMU imx6ul开发板环境搭建\n百问网资料下载中心\nuboot源码\nqemu很老的例程\ngithbub文档语法\n【从0学ARM】你不了解的ARM处理异常之道\n视频\nSTM32:从0写RTOS,学习内部机制\n文档介绍\n记录问题 armv7需要设置异常向量表，即 VBAR 寄存器 在上电reset_handler中调用svc #0无法调转swi_handler，所以才发现需要设置异常向量中断 arm arch timer 每个核上的timer一直是在计数的，设置中断信号之后，要在中断函数中更新CompareValue或TimeValue的值 无法通过通过cp15读取gic基地址 ？, Configuration Base Address Register, （cortexa7，p137） MRC p15, 4, , c15, c0, 0; Read Configuration Base Address Register 读取cpuid，MPIDR MRC p15, 0, , c0, c0, 5; Read Multiprocessor Affinity Register 5. 调试阶段发现有些代码执行异常，比如c和汇编相互调用的时候，发现可能是armv7支持thumb造成的，-marm强制arm态 6. task栈切换 task中添加uint64变量执行异常（Undefined_Handler） 分析汇编代码发现了vmov指令，在编译选项中添加 -mfpu=vfpv3解决，vfpv3和neon的区别是啥呢？ arm编译器的区别 遇到编译链接问题，注意到编译器不一样，记录一下\n9. c 函数库 （newlic 和 glic） C 函数库 （libc,glibc,uClibc,newlib）\n遇到一个编译很坑的问题，查了好久发现是 project enable_language 和 设置编译器，先后顺序导致的问题 此案例中，先设置project(IMX6ULL ASM C)，后设置编译器即可解决问题 那么是如何发现的问题呢，因为我开始的时候用的是 arm-none-linux-gnueabihf-gcc 编译freertos，测试qemu启动，简单的task切换都没有问题，然后开始加入freertos源码，编译就出现一堆奇怪的问题（undefined reference __gcc_personality_v0 / __aeabi_unwind_cpp_pr0）等一大堆问题，先是问了人工智能改了一大圈也无果 后面我发现其他工程用的编译器是 arm-none-eabi-gcc（上述问题8）, 换了之后直接报错 \u0026lt; is not able to compile a simple test program. undefined reference to `_exit\u0026rsquo; \u0026gt;, 对我来说有是一个奇怪的问题 根据ai的回答，加上_exit函数也不行，后面我就用cmake写了一个最小编译环境，和我工程交叉测试发现了问题所在，不过根本原因也没深究，也可能只是碰巧解决了问题吧\nVERBOSE=1，编译详细日志\nCMAKE_EXE_LINKER_FLAGS_xxx 和 CMAKE_BUILD_TYPE CMAKE_\u0026lt;LANG\u0026gt;_FLAGS_\u0026lt;CONFIG\u0026gt; , 测试发现 CMAKE_BUILD_TYPE (release，debug，或者自定义标签)，会决定前面的\u0026lt;CONFIG\u0026gt;,\nCmake笔记\n12. xxxx.c.obj 和 xxx.c.o 生成差异\nCMAKE_SYSTEM_NAME 变量用于设置目标系统的操作系统。不同的操作系统通常有不同的编译工具链和库路径。通过设置 CMAKE_SYSTEM_NAME，你告诉CMake期望的目标系统是什么，这影响了CMake配置过程中的行为。例如： Windows、Linux、Darwin（macOS）、Generic（通常用于裸机或嵌入式系统）\nset(CMAKE_SYSTEM_NAME Generic) set(CMAKE_SYSTEM_PROCESSOR arm) 测试设置之后会生成obj后缀文件\ngcc 链接 和 ld 链接异同点 安装的 arm-none-eabi-gdb 报错：libncurses.so.5: cannot open shared object file: No such file or directory 网上的答案 sudo apt install libncurses5* 搞定，不知道是不是我的最新ubuntu24的问题，找不到下载源，所有就手动下载安装\nubuntu lib库下载地址：https://packages.ubuntu.com/ http://security.ubuntu.com/ubuntu/pool/universe/n/ncurses/libncurses5_6.2-0ubuntu2.1_amd64.deb http://security.ubuntu.com/ubuntu/pool/universe/n/ncurses/libtinfo5_6.2-0ubuntu2.1_amd64.deb 版本：6.2-0ubuntu2.1， 架构：i386，amd64\n64位电脑只需要 amd64，旧的gdb版本需要libncurses5, Distribution选择any\n基于imx6ull的sdk，在qemu上实现freertos，编译正常，运行的时候 portYIELD_WITHIN_API 这个就崩了，其实调用svc异常,主要分析定位异常原因 根本原因是问题1，未设置vbar寄存器，如何定位呢，\n首先肯定可以定位到哪一行的代码执行异常 在执行异常代码的时候切换到汇编代码查看，可以分析异常原因，比如此异常时候，跳到了0x000000c8, 这个地址是不正常的（由汇编文件可以分析向量地址0x80002008），就能知道是哪里的异常了 is not able to compile a simple test program https://discourse.cmake.org/t/ the-c-compiler-is-not-able-to-compile-a-simple-test-program-when-compiling-using-arm-gnu-toolchain/8215\nset(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY) 即可\n","date":"2025年7月19日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/arm/armv7-qemu/","series":[],"smallImg":"","tags":[],"timestamp":1752896693,"title":"Armv7 Qemu"},{"authors":[],"categories":[],"content":"IMX6ULL裸机启动，IMX6ULL运行FreeRTOS，源代码分析\n裸机启动部分 imx6ull中根据运行代码位置的不同RAM/flash/SD卡，上电会先运行片上ROM中的代码，搬运的数据大小是不同的，代码也不是存储在0地址处的。如下图，比如从sd中运行代码，代码IVToffset大小1k，initloadSize为4k。 实质上应用程序前红色框中的大小有3k，可以配置启动信息，入口地址，初始化设备，基本的时钟，DDR要先初始化才能使用吧。具体的可以参考其他资料如百问网的imx6ull手册 韦老师的裸机代码中，写好的程序是调用mkimage给app程序加上特有的头部信息，配合其开发的烧录工具100ask_imx6ull_flashing_tool可以下载到ram运行（*.imx文件）。如果想下载sd中，需要在imx文件前面加上1k的偏移（image vector table offset）\nmkimage -n ./tools/imximage.cfg.cfgtmp -T imximage -e 0x80200000 -d led.bin led.imx // -e 0x80200000程序会被搬运到的位置其他的开发板如，原子的imxdownload工具中直接固定了加载地址为0X87800000，链接脚本中也是这个地址，如不地址不相同，就会牵扯到代码重定位的问题。 但也有可能有人设置的就是不一样的地址，照样能跑下去，这就要看start.s中的跳转指令是\nldr sp, =main /* 跳转到main函数 */ b main /* 跳转到main函数 */链接地址和加载地址不一样的情况： 如果是第一行的话就无法运行，地址相关代码 如果第二行的话就代码可以部分运行，比如打印定义好的全局变量就不正常了，data区没有搬运到相应的链接地址去。\nIMX6ULL运行FreeRTOS imx6ull有官网的skd，里面已经有一些例子。 第一步： SDK_2.2_MCIM6ULL/boards/evkmcimx6ull/demo_apps/hello_world/armgcc中直接运行 ./build_ddr_debug.sh\nSDK_2.2_MCIM6ULL/boards/evkmcimx6ull/demo_apps/hello_world/armgcc# ./build_ddr_debug.sh第二步：\nmkimage -n ./tools/imximage.cfg.cfgtmp -T imximage -e 0x80002000 -d led.bin led.imx注意：-e 地址 为 0x80002000\n第三步： 利用100ask_imx6ull_flashing_tool下载到imx6ull上面运行就会看到串口打印的\nhello world. 买到板子之后不久就一直想在imx6ULL上面跑rtos，结果也没找到啥教程，有人说cortexa7的可以参看a9的移植，无奈还是懵，后来想看看FreeRTOS源码之后在动手，结果发现简单看了源码还是菜到没头绪。 中间玩玩裸机程序，突然有两天就想研究一下，imx上程序从编译好到下载到板子上是怎么运行的，为啥我编译的sdk代码不可以用，后面就发现rtos的demo代码可能启动位置不对，根据连接脚本中的信息链接地址为0x80002000 SDK_2.2_MCIM6ULL/boards/evkmcimx6ull/rtos_examples 目录中有些例子，只要编译后，加上imx头部信息，就可以愉快的在imx6ull上面跑FreeRTOS了， 后续看看我的板子怎么能在FreeRTOS基础上跑lwip\n代码重定位 关于代码重定位。\nAPI总览 @startmindmap + FreeRTOS ++ Task Creation +++_ xTaskCreate +++_ xTaskCreateStatic +++_ vTaskDelete +++_ xTaskGetStaticBuffers ++ Task Control +++_ vTaskDelay +++_ vTaskDelayUntil +++_ xTaskDelayUntil +++_ uxTaskPriorityGet +++_ uxTaskPriorityGetFromISR +++_ uxTaskBasePriorityGet +++_ uxTaskBasePriorityGetFromISR +++_ vTaskPrioritySet +++_ vTaskSuspend +++_ vTaskResume +++_ xTaskResumFromISR +++_ xTaskAbortDelay ++ Task Utilities +++_ uxTaskGetSystemState +++_ vTaskGetInfo +++_ xTaskGetApplicationTaskTag +++_ xTaskGetCurrentTaskHandle +++_ xTaskGetHandle +++_ xTaskGetIdleTaskHandle +++_ uxTaskGetStackHighWaterMark +++_ eTaskGetState +++_ pcTaskGetName +++_ xTaskGetTickCount +++_ xTaskGetTickCountFromISR +++_ xTaskGetSchedulerState +++_ uxTaskGetNumberOfTasks +++_ vTaskList +++_ vTaskStartTrace +++_ ulTaskEndTrace +++_ vTaskGetRunTimeStats +++_ vTaskSetApplicationTaskTag +++_ xTaskCallApplicationTaskHook +++_ vTaskSetThreadLocalStoragePointer +++_ pvTaskGetThreadLocalStoragePointer +++_ vTaskSetTimeoutState +++_ xTaskCheckForTimeOut ++ RTOS Kernel Control +++_ taskYIELD Colors +++_ taskENTER_CRITICAL +++_ taskEXIT_CRITICAL +++_ taskENTER_CRITICAL_FROM_ISR +++_ taskEXIT_CRITICAL_FROM_ISR +++_ taskDISABLE_INTERRUPTS +++_ taskENABBLE_INTERRUPTS +++_ vTaskStartScheduler +++_ vTaskEndScheduler +++_ vTaskSuspendAll +++_ vTaskResumeAll +++_ vTaskStepTick +++_ xTaskCatchUpTicks ++ Direct To Task Notifications +++_ xTaskNotifyGive/xTaskNotifyGiveIndexed +++_ vTaskNotifyGiveFromISR +++_ ulTaskNotifyTake +++_ xTaskNotify +++_ xTaskNotifyAndQuery +++_ xTaskNotifyAndQueryFromISR +++_ xTaskNotifyFromISR +++_ xTaskNotifyWait +++_ xTaskNotifyStateClear +++_ ulTaskNotifyValueClear ++ Queues +++_ xQueueCreate +++_ xQueueCreateStatic +++_ xQueueDelete +++_ xQueueSend +++_ xQueueSendFromISR +++_ xQueueSendToBack +++_ xQueueSendToBackFromISR +++_ xQueueSendToFront +++_ xQueueSendToFrontFromISR +++_ xQueueReceive +++_ xQueueReceiveFromISR +++_ uxQueueMessagesWaiting +++_ uxQueueMessagesWaitingFromISR +++_ uxQueueSpacesAvailable +++_ xQueueReset +++_ xQueueOverwrite +++_ xQueueOverwriteFromISR +++_ xQueuePeek +++_ xQueuePeekFromISR +++_ vQueueAddToRegistry +++_ vQueueUnregisterQueue +++_ pcQueueGetName +++_ xQueueIsQueueFullFromISR +++_ xQueueIsQueueEmptyFormISR +++_ xQueueGetStaticBuffers +++_ xQueue +++_ xQueue +++_ xQueue +++_ xQueued +++_ xQueuedd ++ Queue Sets +++_ xQueueCreateSet +++_ xQueueAddToSet +++_ xQueueRemoveFromSet +++_ xQueueSelectFromSet +++_ xQueueSelectFromSetFromISR -- Stream Buffers ---_ xStreamBufferCreate/xStreamBufferCreateWithCallback ---_ xStreamBufferCreateStatic/xStreamBufferCreateStaticWithCallback ---_ xStreamBufferSend ---_ xStreamBufferSendFromISR ---_ xStreamBufferReceive ---_ xStreamBufferReceiveFromISR ---_ xStreamBufferDelete ---_ xStreamBufferBytesAvailable ---_ xStreamBufferSpacesAvailable ---_ xStreamBufferSetTriggerLevel ---_ xStreamBufferReset ---_ xStreamBufferResetFromISR ---_ xStreamBufferIsEmpty ---_ xStreamBufferIsFull ---_ xStreamBufferGetStaticBuffers ---_ uxStreamBufferGetStreamBufferNotificationIndex ---_ xStreamBufferSetStreamBufferNotificationIndex ---_ xStreamBatchingBufferCreate ---_ xStreamBatchingBufferCreateStatic -- Message Buffers ---_ xMessageBufferCreate ---_ xMessageBufferCreateStatic ---_ xMessageBufferSend ---_ xMessageBufferSendFromISR ---_ xMessageBufferReceive ---_ xMessageBufferReceiveFromISR ---_ xMessageBufferReset ---_ xMessageBufferResetFromISR ---_ xMessageBufferIsEmpty ---_ xMessageBufferIsFull ---_ xMessageBufferGetStaticBuffers -- Semaphore / Mutexes ---_ xSemaphoreCreateBinary ---_ xSemaphoreCreateBinaryStatic ---_ vSemaphoreCreateBinary ---_ xSemaphoreCreateCounting ---_ xSemaphoreCreateCountingStatic ---_ xSemaphoreCreateMutex ---_ xSemaphoreCreateMutexStatic ---_ xSemaphoreCreateRecursiveMutex ---_ xSemaphoreCreateRecursiveMutexStatic ---_ vSemaphoreDelete ---_ xSemaphoreGetMutexHolder ---_ xSemaphoreGetCount ---_ xSemaphoreTake ---_ xSemaphoreTakeFromISR ---_ xSemaphoreTakeRecursive ---_ xSemaphoreGive ---_ xSemaphoreGiveRecursive ---_ xSemaphoreGiveFromISR ---_ xSemaphoreGetStaticBuffer -- Software Timers ---_ xTimerCreate ---_ xTimerCreateStatic ---_ xTimerIsTimerActive ---_ xTimerStart ---_ xTimerStop ---_ xTimerChangePeriod ---_ xTimerDelete ---_ xTimerReset ---_ xTimerStartFromISR ---_ xTimerStopFromISR ---_ xTimerChangePeriodFromISR ---_ xTimerResetFromISR ---_ pvTimerGetTimerID ---_ vTimerSetReloadMode ---_ vTimerSetTimerID ---_ xTimerGetTimerDaemonTaskHandle ---_ xTimerPendFunctionCall ---_ xTimerPendFunctionCallFromISR ---_ xTimerGetName ---_ xTimerGetPeriod ---_ xTimerGetExpiryTime ---_ xTimerGetReloadMode -- Event Groups ---_ xEventGroupCreate ---_ xEventGroupCreatxeStatic ---_ vEventGroupDelte ---_ xEventGroupWaitBits ---_ xEventGroupSetBits ---_ xEventGroupSetBitsFromISR ---_ xEventGroupClearBits ---_ xEventGroupClearBitsFromISR ---_ xEventGroupGetBits ---_ xEventGroupSync ---_ xEventGroupGetStaticBuffer -- MPU ---_ xTaskCreateRestricted ---_ xTaskCreateRestrictedStatic ---_ vTaskAllocateMPURegions ---_ portSWITCH_TO_USER_MODE -- Co-routines ---_ xCoRoutineCreate ---_ crDELAY ---_ crQUEUE_SEND ---_ crQUEUE_RECEIVE ---_ crQUEUE_SEND_FROM_ISR ---_ crQUEUE_RECEIVE_FROM_ISR ---_ vCoRoutineSchedule ---_ vCoRoutineResetState @endmindmap FreeRTOS源代码分析 任务切换 @startuml start fork :Irq Handler; split :other iar func; split again :timer tick func; note right FreeRTOS_Tick_Handler xTaskIncrementTick(超时任务，从delay，event list删除，加入ready list) 如果 xTickCount 溢出，累加 xNumOfOverflows delay到期的任务高于当前优先级，时间片轮转，xYieldPending=true（其他任务抢占需要调度） ulPortYieldRequired = true end note end split if (ulPortYieldRequired == true) then (false) :irq return; else (yes) :save_context_and_switch; note right bl vTaskSwitchContextConst (vTaskSwitchContext) uxSchedulerSuspended != flase 挂起 os 不允许调度 xYieldPending = 0 一个标志位吧，其他需要调度的时候置1 设置新的 pxCurrentTCB，（软件，clz方式找到最高优先级） 就可以恢复当前task上下文，完成任务切换 end note endif fork again :FreeRTOS_SWI_Handler; :save_context bl vTaskSwitchContextConst restroe_context; end merge stop @enduml vTaskDelay @startuml start :vTaskDelay; :vTaskSuspendAll; note right ++uxSchedulerSuspended end note if (xTicksToDelay \u003e 0) then (yes) :prvAddCurrentTaskToDelayedList; note right 设置delay到期时间，更新 xNextTaskUnblockTime end note :xTaskResumeAll; note right --uxSchedulerSuspended， 为0往下继续处理 xPendingReadyList 处理pending list中task，加入ready list 当有任务大于当前优先级，需要任务切换 设置 xYieldPending=true，更新 xNextTaskUnblockTime 补偿系统tick，uxPendedTicks xAlreadyYielded = xTaskIncrementTick() 如果已经有其他task请求切换了，当前就无需再请求切换了 xYieldPending 会在 vTaskSwitchContext 设置 false end note else :xAlreadyYielded = false; endif if (xAlreadyYielded = false) then (yes) :portYIELD_WITHIN_API; note right delay参数为0，强制执行调度 portYIELD __asm volatile ( \"SWI 0\" ) end note else (no) endif stop @enduml xQueueGenericReceive @startuml start :xQueueGenericReceive; repeat :taskENTER_CRITICAL(); if (uxMessagesWaiting \u003e0) then(yes) note right 队列里的元素数量 end note :记录读数据的位置，receive数据会出队，peek只是读数据; :prvCopyDataFromQueue(); note right 读的索引后移一个uxItemSize，如果到tail，再指向head copy一个uxItemSize的数据到pvBuffer中 end note if (xJustPeeking == pdFALSE) then(yes) :当前为receive模式，读了数据之后就更新读指针，相当于出队操作; :当前queue有互斥锁，指向当前的运行task pxCurrentTCB-\u003euxMutexesHeld++; :判断当前queue的 xTasksWaitingToSend 不为空的话; :xTaskRemoveFromEventList(); note left 移除发送队列，os未挂起就加入readylist，挂起加加入pendingreadlist 优先级大的话，设置task调度标志 end note else :当前模式可以一直读队首的数据，不会出队; :恢复上面记录的数据读位置; :判断当前queue的 xTasksWaitingToReceive 不为空的话; :xTaskRemoveFromEventList(), task是否加入readlist的处理，是否切换task等; endif :taskEXIT_CRITICAL(); :return pdPASS; stop else (队列为空) if (xTicksToWait==0) then (等待时间为0) :taskEXIT_CRITICAL(); :return errQUEUE_EMPTY; stop elseif (xEntryTimeSet == pdFALSE) then(等待时间不为0) :vTaskSetTimeOutState(); note right xEntryTimeSet = true 记录 xNumOfOverflows xTickCount 为后面判断delay做准备 end note endif endif :taskEXIT_CRITICAL(); :; :vTaskSuspendAll(); :prvLockQueue(), rx tx加互斥锁; if ( xTaskCheckForTimeOut()== pdFALSE) then (yes) note right 根据xTimeOut pxTicksToWait判断是否延时时间到 延时时间到返回true，否则返回false，并更新vTaskSetTimeOutState( pxTimeOut ); end note :当前wait时间没有超时; if (队列是否为空) then (yes) :互斥锁，进入临界区，修改task优先级，优先级继承机制; note left vTaskPriorityInherit() 持有锁的taskA优先级低于当前task优先级，调整taskA的优先级 锁的持有者可能为null，意味中当前在isr上下文 end note :vTaskPlaceOnEventList; note right insert event list 加入delay list中 end note :prvUnlockQueue(); if (xTaskResumeAll() == false) then (yes) :调用 svc 切换task; endif else :prvUnlockQueue(); :xTaskResumeAll(); endif else :当前时间已经超时,等待结束了，有数据就返回数据，没有就返回空; :prvUnlockQueue(); :xTaskResumeAll(); if (队列 uxMessagesWaiting 是否为空) then (yes) :return errQUEUE_EMPTY; stop else :非空的话,继续下一个循环; endif endif repeat while () @enduml xQueueGenericSend @startuml start :xQueueGenericSend; repeat :taskENTER_CRITICAL(); if (队列有空闲 || 覆盖写) then(yes) note right 队列里的元素数量 end note :记录读数据的位置，receive数据会出队，peek只是读数据; :xYieldRequired = prvCopyDataToQueue(); note left 1. uxItemSize = 0可能表示互斥锁，需要调整恢复task优先级 xTaskPriorityDisinherit 2. queueSEND_TO_BACK，pcWriteTo+uxItemSize 3. queueSEND_TO_FRONT 先写后调整位置pcReadFrom-uxItemSize pcReadFrom指向的是空 4. queueOVERWRITE，有点坑，只能用在队列长度为1的场景中（无法执行，否则队列中就会存在无效的值） end note if (configUSE_QUEUE_SETS) then (yes) :prvNotifyQueueSetContainer; note left 1. prvCopyDataToQueue,这里把当前queue放入set中 队列集上有等待接收的task，xTaskRemoveFromEventList 唤醒的task高于当前task优先级，则抢占运行 2. set为null场景，判读是否有等待接收task，逻辑同上 end note else :没有配置队列集; if (xTasksWaitingToReceive 非空) then (yes) :xTaskRemoveFromEventList; :如果高优先级task，则抢占运行; else if (xYieldRequired = true) then note left 只有互斥锁的时候才有可能到达这里，因为优先级继承 发送数据的时候会恢复优先级 end note :抢占; endif endif :taskEXIT_CRITICAL(); :return pdPASS; stop else (队列已满) if (xTicksToWait==0) then (等待时间为0) :taskEXIT_CRITICAL(); :return errQUEUE_EMPTY; stop elseif (xEntryTimeSet == pdFALSE) then(等待时间不为0) :vTaskSetTimeOutState(); note right xEntryTimeSet = true 记录时间戳 xNumOfOverflows xTickCount 为后面判断delay做准备 end note endif endif :taskEXIT_CRITICAL(); :; :vTaskSuspendAll(); :prvLockQueue(), rx tx加互斥锁; if ( xTaskCheckForTimeOut()== pdFALSE) then (yes) note right 根据xTimeOut pxTicksToWait判断是否延时时间到 延时时间到返回true，否则返回false，并更新vTaskSetTimeOutState( pxTimeOut ); end note :当前wait时间没有超时; if (队列是否已满) then (yes) :互斥锁，进入临界区，修改task优先级，优先级继承机制; :vTaskPlaceOnEventList; note left 加入待发送队列 xTasksWaitingToSend，xEventListItem 从当前优先级队列移除，加入 delaylist， xStateListItem end note :prvUnlockQueue(); if (xTaskResumeAll() == false) then (yes) :调用 svc 切换task; endif else :prvUnlockQueue(); :xTaskResumeAll(); endif else :当前时间已经超时,等待结束了; :prvUnlockQueue(); :xTaskResumeAll(); :return errQUEUE_FULL; note right #yellow 为啥这里直接返回，不判断队列是否已满 有空闲的话，进行下一次循环呢？？ end note stop endif repeat while () @enduml 参考 PlantUML 语言参考指引\nPlantUML 快速入门指南\nFreeRTOS开发者文档\n","date":"2025年7月19日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/arm/imx6ull-freertos/","series":[],"smallImg":"","tags":[],"timestamp":1752896623,"title":"Imx6ull FreeRTOS"},{"authors":[],"categories":[],"content":"autosar vector candb工具\n精选文章 AUTOSAR精选文章推荐\n如何快速学习AUTOSAR?\ntoppers\ntoppers.atk2\n【Autosar】学习总结-BSW层_autosar bsw-CSDN博客\n","date":"2025年7月9日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/autosar/autosar/","series":[],"smallImg":"","tags":[],"timestamp":1752045220,"title":"Autosar"},{"authors":[],"categories":[],"content":"","date":"2025年7月8日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/onlinetools/calculator/","series":[],"smallImg":"","tags":[],"timestamp":1751987502,"title":"计算器"},{"authors":[],"categories":[{"title":"嵌入式架构","url":"/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9E%B6%E6%9E%84/"}],"content":" tc397学习资料\nInfineon 相关资料： 开发板套件介绍页面：https://www.infineon.com/cms/en/product/evaluation-boards/kit_a2g_tc397_5v_tft/\n开发板说明文档：Application Kit Manual TC3X7， ASCLIN_Shell_UART_1_KIT_TC397_TFT TC3xx系列总览： 32-bit TriCore™ AURIX™– TC3xx\n用户手册： AURIX™ TC39x User Manual 示例代码： Infineon/AURIX_code_examples\n英飞凌汽车电子生态圈：https://www.infineon.com/cms/cn/partners/partner-ecosystems/greater-china/autoeco/\n选型： 命令规则： \u0026lt; Infineon-Microcontroller_Pocket_Guide_2022-ProductSelectionGuide-v02_00-EN.pdf \u0026gt;\nTriCore架构 Infineon-AURIX_TC3xx_Architecture_all-UserManual-v01_00-EN.pdf\nTriCore是一种统一的、单核的32位微控制器-DSP架构，专为实时嵌入式系统优化。TriCore指令集架构（ISA）结合了微控制器的实时能力、DSP的计算能力和RISC加载/存储架构的高性能/价格特点，并且具有紧凑的可重编程核心\n统一32位地址空间，包含可选的虚拟地址和内存映射I/O 支持16位和32位指令格式，16位指令是32位指令的子集，因其使用频率高才选择。这些指令显著减少了代码空间，降低了内存需求、系统和功耗 实时响应能力主要由中断延迟和上下文切换时间决定，避免长的多周期指令和提供灵活的硬件支持中断方案来最小化中断延迟 支持快速上下文切换 小端字节序：data memory and CPU registers EABI传参 2.2.3 Argument Passing1\n用于 非指针类型（例如 int, float, char 等） 的寄存器： D4, D5, D6, D7 用于 指针类型（例如 char*, int*, struct* 等） 的寄存器： A4, A5, A6, A7 CALL 和 RET自动保存/恢复这些寄存器： D8–D15, A10–A15 task切换只需手动保存lower context即可\n返回值\n2.2.5 Return Values\n包括 int, float, char, bool 等类型\nD2 64-bit 标量\n使用 E2，即 D2:D3 32-bit 指针类型\n使用 A2 64-bit 指针\nA2:A3 小于等于 32-bit 的结构体\nD2 大小在 33 ~ 64-bit 的结构体\nA2:A3 大于 64-bit 的结构体\n调用者（caller）分配返回结构体所需的缓冲区 寄存器： 通用寄存器：32个 数据寄存器 (D[0] - D[15]): 用于存储和处理数据\n地址寄存器 (A[0] - A[15]): 用于存储和操作内存地址\nA[10]、A[11]、A[15]、D[15]这4个通用寄存器还有特殊功能：\nA[10]：栈指针寄存器Stack Pointer (SP) register\nA[11]：返回地址寄存器Return Address (RA) register\nA[15]：隐式基地址寄存器Implicit Address register\nD[15]：隐式数据寄存器Implicit Data register\nA[0]、A[1]、A[8]、A[9]是系统全局寄存器：\n函数调用、中断发生过程中，上下文的Save和Restore不会存储这4个寄存器中的信息\n其他功能寄存器 DEA (Data Error Address Register):记录触发异常的内存地址（对于数据访问异常，如空指针或写只读区域） DSTR (Data Synchronous Trap Register):提供数据访问异常的详细信息 FCX (Free Context List Pointer):指向可用上下文保存区域，可能用于检查上下文是否耗尽（可能导致异常） Register Name Description AddressOffset PCXI2 Previous Context Information Register FE00 PSW3 Program Status Word Register FE04 CPU_ID CPU Identification Register (Read Only) FE18 CORE_ID Core Identification Register FE1C BIV4 Base Interrupt Vector Table Pointer FE20 BTV5 Base Trap Vector Table Pointer FE24 ISP Interrupt Stack Pointer Register FE28 ICR6 ICU Interrupt Control Register FE2C Trap System 处理各种异常事件，如不可屏蔽中断（NMI）、指令异常或非法访问，不能被软件屏蔽，trap一直是使能的\ntrap类型： TriCore架构将陷阱分为八个类别，每个类别进一步分为同步或异步、硬件或软件陷阱。每个陷阱都有一个陷阱识别号（Trap Identification Number, TIN），用于在其类别内标识陷阱的原因。当陷阱被捕获时，陷阱识别号 TIN 会放置在数据寄存器D[15]中\nD15的低六位中\nMMU (Memory Management Unit) 陷阱: 与内存管理单元相关的异常，如内存访问违例。 内部保护陷阱: 保护机制引发的异常，如权限问题。 指令错误陷阱: 指令执行过程中发生的错误，如非法指令。 上下文管理陷阱: 与任务上下文切换相关的异常。 系统总线和外设陷阱: 系统总线和外设引发的异常。 断言陷阱: 程序中断言失败引发的异常。 系统调用陷阱: 系统调用指令引发的异常。 不可屏蔽中断 (NMI) 陷阱: 高优先级的不可屏蔽中断引发的异常。 又可分为如下几种类型：\n同步陷阱: 由指令执行过程中的错误引发，发生在程序的预定点。 异步陷阱: 由外部事件（如中断）引发，可能在程序执行的任意时刻发生。 硬件陷阱: 由硬件错误或异常引发。 软件陷阱: 由软件错误或异常引发。 不可恢复的陷阱: 引发任务不可恢复，无法简单重新启动。 TIN Name Synch./\nASynch. HW/\nSW Definition Class 0 \u0026mdash; \u0026mdash; \u0026mdash; MMU 0 VAF Synch. HW Virtual Address Fill. 1 VAP Synch. HW Virtual Address Protection. Class 1 \u0026mdash; \u0026mdash; \u0026mdash; Internal Protection Traps 1 PRIV Synch. HW Privileged Instruction. 2 MPR Synch. HW Memory Protection Read. 3 MPW Synch. HW Memory Protection Write. 4 MPX Synch. HW Memory Protection Execution. 5 MPP Synch. HW Memory Protection Peripheral Access. 6 MPN Synch. HW Memory Protection Null Address. 7 GRWP Synch. HW Global Register Write Protection. Class 2 \u0026mdash; \u0026mdash; \u0026mdash; Instruction Errors 1 IOPC Synch. HW Illegal Opcode. 2 UOPC Synch. HW Unimplemented Opcode. 3 OPD Synch. HW Invalid Operand specification. 4 ALN Synch. HW Data Address Alignment. 5 MEM Synch. HW Invalid Local Memory Address. Class 3 \u0026mdash; \u0026mdash; \u0026mdash; Context Management 1 FCD Synch. HW Free Context List Depletion (FCX = LCX). 2 CDO Synch. HW Call Depth Overflow. 3 CDU Synch. HW Call Depth Underflow 4 FCU Synch. HW Free Context List Underflow (FCX = 0). 5 CSU Synch. HW Call Stack Underflow (PCX = 0). 6 CTYP Synch. HW Context Type (PCXI.UL wrong). 7 NEST Synch. HW Nesting Error: RFE with non-zero call depth. Class 4 \u0026mdash; \u0026mdash; \u0026mdash; System Bus and Peripheral Errors 1 PSE Synch. HW Program Fetch Synchronous Error. 2 DSE Synch. HW Data Access Synchronous Error. 3 DAE Asynch AHW Data Access Asynchronous Error. 4 CAE Asynch HW Coprocessor Trap Asynchronous Error. 5 PIE Synch HW Program Memory Integrity Error. 6 DIE Asynch HW Data Memory Integrity Error. 7 TAE Asynch HW Temporal Asynchronous Error Class 5 \u0026mdash; \u0026mdash; \u0026mdash; Assertion Traps 1 OVF Synch SW Arithmetic Overflow. 2 SOVF Synch SW Sticky Arithmetic Overflow. Class 6 \u0026mdash; \u0026mdash; \u0026mdash; System Call SYS Synch SW System Call. Class 7 \u0026mdash; \u0026mdash; \u0026mdash; Non-Maskable Interrupt 0 NMI Asynch HW Non-Maskable Interrupt Infineon-AURIX_TC3xx_Architecture_vol1-UserManual-v01_00-EN_merged_unsigned.pdf -\u0026gt; 6.1 Trap Types\n异常处理： 陷阱不会改变 CPU 的中断优先级，因此 ICR.CCPN 字段不会被更新\n返回地址存储在返回地址寄存器 A[11] 中。\n同步陷阱，返回地址是引发陷阱的指令的程序计数器 (PC)\nSYS 陷阱: 由 SYSCALL 指令触发的 SYS 陷阱，返回地址指向 SYSCALL 之后的指令\nFCD 陷阱: 详见 “FCD - 自由上下文列表耗尽 (TIN 1)”\n异步陷阱: 返回地址是如果未发生陷阱将要执行的下一条指令地址。中断的返回地址也遵循相同的规则\n当发生陷阱时，硬件会生成一个陷阱标识符，该标识符由两个部分组成：\n陷阱类别号 (TCN): 用于索引到陷阱向量表。 陷阱识别号 (TIN): 该号码会被加载到数据寄存器 D[15] 中。 陷阱类别号 (TCN) 会左移五位，并与 BTV 寄存器中的地址进行按位或操作，以生成陷阱处理程序的入口地址。\n异常向量基地址 ：BTV， 每两个之间间隔32个byte ，如果处理逻辑很简短，可以放在向量代码段32个byte内，否则就跳到处理程序其他部分，使用 MTCR 指令修改 BTV 寄存器，有多个异常向量表的时候可以适配调整。\n通过TCN左移5位与上BTV，找到函数的入口地址\nUnlike the Interrupt Vector Table, entries in the Trap Vector Table cannot be spanned. 所有的trap条目都要配置 ?\nTCN的作用，计算配置trap向量表，找到入口地址，然后TIN进行处理？\n陷阱触发时的初始状态 当陷阱发生时的初始状态定义如下：\n上层上下文被保存。 返回地址更新至 A[11]。 陷阱识别号 (TIN) 被加载到 D[15]。 堆栈指针 (A[10]) 被设置为中断堆栈指针 (ISP)，前提是处理器之前未使用中断堆栈（即 PSW.IS = 0）。堆栈指针位被设置为使用中断堆栈：PSW.IS = 1。 I/O 模式被设置为监督模式，这意味着所有权限都被启用：PSW.IO = 10B。 当前保护寄存器组被设置为 0：PSW.PRS = 000B。 调用深度计数器 (CDC) 被清零，调用深度限制设置为 64：PSW.CDC = 0000000B。 启用调用深度计数器，PSW.CDE = 1。 PSW 安全位被设置为 SYSCON 寄存器中定义的值：PSW.S = SYSCON.TS。 禁止写入全局寄存器 A[0], A[1], A[8], A[9]：PSW.GW = 0。 中断系统被全局禁用：ICR.IE = 0。旧的 ICR.IE 和 ICR.CCPN 分别保存到 PCXI.PIE 和 PCXI.PCPN 中。ICR.CCPN 保持不变。 访问陷阱向量表以获取陷阱处理程序的第一条指令。 **尽管陷阱不会更改 ** ICR.CCPN ，但它们的处理程序仍然在中断被禁用的情况下开始执行。因此，它们可以在不被中断的情况下执行关键的初始操作，直到它们明确重新启用中断。\n对于不可恢复的 FCU 陷阱，初始状态有所不同。上层上下文无法保存。只有以下状态被保证：\nTIN 被加载到 D[15]。 堆栈指针 (A[10]) 被设置为中断堆栈指针 (ISP)，前提是处理器之前未使用中断堆栈（即 PSW.IS == 0）。 I/O 模式被设置为监督模式（所有权限都被启用：PSW.IO = 10B）。 当前保护寄存器组被设置为 0：PSW.PRS = 000B。 PSW 安全位被设置为 SYSCON 寄存器中定义的值：PSW.S = SYSCON.TS。 中断系统被全局禁用：ICR.IE = 0。ICR.CCPN 保持不变。 访问陷阱向量表以获取 FCU 陷阱处理程序的第一条指令 代码分析 BTV寄存器设置trap异常跳转函数\n#define TRAPTAB0 (LCF_TRAPVEC0_START) group trapvec_tc0 (align = 8, run_addr=LCF_TRAPVEC0_START) { section \"trapvec_tc0\" (size=0x100, attributes=rx, fill=0) { select \"(.text.traptab_cpu0*)\"; } } \"__TRAPTAB_CPU0\" := TRAPTAB0; #define CPU_BTV 0xFE24 #define __TRAPTAB_CPU(cpu) __TRAPTAB_CPU##cpu #define __TRAPTAB(cpu) __TRAPTAB_CPU##cpu Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(0)); #pragma ghs section text=\".traptab_cpu0\" void IfxCpu_Trap_vectorTable0(void) { IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError); IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError); IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError); IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError); IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError); IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion); IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu0); IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt); } #pragma ghs section // defined(__ghs__) #define __ALIGN_TRAP_TAB__ __asm(\" .align 32\"); #define IfxCpu_Tsr_CallTSR(serviceRoutine) \\ { \\ __ALIGN_TRAP_TAB__; \\ __asm(\"svlcx\\n\"); \\ __asm(\"mov\\t d4, d15\"); \\ __asm(\"ji\\t %0\" : : \"a\" (serviceRoutine)); \\ __asm(\"rfe\"); \\ } #define IfxCpu_Tsr_CallCSATSR(serviceRoutine) \\ { \\ __ALIGN_TRAP_TAB__; \\ __asm(\"mov\\t d4, d15\"); \\ __asm(\"ji\\t %0\" : : \"a\" (serviceRoutine)); \\ __asm(\"rfe\"); \\ } 中断： SRPN (Service Request Priority Number): 每个中断源分配一个唯一的 SRPN\nPIPN (Pending Interrupt Priority Number) : 挂起中断优先级号\nCCPN (Current CPU Priority Number): 当前cpu优先级\nICU (Interrupt Control Unit ): 中断控制单元\n中断描述： 中断控制单元 (ICU) 使用 SRPN 来优先处理多个并发的中断请求。获胜请求的 SRPN 作为挂起中断优先级号 (PIPN)，当有新的中断请求触发,CPU 通过将 PIPN 与当前 CPU 优先级号 (CCPN) 进行比较，决定是否接受请求的中断。如果 CPU 决定接受中断请求，它将响应一个中断确认，并返回已接受中断的优先级号。ICU 随后会清除请求的中断源\n**中断响应条件： **ICR.IE == 1 \u0026amp;\u0026amp; PIPN \u0026gt; CCPN\n可能禁止中断响应的条件：\n中断系统全局禁用 (ICR.IE == 0)。\n当前 CPU 优先级 (CCPN) 等于或高于挂起中断优先级号 (PIPN)。\nCPU 正在进入中断或陷阱服务例程。\nCPU 正在执行不可中断的陷阱服务。\nCPU 正在执行多周期指令。\nCPU 正在执行修改 ICR 的指令\n中断向量表： 每个中断向量占用32byte或者8byte，由BIV.VSS的值决定\nif (BIV.VSS == 1’b0) ISR_Entry_PC = {BIV[31:1],1’b0} | {PIPN\u003c\u003c5}; else ISR_Entry_PC = {BIV[31:1],1’b0} | {PIPN\u003c\u003c3}; 优先级组：\n中断优先级组描述了一组不能中断彼此服务程序的中断。当 CPU 开始处理某个中断时，中断系统会被全局禁用，且 CPU 的当前优先级号码 (CCPN) 设置为正在服务的中断的优先级号码。这会阻止所有进一步的中断服务，直到通过软件重新启用中断系统或使用 RFE（异常返回）指令终止服务例程。\nRFE 指令：RFE 指令会自动恢复 ICR.IE 位的前一个状态（ICR.IE = 1）\n当 ISR 软件通过设置 ICR.IE 再次启用中断系统而不改变 CCPN 时，就可以阻止所有与 CCPN 相同或更低优先级的中断请求。这包括当前中断的重新发生，即当前中断不能中断自己的服务。但会被更高优先级的中断打断。为了实现中断优先级组，相关的服务例程软件会在再次启用中断系统之前， 将 CCPN 设置为该组中最高 SRPN 的值 ，如下图：\n组1：11-12，CCPN=12\n组2：14-17，CCPN=17\n中断优先级： 中断处理： 进入中断的行为如下：\nThe upper context of the current task is saved. The Return Address (A[11]) is updated with the current PC. If the processor was not previously using the interrupt stack (PSW.IS = 0), then the A[10] Stack Pointer is set to the interrupt stack pointer (ISP). The stack pointer bit is then set for using the interrupt stack: PSW.IS = 1. The I/O mode is set to Supervisor mode, which means all permissions are enabled: PSW.IO = 10B. The current Protection Register Set is set to 0: PSW.PRS = 000B. The Call Depth Counter (PSW.CDC) is cleared, and the call depth limit selector is set for 64: PSW.CDC = 0000000B. Call Depth Counter is enabled, PSW.CDE = 1. PSW Safety bit is set to value defined in the SYSCON register. PSW.S = SYSCON.IS. Write permission to global registers A[0], A[1], A[8], A[9] is disabled: PSW.GW = 0. The interrupt system is globally disabled: ICR.IE = 0. The old ICR.IE is saved into PCXI.PIE. The Current CPU Priority Number (ICR.CCPN) is saved into the Previous CPU Priority Number (PCXI.PCPN) field. The Pending Interrupt Priority Number (ICR.PIPN) is saved into the Current CPU Priority Number (ICR.CCPN) field. The interrupt vector table is accessed to fetch the first instruction of the ISR. 中断退出的行为：\nPCXI.PCPN is written to ICR.CCPN to set the CPU priority number to the value before interruption. PCXI.PIE is written to ICR.IE to restore the state of this bit. 任务切换 在嵌入式和实时控制系统设计中，通常将中断处理程序和软件管理的任务视为在各自的“虚拟”微控制器上执行。这个模型通常由实时执行系统或实时操作系统（RTOS）支持，这些系统层叠在底层机器架构的功能之上。\n在TriCore™架构中，RTOS层需要处理的更少，硬件可以高效地处理任务之间的切换。同时，该架构允许在任务模型中具有相当大的灵活性。系统设计人员可以根据应用程序的需求选择最合适的实时执行系统和软件设计方法，而架构对其施加的限制相对较少。\n在TriCore架构中，低开销的任务切换和函数调用机制是密切相关的。\n任务切换，保护当前任务的上下文，然后回复另一个待执行任务的上下文，并执行\nContexts, when saved to memory, occupy 16 word blocks of storage, known as **Context Save Areas ** (CSAs).\nUpper context: 包括地址寄存器A[10]到A[15]和数据寄存器D[8]到D[15]，PCXI和PSW。\nLower context : 包括地址寄存器A[2]到A[7]、数据寄存器D[0]到D[7]、A[11]（返回地址）和PCXI。\n每个CSA保存一个 Upper context 或 Lower context\nLink Word由两部分组成，Segment和Offset，上面解释了一个CSA占用64byte大小，所有CSA可用的大小是4M\n系统中的会维护两个CSA链表，Previous Context List (PCX) 和 Free Context List (FCX)\n上下文保存：\n下半部分上下文寄存器：类似于全局寄存器，即中断处理程序、陷阱处理程序或调用函数可以看到这些寄存器中断前的值。在事件结束后，这些寄存器中的任何更改会保留，因此可以用于 传递函数参数和返回值 。中断和陷阱处理程序必须在使用这些寄存器之前保存它们的原始值，并在退出之前恢复这些值。 上半部分上下文寄存器：这些寄存器不是硬件静态寄存器。概念上，函数调用或中断处理程序总是以自己私有的上半部分上下文寄存器开始执行。被中断或调用的函数的上半部分上下文寄存器不会被继承 只有 A10（sp）、A11（RA）、PSW、PCXI 和在陷阱情况下的 D[15] 寄存器在调用函数、陷阱处理程序或中断处理程序中具有架构定义的初始值。函数、陷阱处理程序或中断处理程序在写入其他上半部分上下文寄存器之前读取这些寄存器的值，是未定义操作。 上下文保存：\n上下文恢复：\n/* 第一个 CSA */ uppercontext = (uppercontext_t)LINKWORDTOEA(Fcx); /* 第二个 CSA */ lowercontext = (lowercontext_t)LINKWORDTOEA(uppercontext-\u003ePCXI); /* 第三个 CSA 线程退出 */ exitcontext = (uppercontext_t)LINKWORDTOEA(lowercontext-\u003ePCXI); 模式与访问权限： 用户模式（User Mode） User-0模式: 该模式用于不访问外设的任务。在这个模式下，任务无法启用或禁用中断。 User-1模式: 该模式用于访问常见的、未保护的外设任务。例如，串口读写操作、计时器的读操作，以及大多数I/O状态寄存器的访问。此模式下的任务可以禁用中断（此行为可以通过系统控制寄存器覆盖）。 监督模式（Supervisor Mode） 该模式允许任务读取和写入系统寄存器，并访问所有外设设备。此模式下的任务可以禁用中断。 Memory Barrier 内存屏障（Memory Barrier），也叫内存栅栏，是一种用于控制 CPU 和编译器在执行操作时的顺序的机制。内存屏障确保某些操作在代码执行顺序上保持一致，从而避免因指令重排序导致的不一致性问题。\n内存屏障的作用 在多核系统中，不同核心可能会乱序执行指令或者 乱序读取/写入内存 。如果没有内存屏障，以下问题可能会发生：\n数据竞争：两个核心同时访问同一内存位置，其中一个核心写入数据后，另一个核心可能会读到旧的数据。 指令重排序：编译器或 CPU 出于优化目的，可能会改变指令执行顺序，导致预期的同步行为被破坏。 内存屏障通过阻止这种乱序操作，确保所有核心看到一致的数据和内存操作顺序。\nDSYNC（Data Synchronization） DSYNC 指令保证在 DSYNC 指令之前的所有数据访问操作都已完成，然后才会启动与 DSYNC 之后的指令相关联的任何数据内存访问操作。这包括所有对系统总线和本地数据内存的访问。 ISYNC（Instruction Synchronization） ISYNC 指令用于确保 CPU 内部的状态一致性。它主要用于指令的同步，确保在 ISYNC 指令之前的所有指令都已执行完毕，并且对架构状态的任何更改已经生效，然后才会继续执行 ISYNC 之后的指令。 ISYNC 指令的操作如下： 等待 ISYNC 之前的所有指令完成。 刷新 CPU 管道并取消 ISYNC 之后的所有指令。 使管道中所有缓存状态失效，例如循环缓存缓冲区。 重新获取 ISYNC 之后的下一条指令。 TC397XX： 官方介绍： SAK-TC397XX-256F300S BD\nInfineon-AURIX_TC3xx_Architecture_all-UserManual-v01_00-EN.pdf\nInfineon-AURIX_TC39x-UserManual-v02_00-EN.pdf\n硬件特性： TriCore™ TC397xx是32位高性能的微控制器，广泛应用于汽车和其他要求高可靠性和高性能的领域。以下是其主要特性：\n处理器架构：\n配备6个TriCore™（TC1.6.2）核心，主频为300 MHz，其中包括4个附加的检查核心，提供4000 DMIPS（Dhrystone MIPS）。 浮点与定点支持：\n所有核心都支持浮点运算和定点运算，提供灵活的计算能力。 RAM/ROM：\n16 MB flash，支持ECC（错误更正码）保护。 umbrella (5 x 3 MB, 1 x 1 MB)1. 高达6.9 MB SRAM，支持ECC保护，增强数据可靠性。 通信接口：\n1 Gbit以太网接口。 12个CAN FD接口，用于高带宽的控制器局域网络通信。 2个FlexRay接口，支持高速车载通信。 12个ASCLIN（异步串行通信接口），适用于多种串行通信需求。 6个QSPI接口（四线串行外设接口），用于高速外部存储。 2个I²C接口，支持多主设备和多从设备的串行通信。 25个SENT接口（串行增强数字传感器接口），用于传感器数据采集。 4个PSI5接口和1个PSI5S接口，支持车载传感器的数据传输。 2个HSSLL接口（高速同步串行链路），适用于高速数据传输。 4个MSC接口（多功能同步通信），用于多种数据通信需求。 1个eMMC/SDIOT接口，支持外部存储扩展。 1个I²S仿真接口，用于音频数据传输。 定时器模块：\n多种冗余和多样化的定时器模块，如GTM（通用定时器模块）、CCU6（计数器控制单元6）、GPT12（通用预分频定时器12），提供精确的时间管理和测量功能。 安全性：\nEVITA Full HSM（硬件安全模块），支持ECC256（椭圆曲线密码学256位密钥）和SHA2（安全散列算法2），提供高级的安全保障。 封装：\n采用LFBGA-292封装，适合高密度集成。 安全标准：\n依照ISO 26262/IEC 61508标准进行开发和文档化，支持高达ASIL-D（汽车安全完整性等级D）/SIL3（安全完整性等级3）的安全要求。 AUTOSAR支持：\n支持AUTOSAR 4.2（汽车开放系统架构），用于车载软件的标准化开发。 可选浮点单元 （FPU） 和内存管理单元 （MMU）\n电源供应：\n单电压供电，支持5 V或3.3 V电压输入。 温度范围：\n工作温度范围为-40°C到125°C，适合极端环境下的应用。 优势：\n最佳性能，支持ASIL-D设计\nASIL-D合规性：TC397xx微控制器提供了顶级的性能，能够支持达到ASIL-D安全标准的设计。ASIL-D是ISO 26262标准中最高的汽车安全完整性等级，确保汽车应用的最高安全水平。 向下兼容，适配成本更低的AURIX™ TC3xx微控制器\n成本效益：TC397xx微控制器可以向下兼容，适配较低成本的AURIX™ TC3xx系列微控制器。这种向下兼容性意味着可以在不同成本级别的产品中使用相似的硬件架构，帮助降低整体系统成本，同时保留核心功能和性能。 支持A/B交换的软件更新\n远程更新支持：TC397xx支持A/B交换的软件更新机制，这允许在系统运行时进行安全的软件更新。A/B交换的方式可以在不影响系统正常运行的情况下完成软件更新，提升系统的可靠性和安全性。这种支持对汽车系统的维护和升级非常重要，尤其是在需要远程更新的情况下。 从AURIX™第一代产品的易迁移\n兼容性：TC397xx微控制器与AURIX™第一代产品在软件和硬件方面具有兼容性，使得从早期版本的AURIX™微控制器迁移到TC397xx变得更为简便。这样的兼容性不仅减少了开发时间和成本，还可以确保现有系统的平稳过渡 Flash 中断 中断请求可以由CPU或DMA模块来处理，在文档中被称为“ 服务请求 ”而不是“中断请求”，因为它们可以由任一服务提供者处理。\n中断系统是在中断路由器(IR)模块中实现的，该模块包括服务请求节点（SRNs）、中断控制单元（ICUs），以及一些支持软件开发的附加功能。\n如下图所示，每个可以产生服务请求的模块都连接到 IR 模块中的一个或多个服务请求节点（SRNs）。IR 模块还包括几个通用的服务请求节点（SRNs），即软件触发中断\n每个SRN都包含一个SRC（Service Request Control Register），用来配置服务请求的优先级、映射到的服务提供者等。每个SRN都连接到中断路由器模块中的所有ICUs，而SRN的控制寄存器设置则定义了服务请求的目标服务提供者和优先级。\n每个ICU负责在映射到该ICU的多个服务请求之间进行中断仲裁。ICU在仲裁轮中选择一个有效的获胜服务请求/SRN，并将其提供给服务提供者（CPU或DMA模块）。服务提供者在处理服务请求时，向ICU反馈当前正在处理的服务请求。\n中断仲裁 每个中断模块中的中断控制单元 (ICU) 都有自己独立的中断总线。每个服务请求节点 (SRN) 都可以通过在SRC.TOS 位字段中设置，将其映射到相关的 ICU / 中断总线上，从而将该服务请求节点定向到特定的服务提供者\nSRC.TOS: Type of Service Control ( cpu0-5, dma ）\nSRC.SRE: Service Request Enable （1：enabled）\n当第一个服务请求pending时，相关的中断总线将启动第一次仲裁过程。相关的中断控制单元 (ICU) 提供在上一次仲裁过程中获胜的服务。仲裁过程使用 3-4 个系统外围总线时钟周期来确定具有最高优先级号码 (SRPN) 的待处理服务请求。\n在仲裁过程中，中断总线会比较映射到此中断总线（通过 SRC.TOS 设置）的所有待处理服务请求节点 (SRN) 的SRC.SRPN 位字段。仲裁过程中，具有最高优先级号码的待处理服务请求将被识别为获胜者，并且相关的 SRN 服务请求控制寄存器的位字段值（SRPN、ECC 和 SRN 的索引）将提供给 ICU，并传给给服务提供者，然后ICU会收到确认信息，之后进行ECC校验,中断路由模块会将检测到的错误信号发送到安全管理单元 (SMU)（SMU 中的一个位覆盖了所有 SRN 和 ICU 的错误）。\n中断配置 如下图中断向量表可以配置32byte，8byte，单地址\n中断初始化：\n外部中断： External Request Unit (ERU) 是一个多功能的事件和模式检测单元，其主要功能是根据可选择的触发事件生成中断（例如，当输入引脚上检测到边沿变化时，生成外部中断请求）。此外，ERU还可以将检测到的事件用于其他目标模块，以触发或控制模块特定的操作。\n功能列表：\n生成中断：支持基于不同输入上的可选择触发事件生成中断。 8个独立输入通道：用于输入选择和触发或控制功能的条件设定。 事件分配矩阵：使用连接矩阵定义输入通道x的事件，这些事件将导致输出通道y的反应。 8个独立输出通道：用于事件组合、定义事件的效果，并分配给系统（例如，中断生成、定时器触发等）。 这些功能使ERU成为一个强大的工具，用于检测和响应多种外部信号和事件，在嵌入式系统中具有广泛的应用。\n这些任务由以下构建块(building block)处理:\nExternal Request Select Unit (ERSx), 每个输入通道都有一个外部请求选择单元（ERSx），可以从6个可能的可用输入中选择一个输入向量 Event Trigger Logic (ETLx), 每个输入通道的事件触发逻辑（ETLx）允许定义导致触发事件的转换（边缘选择或通过软件），也可以存储此状态. 此处，所选信号的输入电平被转换为事件（检测到事件=置位事件标志，与原始输入信号的极性无关） Connecting Matrix, 连接矩阵将输入通道生成的事件和状态标志分配到输出通道 Output Gating Unit (OGUy), 每个输出通道的输出门控单元（OGUy），结合了可用的触发事件和来自输入通道的状态信息. 一个输入通道的事件可以导致多个输出通道的反应，或者多个输入通道的事件也可以组合成一个输出通道的反应（模式检测）. 可以配置不同类型的反应，例如产生中断. 可以从大量输入信号中选择ERU的输入, 这些输入中的16个直接来自输入端口，而其他输入则来自各种外围模块状态信号.\nREQxy Digital PORT Input Glitch Filter (FILT), 毛刺滤波器仅在端口(PORTS)可用, 用寄存器EIFILT配置, 用于抑制信号噪声导致PORTS的输入引脚上发生的不必要的快速转换, 类似于延时消抖. 滤波器预分频器可以设置为1到15之间的值，从而提供从10ns ~ \u0026gt;2µs的可能的毛刺特性范围, 通常，3~5 Tfilt的深度就足够了. 默认情况下，它是清除的. 如果清除了DEPTH，则所有过滤器均处于非活动状态:\nExternal Request Selector Unit (ERS)：\nEvent Trigger Logic (ETLx), 事件触发逻辑, 基于边缘检测模块，在该模块中，可以分别启用对上升沿或下降沿的检测. 如果两个使能位都被置位（例如处理触发输入），则两个边沿都会导致触发事件. 四个ETL单元中的每对都有一个关联的EICRy寄存器，该寄存器控制ETL的所有选项（该寄存器还保存关联的ERS单元对的控制位）\nERU_Interrupt_1 for KIT_AURIX_TC397_TFT\n如何设置中断向量表，以及中断handler如何放到中断向量表中的\nLcf_Tasking_Tricore_Tc.lsl\n#define LCF_TRAPVEC0_START 0x80000100 #define TRAPTAB0 (LCF_TRAPVEC0_START) \"__TRAPTAB_CPU0\" := TRAPTAB0; group trapvec_tc0 (align = 8, run_addr=LCF_TRAPVEC0_START) { section \"trapvec_tc0\" (size=0x100, attributes=rx, fill=0) { select \"(.text.traptab_cpu0*)\"; // 下文代码中配置的 } }// IfxCpu_Trap.c #pragma protect on #pragma section code \"traptab_cpu0\" void IfxCpu_Trap_vectorTable0(void) #pragma endprotect | IfxCpu_Trap.o | .text.traptab_cpu0 (27065)| 0x000000f2 | 0x0| .text.traptab_cpu0 (27065) | 0x000000f2 |#define LCF_INTVEC0_START 0x802FE000 #define INTTAB0 (LCF_INTVEC0_START) \"_lc_u_int_tab\" = (LCF_INTVEC0_START); \"__INTTAB_CPU0\" = (LCF_INTVEC0_START); #define IFX_INTERRUPT(isr, vectabNum, prio) IFX_INTERRUPT_INTERNAL(isr, vectabNum, prio) #define IFX_INTERRUPT_INTERNAL(isr, vectabNum, prio) void __interrupt(prio) __vector_table(vectabNum) isr(void) 参考： AURIX TC397 SCU 之 ERU 外部中断_scu中断配置-CSDN博客\n【回眸】AurixTC397ERU外部中断开发 萌新札记\nUCB：6.8 User Configuration Block (UCB)\nTriCore™ Embedded Applications Binary Interface (EABI)\n问题定位 访问空指针 DMI-\u0026gt;DSTR-\u0026gt;MPE : Error\n系统寄存器 Infineon-TC2xx_EABI-UM-v02_09-EN.pdf\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPCXI(Previous Context Information register): 保存任务上下文信息\nField Bits Type Description PCPN [29:22] rw Previous CPU PriorityNumber PIE 21 rw Previous Interrupt Enable (ICR.IE) UL 20 rw 0:Lower, 1:Upper Context PCXS [19:16] rw PCX Segment Address PCXO [15:0] rw Previous Context Pointer Offset \u0026#160;\u0026#x21a9;\u0026#xfe0e; PSW (Program Status Word): 记录处理器状态、保护模式等\nField Bits Type Description USB [31:24] rw User Status Bits PRS[2] 15 - Protection Register Set bit[2] S 14 rw Safety Task Identifier PRS[1:0] [13:12] rw Protection Register Set bits[1:0] IO [11:10] rw Access Privilege Level Control IS 9 rw 0:User Stack, 1: Shared Global Stack GW 8 rw Global Address Register Write Permission CDE 7 rw Call Depth Count Enable CDC [6:0] rw Call Depth Counter (0-64) User Status Bits: Field Bits Type Description C 31 rw Carry V 30 rw Overflow SV 29 rw Sticky Overflow AV 28 rw Advance Overflow SAV 27 rw Sticky Advance Overflow RES [26:24] - Reserved Field Access Privilege Level Control: 00: User-0 Mode, No peripheral access\n01: User-1 Mode, Regular peripheral access\n10: Supervisor Mode, Enables access to all peripheral devices \u0026#160;\u0026#x21a9;\u0026#xfe0e; BIV(Base Interrupt Vector Table Pointer): 中断向量地址\nField Bits Type Description BIV [31:1] rw Base Address of Interrupt Vector Table VSS 0 rw Vector Spacing Selec (0:32byte,1:8byte) \u0026#160;\u0026#x21a9;\u0026#xfe0e; BTV(Base Trap Vector Table Pointer): trap异常地址\nField Bits Type Description BIV [31:1] rw Base Address of Trap Vector Table RES 0 - Reserved \u0026#160;\u0026#x21a9;\u0026#xfe0e; ICR(ICU Interrupt Control Register): 中断控制寄存器\nField Bits Type Description PIPN [23:16] rh Pending Interrupt Priority Number\n0:no pending, 1:lower priority IE 15 rwh Global Interrupt Enable Bit\n0:全局关中断，1:全局开中断 CCPN [7:0] rwh Current CPU Priority Number \u0026#160;\u0026#x21a9;\u0026#xfe0e; ","date":"2025年7月8日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/tricore/tc397/","series":[{"title":"Tc397 架构系列","url":"/series/tc397-%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97/"}],"smallImg":"","tags":[{"title":"Tricore","url":"/tags/tricore/"},{"title":"Tc397","url":"/tags/tc397/"}],"timestamp":1751986567,"title":"Tc397"},{"authors":[],"categories":[{"title":"Tricore中断","url":"/categories/tricore%E4%B8%AD%E6%96%AD/"}],"content":" Tc397中断子系统\n3. 通用寄存器和系统寄存器 核心寄存器有两种类型：通用寄存器（GPRs）和核心特殊功能寄存器（CSFRs）。GPRs包括16个通用数据寄存器和16个通用地址寄存器。CSFRs用于控制核心的操作并提供关于核心的状态信息。\n通用寄存器 系统寄存器（PSW，PC，PCXI） 栈管理寄存器（A[10] 和 ISP） SYSCON和CPU_ID寄存器 陷阱寄存器 (Trap registers) 上下文管理寄存器 内存保护寄存器 内存管理寄存器 调试寄存器 浮点寄存器 与核心相关的特殊功能寄存器 复位值 应注意，由于本手册描述的是TriCore®架构，而不是该架构的具体实现，因此某些复位值未给出。未提供的复位值是具体实现相关的。\nENDINIT保护 该架构支持在操作状态之前的初始化状态的概念。\n在初始化状态下，所有核心特殊功能寄存器（CSFRs）都可以使用MTCR指令进行修改。在操作状态下，只有部分CSFRs可以通过这种方式修改。其他功能在这两种状态下保持相同。\n在初始化状态下只能写入的CSFRs被描述为ENDINIT保护的。\n初始化状态和操作状态之间的转换由系统实现控制。此功能通过仅允许在初始化状态下更改关键CSFRs，增加了额外的保护级别。\n以下寄存器受ENDINIT保护：\nBTV, BIV, ISP, PMA0, PMA1, PMA2, PCON0, DCON0, SEGEN 提供了一个专为安全设计的ENDINIT保护版本。以下寄存器受SAFETY_ENDINIT保护：\nSMACON, SYSCON, COMPAT, TPS_EXTIM_ENTRY_LVAL, TPS_EXTIM_EXIT_LVAL 4. 任务和功能 大多数嵌入式和实时控制系统都是根据一个模型设计的，该模型中中断处理程序和软件管理的任务各自被视为在自己的“虚拟”微控制器上执行。这种模型通常由实时执行体或实时操作系统（RTOS）的服务支持，这些服务位于底层机器架构的特性和功能之上。\n在TriCore™架构中，RTOS层可以非常“薄”，硬件可以高效地处理一个任务与另一个任务之间的切换。同时，该架构允许在所使用的任务模型中具有相当的灵活性。系统设计者可以选择最适合其应用需求的实时执行体和软件设计方法，架构施加的限制相对较少。\n5. 中断系统 在TriCoreTM系统中，多个源（如外围设备或外部中断）可以向CPU或DMA通道等中断服务提供者发出中断请求。本章描述了CPU的中断处理能力，包括中断优先级方案和对向量表的访问。\n5.1 一般操作 每个中断源都会被分配一个唯一的中断优先级编号，称为服务请求优先级编号（SRPN）。在接收到来自中断源的中断请求后，SRPN会被中断控制单元（ICU）用来在多个并发中断请求之间进行优先级排序。获胜请求的SRPN作为挂起中断优先级编号（PIPN）与请求触发一起传递给CPU。CPU通过将PIPN与当前CPU优先级编号（CCPN）进行比较，决定是否接受请求的中断。如果CPU决定接受请求的中断，它会以中断确认响应，并返回已接收中断的优先级编号。随后ICU将清除请求中断的源。\n5.1.1 ICU中断控制寄存器（ICR） ICU中断控制寄存器（ICR）包含当前CPU优先级编号（CCPN）、全局中断启用/禁用位（IE）和当前挂起中断优先级编号（PIPN）。\n5.1.2 CPU对中断请求的操作 CPU检查全局中断启用位ICR.IE的状态，并将当前CPU优先级编号ICR.CCPN与PIPN进行比较。只有当ICR.IE == 1并且PIPN大于CCPN时，CPU才会被中断。如果满足条件，CPU可以进入服务例程。PIPN用于确定中断向量表的入口点，并向ICU确认，ICU随后会向挂起的中断请求发送确认。\n几种情况可能会阻止CPU立即响应由ICU生成的中断请求，这些情况包括：\n中断系统被全局禁用（ICR.IE == 0）。 当前CPU优先级（CCPN）等于或高于挂起中断优先级编号（PIPN）。 CPU正在进入中断或陷阱服务例程的过程中。 CPU正在执行不可中断的陷阱服务。 CPU正在执行多周期指令。 CPU正在执行修改ICR的指令。 只有当这些条件不再成立时，CPU才会响应中断请求。\n5.1.3 进入中断服务例程（ISR） 当 CPU 满足所有条件来处理中断请求时，将执行以下操作以进入中断服务程序 (ISR)：：\n当前任务的上文被保存。 当前PC保存到返回地址（A[11]）中。 如果处理器之前没有使用中断栈（PSW.IS = 0），则A[10]栈指针会被设置为中断栈指针（ISP）。随后栈指针位被设置为使用中断栈：PSW.IS = 1。 I/O模式设置为Supervisor模式，这意味着所有权限被启用：PSW.IO = 10B。 当前的保护寄存器集被设置为0：PSW.PRS = 000B。 调用深度计数器（PSW.CDC）被清除，调用深度限制选择器被设置为64：PSW.CDC = 0000000B。 调用深度计数器已启用，PSW.CDE = 1。 PSW安全位设置为SYSCON寄存器中定义的值：PSW.S = SYSCON.IS。 禁止对全局寄存器A[0]、A[1]、A[8]、A[9]的写入权限：PSW.GW = 0。 中断系统被全局禁用：ICR.IE = 0。旧的ICR.IE被保存到PCXI.PIE中。 当前CPU优先级编号（ICR.CCPN）被保存到前一个CPU优先级编号（PCXI.PCPN）字段中。 挂起中断优先级编号（ICR.PIPN）被保存到当前CPU优先级编号（ICR.CCPN）字段中。 访问中断向量表以获取ISR的第一条指令。 注意 : 每当进入中断服务例程或陷阱处理程序时，都会禁用全局寄存器写入权限（PSW.GW == 0）。这确保所有陷阱和中断默认情况下都假设它们没有写入受PSW.GW控制的寄存器的权限。\n进入中断服务例程，中断系统全局禁用，当前 CPU 优先级 (CCPN) 设置为正在服务的中断的优先级 (PIPN)。用户需要自行再次启用中断系统，并可以选择修改优先级编号CCPN，以实现中断优先级级别或处理特殊情况。有关详细信息，请参见《使用TriCore中断系统》。\n开启中断的方式如：\nENABLE指令，ENABLE将ICR.IE设置为1（中断系统启用）。\nBISR（Begin Interrupt Service Routine）指令也会启用中断系统，将ICR.CCPN设置为新值，并保存被中断任务的下文。\nMTCR（Move To Core Register）指令修改中断启用位（ICR.IE）和当前CPU优先级编号（ICR.CCPN）。\nENABLE、BISR和DISABLE（禁用中断）指令都是在 CPU完全执行完这些指令后才允许接受中断请求的 。这避免了流水线副作用，并消除了在这些指令之后使用ISYNC（同步指令流）的需要。MTCR是个例外，必须在之后跟随ISYNC指令。\n5.2 退出中断服务例程（ISR） 当ISR通过RFE（Return From Exception）指令退出时，硬件会自动恢复上文。上文包括保存前一个CPU优先级编号（PCXI.PCPN）和前一个全局中断启用位（PCXI.PIE）。这些相应位中的值将如下使用：\n将PCXI.PCPN写入ICR.CCPN，以将CPU优先级编号恢复为中断前的值。 将PCXI.PIE写入ICR.IE，以恢复该位的状态。 被中断的例程随后将继续执行。\n5.3 中断向量表 中断服务例程（ISR）通过中断向量表与特定优先级的中断关联。中断向量表是中断服务例程（ISR）入口点的数组。中断向量表存储在内存中。\n当CPU响应中断时，它会计算一个中断向量表中的地址，该地址与中断的优先级（ICR.PIPN位字段）相对应。此地址被加载到PC中，CPU开始执行此地址的指令。此地址的代码是所选中断服务例程（ISR）的起始部分。根据ISR的代码大小，中断向量表可能只存储ISR的初始部分，例如将CPU引导到ISR其余部分的跳转指令，这些部分可能存储在内存的其他地方。\n中断向量表基地址寄存器 （BIV）存储中断向量表的基地址。中断向量在表中按优先级递增的顺序排列。在启用中断之前进行, BIV寄存器可以在系统初始化阶段使用MTCR指令进行修改（BIV受ENDINIT保护）。通过这种方式，可以使用多个中断向量表，并通过更改BIV寄存器的内容在它们之间切换。\n当发生中断时，CPU从ICU.PIPN和BIV寄存器的计算出相应中断服务例程的入口点。有 两种向量表配置可用，向量之间的间隔分别为32字节或8字节 。间隔由BIV寄存器的向量大小选择（BIV.VSS）位选择。\n为了生成中断向量表中的指针，PIPN向左移位五位（VSS=0）或三位（VSS=1），然后与BIV寄存器中的地址进行“或”运算，以生成指向中断向量表的指针。ISR的执行从这个地址开始。由于这种操作，建议BIV寄存器的[14:5]位（VSS=0）或[12:3]位（VSS=1）设置为0。\nif (BIV.VSS == 1’b0) ISR_Entry_PC = {BIV[31:1],1’b0} | {PIPN\u003c\u003c5}; else ISR_Entry_PC = {BIV[31:1],1’b0} | {PIPN\u003c\u003c3};如果一个中断处理程序非常短，它可能完全适合在向量代码段中提供的指令字内。否则，存储在入口位置的代码可以跨越多个向量条目，或者包含一些初始指令，然后跳转到处理程序的其余部分。有关跨越向量条目的中断服务例程的详细信息，请参见“跨越向量条目的中断服务例程”。\nBIV寄存器允许中断向量表位于可用代码内存的任何位置。上电时的默认值取决于具体的实现。可以在系统初始化阶段使用MTCR指令写入BIV寄存器，这通常是在启用中断之前进行。还可以通过修改BIV寄存器的内容，实现多个中断向量表之间的切换。\n5.4 使用TriCore中断系统 以下部分包含一些示例，展示了如何使用TriCore架构灵活的中断系统来解决典型和特殊应用的需求。\n5.4.1 跨向量条目扩展中断服务例程（ISRs） 由于向量条目并未与中断源直接绑定，因此很容易跨越多个向量条目位置来扩展中断服务例程，如之前图22所示。如果中断处理程序的剩余部分无法容纳在入口位置之间的八个字内，则扩展可消除跳转到中断处理程序剩余部分的需要。。\n要注意的是，与跨越服务例程相关的条目所对应的优先级号，不能用于请求同一服务提供者服务的活动服务请求节点（SRNs）。\n在图22中，向量位置三和四被第二条目的服务例程覆盖。因此，这些优先级号不能分配给请求CPU服务的SRNs，虽然它们可以用于请求其他服务提供者。接下来的可用向量条目是条目五。\n使用这种技术会增加系统中所需的优先级号码范围，但需要相应调整向量表的大小。\n5.4.2 中断优先级组 中断优先级组描述了一组中断，这些中断的服务例程不能相互中断。这些组可以通过TriCore中断系统架构轻松创建。\n当CPU开始服务某个中断时，中断系统会全局禁用，并且CPU优先级CCPN设置为正在服务的中断的优先级。这将阻止所有对其他中断的处理，直到通过软件重新启用中断系统，或通过RFE（异常返回）指令终止服务例程。\n注意： RFE指令会自动恢复ICR.IE位的先前状态。这将是1（ICR.IE = 1），否则该中断就不会被处理 。\n当中断服务例程（ISR）软件在不改变CCPN的情况下重新开启中断（设置ICR.IE），其效果是，所有优先级等于或低于CCPN的中断请求仍然被阻止服务。这包括当前中断的再次发生；即它不能中断此服务。\n然而，具有比CCPN更高优先级号码的每个请求都会中断此ISR。一个潜在的问题（在TriCore架构中可以轻松克服）是，应用程序需求通常要求相似重要性的中断请求被分组在一起，使得该组中的任何请求都不能中断同组其他成员的ISR。\n在中断系统中创建这些中断优先级组非常容易。对于定义的一组中断请求，其相应服务例程的软件在再次启用中断系统之前，将CCPN设置为该组中使用的最高SRPN的号码。如图23所示。\n优先级号为11和12的中断请求构成一个组，而优先级号为14到17（包括14和17）的中断请求构成另一个组。每次在处理第一个组中的一个中断时，服务例程会将CCPN设置为该组中的最高优先级号12，然后再重新启用中断系统。每次处理第二个组中的一个中断时，服务例程会将CCPN设置为17，然后再重新启用中断系统。例如，如果处理了中断14，它只能被优先级高于17的请求中断，而不会被来自其自身优先级组的请求或优先级较低的请求中断。\n可以看出该系统的灵活性及其优于固定优先级系统的地方。在上述示例中，优先级号为13的中断请求形成了一个单独的“组”。 在每个服务例程中将CCPN设置为最大值255的效果与不重新启用中断系统的效果相同 ；即所有中断请求都可以被视为属于同一个组。\n中断优先级水平的灵活性范围从所有中断在一个组内，到每个中断请求形成自己的组，以及所有介于两者之间的可能组合。\n5.4.3 将ISR分为不同的优先级 中断服务例程（ISR）可以很容易地分为不同优先级的部分 。例如，一个中断被设置为非常高的优先级，因为对事件的响应时间和反应非常关键，但该服务例程中的进一步操作可以在较低优先级上运行。在这种情况下，服务例程将被分为两个部分，一部分包含关键操作，另一部分包含较不关键的操作。\n首先将中断节点的优先级设置为高优先级，以便当中断发生时，立即执行必要的操作。然后将该中断的优先级降低，并在仍处于服务例程中时通过软件再次设置中断请求位（表示有待处理的中断）。返回被中断的程序将终止高优先级的服务例程。当CPU的优先级低于挂起中断的优先级时，该待处理中断将被服务。进入服务例程后（此时服务例程在程序存储器的不同地址），执行剩余的低优先级中断操作。\n在其他情况下，服务请求的优先级可能较低，因为对事件的响应时间并不关键，但一旦获得服务则不应被中断。为了防止任何中断，TriCore架构允许在ISR内提高服务请求的优先级，并且允许完全禁用中断。\n即对于同一个isr，进入中断handler前后设置不同的优先级\n5.4.4 使用不同的优先级处理相同的中断源 对于某些应用程序，中断请求的优先级相对于其他请求并不是固定的，而是取决于系统的当前情况。这可以通过在不同时间为中断源分配不同的服务请求优先级号码（SRPNs）来实现，以满足应用程序的需求。通常，针对该中断的ISR会根据优先级执行不同的代码。\n在传统的中断系统中，ISR必须检查当前中断请求的优先级，并根据优先级执行适当的代码部分，这可能导致对请求的响应延迟。然而，在TriCore系统中，中断会自动为不同的优先级提供不同的向量条目。因此，不需要在ISR中进行额外的检查和跳转，从而减少了中断延迟。\n如果ISR与中断的优先级无关，则需要在该中断的每个向量条目上跳转到通用ISR代码。\n为一个中断使用不同优先级号码时，在创建向量表时需要考虑这一点。\n5.4.5 中断控制寄存器 ICR： ICU Interrupt Control Register 中断控制寄存器 ICR.PIPN [23:16] : 挂起的中断优先级号\n0：无效，1：最低，0xff:最高\nICR.IE [15] : 中断系统使能/禁用位\nICR.CCPN [7:0] : 当前 CPU 优先级号\nBIV： Base Interrupt Vector Table Pointer 基本中断向量表指针 ICR.BIV [31:1] : 中断向量表的基地址\nICR.VSS [0] : 向量间距选择\n0 -\u0026gt; 32byte, 1 -\u0026gt; 8byte\n16. 中断路由器 (Interrupt Router, IR) 本章描述了中断路由器模块，该模块将来自外部资源、内部资源和软件的中断（在此称为 服务请求 ）调度到CPU和DMA模块（在此称为 服务提供者 ）。\n本文档的范围 本文档适用于TC3xx，并涵盖以下主题：\n中断系统架构 中断系统配置 中断路由器操作 16.1 功能列表 以下列表显示了中断路由器模块的主要功能：\n支持最多1024个服务请求的中断系统 每个ICU1) / 服务提供者支持多达255个服务请求优先级别 支持多达 8个ICU / 服务提供者 （ 397有只有7个**）** 每个实现的CPU / DMA模块（服务提供者）都有一个专用ICU 低延迟仲裁 - 从接收到服务请求到发送给服务提供者，耗时仅为三到四个时钟周期 每个外设中断都有一个专用的服务请求节点（SRN） 每个SRN都有一个可编程的8位优先级向量 每个SRN可以映射到一个已实现的ICU / 服务提供者 当配置的服务提供者确认中断时，SRN将由硬件自动清除 支持完整性保护的中断系统 每个CPU有8个通用服务请求（GPSR），可用作软件中断（不分配给外设或外部中断） 服务请求广播寄存器（SRB），可同时向多个服务提供者发出通用服务请求（软件中断） 服务请求的优先级依赖屏蔽（针对CPU，相关控制寄存器包含在CPU中） 具有滤波模式和触发模式（如下降沿、上升沿、高电平或低电平）的外部中断。模式可在运行时配置3) CPU唤醒支持（当CPUx处于IDLE状态时，将服务请求信号发送至SCU以唤醒CPUx） 16.2 与TC2xx的差异 以下功能变化是从Aurix到TC3xx引入的：\n通用服务请求组：每组服务请求节点的数量从4个变更为8个SRN（详见 16.7 “通用服务请求，服务请求广播”） 广播寄存器：广播寄存器的位图已适应新的GPSR SRN数量（详见 16.7 “通用服务请求，服务请求广播”）。 广播寄存器：每个广播寄存器现在都有一个专用的ACCEN寄存器（详见 16.7.3 “SRBx寄存器的访问保护（ACCEN_SRBx）”）。 SRCx：引入了SRCx[31:0]的访问保护（每个实现的TOS编码/ICU都有一个ACCEN寄存器，详见 16.4.1.3 “SRC寄存器的保护”）。 SRC.ECC：ECC位字段的大小从6位更改为5位（详见 16.4.1.1 “通用服务请求控制寄存器格式”）。 SRC.TOS：TOS位字段的大小更改为3位（详见 16.4.1.1 “通用服务请求控制寄存器格式”）。 SRC偏移和索引编号方案更改：SRC被映射到1024 * 32位范围内。索引编号（0-1023）等于SRC的32位偏移量（详见 16.4.1.1 “通用服务请求控制寄存器格式”）。 检测到信号到保留TOS的服务请求时，会向SMU发出警报。 SRC寄存器映射到IR地址映射已重新设计。 16.3 概述 中断请求可以由CPU或DMA模块服务 。本文档中使用“服务请求”而非“中断请求”，因为它们可以由任一服务提供者服务。\n中断系统在中断路由器模块中实现，该模块包括服务请求节点（SRNs : Service Request Nodes ）、中断控制单元（ICU : Interrupt Control Units ）以及支持软件开发的附加功能。\n如图173所示，每个能够生成服务请求的模块都连接到中央中断路由器模块中的一个或多个服务请求节点（SRN）。中断路由器模块还包括多个通用服务请求节点（SRN），这些节点可用于软件（SW）触发的服务请求。\n每个SRN包含一个服务请求控制寄存器（SRC），用于配置服务请求，例如优先级、映射到一个可用的服务提供者。\n每个SRN连接到中断路由器模块中的所有ICU，在那里，SRN的控制寄存器设置定义了目标服务提供者和服务请求的优先级。\n每个ICU处理来自映射到该ICU的SRN的竞争服务请求之间的中断仲裁。\n每个ICU连接到一个服务提供者（CPU或DMA模块），在仲裁轮中，ICU向服务提供者提供有效的获胜服务请求/SRN，并且服务提供者在处理服务请求时向ICU发回信号。\n16.4 服务请求节点 (SRN) 中断路由器模块中的每个服务请求节点（SRN）包含一个服务请求控制（SRC）寄存器和接口逻辑，该接口逻辑将其连接到中断路由器模块外部的触发单元以及中断路由器内部的中断仲裁总线（参见图173）。\n16.4.1 服务请求控制寄存器 中断路由器模块中的所有服务请求控制寄存器格式相同。通常，这些寄存器包含以下信息：\n启用/禁用信息（SRE，第9页） 服务请求设置位和服务请求清除位（SETR，CLRR，第9页） 软件粘滞位（SWS），用于指示软件发起的服务请求（SWS，第12页） 服务请求优先级向量（SRPN，第10页） 服务请求目标/服务提供者（TOS，第9页） 服务请求状态位（SRR，第9页） 向安全管理单元（SMU）信号完整性错误（第11页） 中断溢出位（IOV，第11页） 除了可以通过硬件由相关的触发单元激活外，每个SRN还可以通过软件通过两个软件发起的服务请求控制位进行设置或重置。\n16.4.1.1 通用服务请求控制寄存器格式 16.4.1.1.1 服务请求控制寄存器（SRC ： Service Request Control Register ） 本章描述了服务请求控制寄存器（SRC）的特性。\n请注意：一些模块在模块级别有额外的中断相关控制寄存器（例如，中断状态、设置清除或启用寄存器）。这些模块寄存器在相应模块章节中描述。\n服务请求控制寄存器 i ，SRCi (i=0-1023)，(00000H + i*4)\nSRC.SRPN [7:0] : 服务请求优先级\n0：最低，0xff：最高；cpu的最小值为1，dma最小值0\nSRC.SRE [10] : 服务请求使能/禁用位\nSRC.TOS [13:11] : 服务请求类型\n0：cpu0，1：DMA，2-6：cpu1-5\nSRC.ECC [20:16] : 错误纠正码\nSRC.SRR [24] : 服务请求挂起标志位\nSRC.CLRR [25] : clear SRR 清楚服务挂起位\nSRC.SETR [26] : set SRR 设置服务器请求位\nSRC.IOV [27] : hw中断触发溢出标志位\nSRC.IOVCLR [28] : clear IOV\nSRC.SWS [29] : 软件中断标志位\nSRC.SWSCLR [30] : clear SWS\n16.4.1.2 更改SRN配置 默认情况下，所有服务请求节点（SRN）均被禁用。要使用服务请求节点，必须通过将SRC.SRE位设置为 1来配置并启用它。\n服务请求节点可以针对中断服务提供者目标（SRC.TOS）和服务请求优先级编号（SRC.SRPN）进行配置。启用SRN后，可以通过以下步骤更改TOS和/或SRPN位字段：\n禁用SRN（设置SRC.SRE= 0）。 检查SRN是否已禁用（读回SRC.SRE并检查SRE= 0）。 检查寄存器LWSRx（最后的获胜服务请求，读取/轮询LWSRx，参见下述说明）： 如果LWSRx.STAT= 0或LWSRx.SRPN或LWSRx.ECC不再等于旧的SRC值，则继续进行下一步（更改SRC值）。 如果LWSRx.STAT= 1且LWSRx.SRPN和LWSRx.ECC等于（旧的）SRC值，则再次检查LWSRx。 更改SRC.TOS和/或SRC.SRPN位字段。 启用SRN（SRC.SRE= 1，写入SRC.SRE）。 如果需要重新配置的服务请求在禁用时处于挂起状态，可能该服务请求已被仲裁并提供给中断服务提供者（CPU或DMA）。在这种情况下，应延迟启用重新配置的SRN，直到上述LWSRx轮询算法完成，以确保刚禁用的SRN配置不再存在于中断系统中。如果禁用的服务请求节点映射到TriCore，读取/轮询序列的时间是非确定性的。如果ISP是DMA模块，则进入和确认在同一周期内发出。LWSRx中的 x表示需要检查与TOS设置相关的LWSR寄存器（TOS=0 -\u0026gt; LWSR0，TOS=1 -\u0026gt; LWSR1，\u0026hellip;）。\n16.4.1.3 SRC寄存器的保护 SRC寄存器通过片上总线主控TAG-ID保护（详见第16.8.1章）进行写保护。此保护由中断路由器控制寄存器ACCEN_CONFIG和ACCEN_TOSx控制。\nSRC[31:16]：受ACCEN_TOSx（x = SRC.TOS）写保护。 SRC[15:0]：受ACCEN_CONFIG写保护。 将SRC写保护划分为SRC[31:16]和SRC[15:0]的不同写保护寄存器，允许为所有服务请求节点的配置（通常在运行时是静态的）和在运行时由相关软件任务作为正常应用程序一部分使用的服务请求节点控制寄存器定义不同的保护配置（例如软件中断）。\n对SRC[31:16]进行写访问时发生访问保护违规\n当使用32位数据访问写入SRC寄存器时，仅更新未发生ACCEN保护违规的SRC寄存器部分：\n对SRC[31:16]（ACCEN_TOSx）和SRC[15:0]（ACCEN_CONFIG）的违规 不更新SRC寄存器，向SMU发送警报。 对SRC[31:16]（ACCEN_TOSx）的违规： 不更新SRC[31:16]，更新SRC[15:0]，向SMU发送警报。 对SRC[15:0]（ACCEN_CONFIG）的违规： 更新SRC[31:16]，不更新SRC[15:0]，向SMU发送警报。 SRC配置的访问保护（SRC[15:0]）\n所有SRC寄存器的下半部分SRCx[15:0]通过ACCEN_CONFIG寄存器进行写保护。这意味着，ACCEN_CONFIG的配置定义了哪些TAG ID被允许写入所有已实现的SRC寄存器的下半部分。需要注意的是，对SRC.TOS、SRC.SRE、SRC.SRPN（均映射在SRC[15:0]）的修改也会间接修改SRC.ECC位字段。\n背景 / 用例（ACCEN_CONFIG保护的SRC[15:0]）\nSRCx[15:0]包括服务请求节点的配置位/位字段，通常：\n在启动期间配置 在运行时是静态的 不应由非安全软件任务修改 ACCEN_CONFIG允许配置仅特定的TAG ID可以重新配置SRC配置，例如CPUx.DMI安全TAG ID。\nSRC控制位的访问保护（SRC[31:16]）\nSRC寄存器的上半部分SRC[31:16]通过一个ACCEN_SRC_TOSx寄存器进行写保护。保护SRN的ACCEN_SRC_TOSx寄存器由SRN的SRC.TOS配置选择：\nSRCx.TOS = 0 -\u0026gt; SRC寄存器通过ACCEN_SRC_TOS0进行写保护 SRCx.TOS = 1 -\u0026gt; SRC寄存器通过ACCEN_SRC_TOS1进行写保护 SRCx.TOS = 2 -\u0026gt; SRC寄存器通过ACCEN_SRC_TOS2进行写保护 \u0026hellip; 对于“保留”TOS编码，没有实现ACCEN_SRC_TOSx寄存器。这意味着，对于配置了保留TOS编码的SRCy，SRCy始终可以写入。服务请求到未实现的ISP（SRC.TOS=保留）将作为警报发送到SMU。\n背景 / 用例（ACCEN_SRC_TOSx保护的SRC[31:16]）\nSRCx[31:16]包括服务请求节点的控制位/位字段，可用于在运行时：\n设置服务请求（软件中断） 清除服务请求 清除中断溢出或粘滞位 通过SRC.ECC位字段注入ECC错误 如果没有这个机制，任何CPU任务和任何具有主功能的片上总线IP都可以生成对任何CPU的SW中断和/或清除任何中断。该机制使系统能够以“每CPU”为粒度封装软件任务，并限制不正确软件的副作用仅影响执行该软件的CPU。\n例如：所有映射到CPU0的SRNs（TOS=0）都通过ACCEN_SRC_TOS0进行写保护。这意味着，通过ACCEN_SRC_TOS0的配置，定义了哪些TAG ID被允许向CPU0设置或清除服务请求。ACCEN_SRC_TOS0可以配置为仅允许CPU0任务向CPU0设置软件中断。这确保了任何其他CPU或DMA通道上的损坏软件不会通过永久软件中断影响CPU0。\n在这种情况下，如果发生访问保护错误，写入操作将被静默忽略，并向SMU发送错误信号。除向SMU发出信号外，不会生成其他错误、中断或陷阱。\n16.4.1.4 请求设置和清除位（SETR，CLRR） SETR位：写入1会将SRR位设置为1。 CLRR位：写入1会将SRR位清除为0。 同时写入1到SETR和CLRR时，SRR位不会改变。 写入SETR或CLRR的值不会被存储。 写入0对这些位没有影响。 读取这些位时总是返回0。 16.4.1.5 使能位（SRE） SRE位允许中断参与选定服务提供者的仲裁。它不会启用或禁用请求标志SRR的设置；请求标志可以通过硬件或软件（通过SETR）独立于SRE位的状态进行设置。这使得服务请求可以通过硬件自动处理或通过软件轮询处理。\nSRE = 1： 如果SRE = 1，待处理的服务请求将传递给指定的服务提供者进行中断仲裁。当服务请求被服务提供者确认时，硬件会自动将SRR位重置为0。在这种情况下，建议软件不要修改SRR位，以避免由于硬件控制该位导致的意外行为。 SRE = 0： 如果SRE = 0，待处理的服务请求不会传递给服务提供者。软件可以轮询SRR位以检查是否有服务请求待处理。要确认服务请求，SRR位必须通过软件写入1到CLRR来重置。 在本文档中，“active source”指的是其请求使能位SRE设置为1，以允许其服务请求参与中断仲裁的SRN。\n16.4.1.6 服务请求标志（SRR） 当设置时，SRR标志表示有一个服务请求待处理。它可以通过硬件直接设置或重置，或通过软件使用SETR和CLRR位间接设置或重置。通过软件直接写入该位没有效果。 SRR可以由硬件或软件设置或清除，无论SRE位的状态如何。然而，只有当SRE位设置为1时，请求才会被转发进行服务。如果SRE = 1，待处理的服务请求将参与设备TOS位字段选择的服务提供者的中断仲裁。如果SRE = 0，待处理的服务请求将被排除在中断仲裁之外。 当服务请求被确认并服务后，硬件会自动重置SRR。软件可以轮询SRR以检查待处理的服务请求。在这种情况下，SRR必须通过软件写入1到CLRR来重置。 清除待处理的服务请求标志SRR和启用相应的服务请求节点（SRN）应分两步/两次写入：首先清除SRR标志（SRC.CLRR），然后启用（SRC.SRE）。\n16.4.1.7 类型服务控制 (TOS) 每个 TriCore CPU 和每个系统 DMA 实例都可以作为中断服务提供者（ISP）。服务请求节点（SRN）可以通过 TOS 位字段映射到一个确切的 ISP。\nTOS 配置将服务请求映射到：\n中断服务提供者（CPUx，DMA） 与 ISP 相关的中断路由器内部中断控制单元（ICUx），例如 TOS=0 映射到 ICU0，TOS=1 映射到 ICU1，\u0026hellip; 一个 ACCEN_SRC_TOSx 写保护寄存器，例如 TOS=0 映射到 ACCEN_SRC_TOS0，\u0026hellip; 如果 SRN 启用且配置为保留 TOS 编码，HW 或 SW 触发该 SRN 将通过警报发送到 SMU，不会有进一步的操作。\n16.4.1.8 服务请求优先级号 (SRPN) SRPN 定义了服务请求相对于同一服务提供者的其他请求源的优先级，以及相对于服务提供者本身的优先级。\n对于映射到相同服务提供者（相同 TOS 配置）的每个活动 SRN：\n可以具有唯一的 SRPN 值 可以具有非唯一的 SRPN，以赋予一组服务请求相同的优先级 对于具有相同 SRPN 的服务请求组，执行顺序无法定义 如果 SRN 未激活（即 SRE 位为 0），则 SRPN 配置没有限制 服务提供者是 CPU：\n服务请求通过位于每个 CPU 的中断向量表与服务请求优先级号相关联。这意味着 ** CPU 中断向量表按优先级号排序** 。这与传统的中断 CPU 架构不同，传统架构的中断向量表按中断源排序。CPU 中断向量表允许单个外设为不同目的设置多个优先级。 对于 CPU，SRPN 值 0000H 是一个特殊值。SRPN 为 0000H 的服务请求将被 CPU 忽略。CPU 不会确认该请求，相关的服务请求节点将因此不会被清除。由于优先级 0 是最低的服务请求优先级，它不会阻塞中断路由器仲裁。\nTriCore CPU 提供灵活的中断表对齐，可配置 8 字节或 32 字节的向量间距。另请参阅 CPU chapter\n服务提供者是 DMA：\n服务请求通过服务请求优先级号与 DMA 通道号相关联： SRPN=x 将触发 DMA 通道 x（如果 DMA 通道 x 已实现） 仅 SRPN 号在 0 到最大通道号之间会触发相关的 DMA 通道。SRPN 号大于最大通道号的请求将作为其他待处理服务请求处理，但不会触发 DMA 通道。 示例：\n对于一个 16 通道的 DMA 模块，SRPN 号 00H 将触发通道 0，07H 将触发通道 7。所有 SRPN 大于 0FH 的请求将作为其他服务请求处理，但不会触发通道。 对于一个 64 通道的 DMA 模块，SRPN 号 00H 将触发通道 0，17H 将触发通道 23，3FH 将触发通道 64。所有 SRPN 大于 3FH 的请求将作为其他服务请求处理，但不会触发通道。 损坏的 SRC 配置会触发不存在的 DMA（由于 TOS、SRPN 或SRE 损坏），ICU EDC 检查（第 16.4.1.9 章）会检测到该配置损坏的服务请求，并在中断服务提供商（此处为：DMA）确认该服务请求后立即向 ICU 发出信号。 由于 TOS，SRPN 或 SRE 的损坏而触发不存在的 DMA 的损坏 SRC 配置，将由 ICU EDC 检查检测，并在服务请求被服务提供者（DMA）确认后向 ICU 发送警报。 16.4.1.9 ECC 编码 (ECC) SRC.ECC 位字段会在以下情况下由服务请求节点（SRN）更新：\n对 SRC[31:0] 进行写操作或读-修改-写操作。 对 SRC[15:0] 进行写操作（16 位写入）。 对 SRC[15:8] 或 SRC[7:0] 进行写操作（字节写入）。 在执行 32 位写入或读-修改-写入操作时，ECC 位字段将使用计算出的 ECC 更新，写入到 ECC 位字段的数据将被忽略。\nECC 编码涵盖：\nSRC.SRPN，SRC.TOS，SRC.SRE 的新值，以及写入的 SRN 的内部 10 位索引号。 ECC 没有永久性的检查。每当挂起的服务请求被选定的（TOS）服务提供者接受为下一个处理的服务请求时，ECC 将进行检查。\nECC 错误检测机制：\nECC 错误可以通过以下方式插入（修改 ECC 位字段）： 写入 SRC[23:16]（字节写入） 写入 SRC[31:16]（16 位写入） 在当前实现中，ECC 代码仅用于错误检测。检测到的错误会报告给 SMU，但不会进行纠正。\nECC 代码：\n用于中断路由器错误检测机制的 ECC 代码是 Hsiao 22_5 代码，具有双重错误检测（DED）能力：\nGEN_ENC22_5 : if (word_width_g/(nb_mems_g*ecc_granularity_g)) = 22 and (nb_check_bits_g = 5) generate cmr22_5: for i in 0 to nb_check_bits_g - 1 generate CODE_MATRIX_ROWS(i) \u003c= code_rows_22_5(i); end generate; end generate; type rows_22_5_t is array (4 downto 0) of std_ulogic_vector(21 downto 0); constant code_rows_22_5 : rows_22_5_t := (\"0001001011001011011011\", \"0010010101010101101101\", \"0100100110100110110110\", \"1000111000111000111111\", \"1111000000111111000111\" ); 16.4.1.10 中断触发溢出位 (IOV) IOV 位由硬件设置，当以下两个条件都为真时：\n服务请求处于挂起状态。 新的服务请求通过中断触发或 SETR 位触发。 16.4.1.11 中断触发溢出清除位 (IOVCLR) 中断触发溢出清除位（IOVCLR）用于清除 IOV 位。通过向 IOVCLR 位写入 1，可以清除 IOV 位。\n16.4.1.12 软件粘滞位 (SWS) 当 SETR（请求设置位）被写入 1 时，软件粘滞位（SWS）将被设置。\n16.4.1.13 软件粘滞清除位 (SWSCLR) 软件粘滞清除位（SWSCLR）用于清除 SWS 位。通过向 SWSCLR 位写入 1，可以清除 SWS 位。\n16.5 模块中断请求触发到服务请求节点 (SRN) 的映射 所有模块中断请求都映射到中断路由器中的服务请求节点（SRN）。每个模块中断请求都有一个专用的服务请求节点（SRN）。\n每个 SRN 在中断路由器模块内都有一个唯一的 SRN 索引号。索引号并不是中断路由器模块本身功能所必须的。索引号可以用于通过 OTGM 功能选择一个服务请求节点进行观察。\n服务请求控制（SRC）寄存器的索引号可以直接从其在 SRC 地址范围内的地址偏移量中计算出来，详见第 16.5.1 章。\n中断路由器模块有一个 1024 个中断触发输入向量。每个中断触发输入向量位 [x] 与 SRN 索引号 x 的一个 SRN 相关联。这意味着在中断触发输入向量位 [x] 上的触发脉冲将触发 SRN [x]。\n中断触发信号的正边沿被解释为中断触发。详见第 16.5.3 章。\n16.5.1 SRC 索引号 每个服务请求节点（SRN）都可以通过其专用的服务请求控制寄存器（SRC）进行配置和控制\n与某个模块实例相关的 SRC 寄存器的地址在整个 Aurix 系列中都是相同的（例如，QSPI0 的中断）。\n每个 SRC 在中断路由器模块中都有一个唯一的索引号。\n服务请求控制（SRC）的索引号可以直接通过其在 SRC 地址范围内的地址偏移量来计算：\n索引号(SRC) = \u0026lt;SRC 地址偏移量\u0026gt; / 4 示例：\nSRC_BCU_SPB 的偏移量为 20Hex（见第 16.13 章） 索引号(SRC_BCU_SPB) = 20Hex / 4 = 8 16.5.2 与调试复位相关的中断 为了软件调试的目的，AURIX 设备需要一些仅与调试复位相关的服务请求节点（SRN）。这些 SRN 在非调试复位（例如应用复位）情况下保持其 SRC 寄存器内容和挂起的服务请求状态。结合其他与调试复位相关的调试逻辑（例如断点逻辑），这允许用户软件在应用复位后调试导致应用复位的情况。\n16.5.3 服务请求触发信号的时序特性 中断路由器由系统外围总线（SPB）时钟驱动。对于模块中断/服务请求触发信号到中断路由器的规则如下：\n触发信号必须与 SPB 时钟同步 中断路由器的触发输入是边沿敏感的（对正时钟边沿敏感） 触发信号脉冲的最小高电平长度为一个 SPB 时钟周期，高电平脉冲长度可以大于 1 个 SPB 时钟周期 与调试相关的触发信号脉冲应由相关模块保持高电平，直到触发被处理 16.6 中断控制单元 (ICU) 中断路由器模块包括每个服务提供者（如 CPU 和 DMA 模块）对应的一个中断控制单元 (ICU)，每个 ICU 与一个服务提供者相关联。服务请求节点 (SRN) 可以通过 SRN 的 SRCx.TOS 寄存器位字段映射到其中一个 ICU（参见图 173）。\nICU 的功能包括：\n管理映射到 ICU 的 SRN 之间竞争的服务请求的仲裁。 向服务提供者提供仲裁轮次的胜利者。 接收来自服务提供者的信息，表明哪个服务请求被接受。 检查被接受的服务请求信息（ECC 检查）。 向安全管理单元 (SMU) 发出完整性错误信号。 管理相关 SRN 中被确认的服务请求的清除。 当前实现中，ECC 代码仅用于错误检测。检测到的错误会报告给 SMU，但不会被纠正。\n16.6.1 ICU 与 ISP 的接口 ICU 和连接的 ISP 之间的接口由中断路由器的 EDC 保护覆盖。为了增强接口的稳健性，在没有服务请求信号发送给 ISP 或 ISP 未确认服务请求给 ICU 的情况下，ICU 和 ISP 输出会被设置为默认值。\n当 VALID 信号发生卡住在高电平的错误时，CPU 将忽略默认信息（SRPN=8\u0026rsquo; h00），而 DMA 将触发通道并确认默认信息给 ICU，ICU 会通过 EDC 保护检测到此情况并向 SMU 发送警报。\n当 ACKNOWLEDGE 信号发生卡住在高电平的错误时，ICU 会采用默认值并检测到 EDC 错误。\n只要 ICU 未向连接的 ISP 发送服务请求（VALID=0），ICU 输出信号将设置为以下默认值：\nIDX = 10\u0026rsquo;h 000 PIPN/SRPN = 8\u0026rsquo;h 00 ECC = 5\u0026rsquo;h 00 只要 ISP 未确认服务请求给相关的 ICU（ACKNOWLEDGE=0），ICU 输出信号将设置为以下默认值：\nIDX = 10\u0026rsquo;h 000 PIPN/SRPN = 8\u0026rsquo;h 00 ECC = 5\u0026rsquo;h 00 16.6.2 ICU 控制寄存器 本节描述中断控制单元 (ICU) 寄存器。每个 ICU 包含两个控制寄存器：\nLWSR：最新获胜服务请求寄存器（第 16 页）提供有关上一次服务请求仲裁轮次的获胜者的信息。 最后确认服务请求寄存器（第 17 页）提供有关被服务提供者接受的最后一个服务请求的信息。 错误捕获寄存器（第 17 页）在 ICU 检测到 ECC 错误时捕获最后确认服务请求寄存器的内容。 16.6.2.1 LWSR：最新获胜服务请求寄存器 最新获胜服务请求寄存器 x，与 ICUx 相关。\n该寄存器提供有关上一次仲裁轮次获胜者的信息。寄存器位字段表示 ICU 向中断服务提供者提供的内容。\nLWSRx (x=0-7) 最新获胜服务请求寄存器 x，与 ICUx 相关 (0200H+x*10H)，default：0\nLWSR.PN [7:0] : Latest Winner Priority Number\nLWSR.ECC [14:10] : Latest Winner ECC\nLWSR.ID [25:16] : Latest Winner Index Number of SRN\nLWSR.STAT [31] : LWSR Register Status，是否有效\n16.6.2.2 LASR：最后确认的服务请求寄存器 最后确认的服务请求寄存器 x，与 ICUx 相关。\n最后确认的服务请求寄存器提供了有关被中断服务提供者 (ISP) 确认的最后一个服务请求的信息。寄存器位字段显示了中断服务提供者与最新确认一起发送的内容。\nLASRx (x=0-7) 最后确认的服务请求寄存器 x，与 ICUx 相关 (0204H + x*10H)，复位值: 0\nLASR.PN [7:0] : Last Acknowledged Service Request Priority Number\nLASR.ECC [14:10] : Latest Acknowledged Interrupt ECC\nLASR.ID [25:16] : Last Acknowledged Interrupt SRN ID\n16.6.2.3 ECR：错误捕获寄存器 错误捕获寄存器 x，与 ICUx 相关。\n在检测到 ECC 错误时，错误捕获寄存器 (ECRx) 会捕获相关的服务请求信息。这是通过在检测到 ECC 错误时，将最后确认的服务请求 (LASRx) 寄存器的内容更新到 ECR 来实现的。ECR 始终显示检测到 ECC 错误时的最后一次 ECR 内容。\n软件可以通过写入 ECRx 来清除 ECR 位字段中的 PN，ECC，ID。错误状态 (STAT) 和错误溢出 (EOV) 位可以用作错误处理机制，并指示错误信息的丢失。如果 ECR.EOV 被软件清除，则 ECR.EOV 必须与 ECR.STAT 一起清除。如果在 ECR.EOV 清除的同时检测到新的错误，硬件会再次设置 ECR.EOV，而 ECR.STAT 则被清除。\n注意: 在当前的实现中，ECC 代码仅用于错误检测。检测到的错误会报告给 SMU，但不会被纠正。\nECRx (x=0-7)\n错误捕获寄存器 x，与 ICUx 相关 (0208H + x*10H)，复位值: 0\nECR.PN [7:0] : Service Request Priority Number\nECR.ECC [14:10] : Service Request ECC\nECR.ID [25:16] : Service Request Node ID\nECR.EOVCLR [28] : Error Overflow Bit\nECR.STATCLR [29] : Error Status Bit\nECR.EOV [30] : Error Overflow Bit\nECR.STAT [31] : Error Status Bit，错误检测标志位\n16.7 通用服务请求，服务请求广播 INT 模块提供了多个通用服务请求 (GPSR) 组，以及通过软件并行触发 GPSR 组中多个服务请求的机制（见 16.7.2 章节）。\n通用服务请求主要用于软件中断，因为它们并未映射到硬件中断触发事件\n16.7.1 通用服务请求 (GPSRxy) INT 模块提供了多个通用服务请求组：\n每个通用服务请求组包含八个服务请求节点 (SRN)。 通用服务请求命名为 SRC_GPSRxy。 x = 组号; y= 组内的中断号, y=0:7\nGPSR 主要用于软件中断（未映射到硬件服务请求触发器）。 GPSR 只能通过向相关的 SRC_GPSRxy.SETR 位写入 1 或通过向相关的服务请求广播寄存器 SRBx[y] 写入 1 来触发。 16.7.2 服务请求广播寄存器 (SRBx) 服务请求广播寄存器 (SRBx) 可用于并行向多个服务提供者（CPU 或 DMA）发送服务请求。\n每个通用服务请求组 (GPSRxy) 对应一个服务请求广播寄存器 (SRBx)。 SRBx 可用于并行触发 SRC_GPSRx 组内的多个服务请求。 SRBx 总是读取为 0。 向 SRBx[y] 写入 1 触发服务请求 GPXRxy。 向 SRBx[31:6] 写入 1 无效。 16.7.3 SRBx 寄存器的访问保护 (ACCEN_SRBx) 每个 SRBx 寄存器通过专用的 ACCEN_SRx0 / ACCEN_SRBx1 寄存器组进行写保护：\n每个 SRBx 寄存器都有一个相关的 ACCEN_SRBx 寄存器。 ACCEN_SRBx 的配置定义了哪个 TAG ID 可以写入相关的 SRBx 寄存器。 如果发生访问保护违规，写操作将被静默忽略，并向 SMU 报告错误。除此之外，不会生成其他错误、中断或陷阱。 16.8 系统寄存器 中断路由器模块不支持 CLC, OCS 和 KRSTx 寄存器。中断路由器支持多组访问启用 (ACCEN) 寄存器：\nINT_ACCENx：寄存器访问保护通过标准 ACCEN 寄存器实现，但包括 ACCEN_CONFIG0/1、ACCEN_SRBx0/1 和 ACCEN_SRC_TOSx0/1。 INT_CLC：中断路由器模块不支持时钟控制 (CLC) 功能。 INT_KRSTx：中断路由器模块不支持模块内核重置功能。 OCS：中断路由器不支持 OCDS 控制和状态寄存器。 16.8.1 中断路由器寄存器的写保护 中断路由器模块提供基于主 TAG ID 的写访问保护，作为 AURIX 安全概念的一部分。每个具有直接或间接总线主控能力的片上资源都有一个唯一的主 TAG ID，可用于标识片上总线事务的主控。\n中断路由器模块通过三个访问启用寄存器/寄存器组提供控制寄存器的写保护：\n服务请求广播寄存器的访问保护 (ACCEN_SRBx0/1)： 中断路由器模块提供一个或多个通用服务请求组 (GPSRx)。 每个 GPSRx 组都有一个专用的服务请求广播寄存器 (SRBx)，可用于并行设置组中的多个服务请求节点。 静态控制寄存器的访问保护 (ACCEN_CONFIG0/1)： ACCEN_CONFIG 提供对以下寄存器的写访问保护： 所有 SRC 寄存器的低 15 位 (SRCx[15:0])，包括 TOS、SRE 和 SRPN 位字段。 所有 ICU 错误捕获寄存器 (ECRx)。 SRC 控制寄存器的访问保护 (ACCEN_SRC_TOSy)： ACCEN_SRC_TOSy 提供对 SRCx[31:16] 的写访问保护。 16.8.2 内核复位寄存器 (KRST1/0, KRSTCLR) INT 模块不包括内核复位寄存器 (KRST1, KRST0, KRSTCLR)。\n注意： 中断路由器模块不支持模块内核复位。\n16.8.3 时钟控制寄存器 (CLC) INT 模块不包括模块时钟控制 (CLC)。\n注意： 中断路由器模块不支持时钟控制寄存器功能，这意味着不能通过 CLC 寄存器禁用中断路由器模块的时钟。\n16.8.4 OCDS 控制和状态寄存器 (OCS) INT 模块不包括 OCDS 控制和状态 (OCS) 寄存器。\n注意： 中断路由器模块不支持 OCS 寄存器功能。\n16.9 仲裁过程 在中断模块中，每个 ICU 都有其自己的中断总线。每个服务请求节点 (SRN) 都可以通过将 SRC.TOS 位字段设置映射到相关的 ICU / 中断总线，将其定向到一个服务提供者。\n当有第一个待处理的服务请求时，相关的中断总线将开始第一次仲裁过程。相关的中断控制单元 (ICU) 将提供在上一次仲裁过程中获胜的服务请求。\n仲裁过程使用 3-4 个系统外围总线 (SPB) 时钟周期来确定具有最高优先级编号 (SRPN) 的待处理服务请求。确切的实现方式在模块实现章节中有所描述。\n在仲裁过程中，中断总线会比较所有映射到该中断总线的待处理服务请求节点 (SRN) 的 SRC.SRPN 位字段。仲裁过程中，具有最高优先级编号的待处理服务请求被确定为获胜者，并将相关的 SRN 服务请求控制寄存器位字段值 (SRPN, ECC 和 SRN 的索引) 提供给 ICU。 ICU 将这些信息 (SRPN, ECC, SRN 索引) 提供给服务提供者。当服务提供者返回确认信息时，ICU 将进行 ECC 校验。ECC 校验使用接收到的值：ECC, SRPN, SRN 索引号，假定为 1 的 SRE 位 (SRN 启用) 以及 ICU 的 TOS 编号。\n中断路由器模块会将检测到的错误信号发送到安全管理单元 (SMU)（SMU 中的一位，涵盖所有 SRN 和 ICU 的错误）。\n当前实现中，ECC 代码仅用于错误检测，检测到的错误会报告给 SMU，但不会进行纠正。\n16.9.1 每个仲裁过程的时钟周期数 中断路由器的实现可以根据以下方面进行配置：\n支持的服务请求数量 (Service Request Nodes, SRN，最多可达 1024) SRPN 位大小 (8 位) 支持的服务提供者数量 (中断控制单元，ICU) 每个服务请求仲裁的时钟周期数 (3-4 个 SPB 时钟周期) 在 AURIX 产品中实现的中断路由器模块的特性在模块实现子章节中有所描述。\n第178图显示了一个中断路由器在3周期仲裁过程中的中断时序。\nCycle 1: ICU没有待处理的服务请求（因此没有仲裁轮次）。\nCycle 2: 一个模块通过向中断路由器模块中的相关服务请求节点（SRN）发送一个脉冲来触发一个服务请求。\nCycle 3-5: 在所有发送给ICU的待处理服务请求之间进行仲裁，比较所有待处理请求的服务请求优先级编号（SRPN），并确定最高优先级的请求为获胜请求。\nCycle 6: ICU将获胜的服务请求提供给服务提供者，包括SRPN，ECC和SRN索引。\nCycle 7 \u0026ndash; n-1: ICU重新仲裁，当有另一个SRN的新服务请求挂起时，如果该新请求具有更高的SRPN（更高优先级），则提供新的获胜服务请求给ICU。\nCycle 6 \u0026ndash; n-1: 中断服务提供者接收最新的获胜SRN的信息（Enter）。\nCycle n: 服务提供者确认服务请求，提供已确认的服务请求的SRPN、ECC、SRN索引信息。同时，ICU在同一个时钟周期内将信号更改为“无有效服务请求”。\nCycle n+1: ICU对确认信息进行ECC检查，包括SRPN，ECC，SRN索引、SRE=‘1’（SRN已启用）、ICU的TOS编号。如果出现不匹配，则向SMU报告完整性错误，SRPN、ECC和索引会被捕获到ECR中。硬件将清除已确认的SRN索引号的服务请求。\nCycle n+2: 如果ICU中至少有一个服务请求待处理，则在所有待处理服务请求之间进行新的仲裁。\n16.9.2 服务请求有效性 (Service Request Valid) ICU 通过断言 Valid 信号向 ISP 提供仲裁获胜的待处理服务请求的信息。在 ISP 断言 Enter 信号之前，将继续重新仲裁。\n16.9.3 服务请求进入 (Service Request Enter) 当中断服务提供者 (ISP) 接收到服务请求的有效信息后，向 ICU 发送 Enter 信号，表示它已开始准备执行相关的中断服务例程 (ISR)。ISP 可以通过 Acknowledge 信号（表示中断服务例程已经开始执行，ICU 将清除相关的 SRN）或在没有 Acknowledge 信号的情况下重置 Enter 信号（例如，当 CPU 在能够开始 ISR 之前陷入陷阱或异常时，ICU 将不会清除相关的 SRN）。\n16.9.4 服务请求确认 (Service Request Acknowledge) 当服务提供者开始执行 ICU 提供的服务请求时，服务提供者会向 ICU 发送确认信号 (Acknowledge)。同时，服务提供者会将已执行的服务请求的信息 (SRPN, ECC, SRN 索引号) 发送回 ICU。在同一时钟周期内，服务提供者发送确认信号，ICU 将状态更改为“没有可用的服务请求”：ICU 不会再向服务提供者提供仲裁获胜者。ICU 的这种行为确保在 SRN 被重置之前，已确认的服务请求不会再次被提供（参见图 178）。\n16.9.5 处理检测到的 ECC 错误 ICU 会对其从服务提供者接收到的确认信息 (TOS, SRPN, Index 和 ECC) 以及 ICU 本身的 TOS 编号进行错误检测校验。SRE 位假定为 1（SRN 已启用）。SRN 中的 ECC 覆盖了 SRC 位字段的值：SRC.SRPN, SRC.SRN 索引, SRC.SRE 和 SRC.TOS（参见图 178）。\n在当前实现中，ECC 代码仅用于错误检测，检测到的错误会报告给 SMU，但不会进行纠正。\n如果 ICU 检测到 ECC 错误：\nICU 会在错误捕获寄存器 (ECRx) 中捕获显示 ECC 错误的 ECC, SRPN 和索引，设置 ECRx.STAT 位，并在 STAT 位仍然设置时设置 ECRx.EOV 位。 ICU 通过中断路由器错误信号向 AURIX TM TC3xx 平台安全管理单元 (SMU) 发出错误信号。SMU 将此信息转发给 CPU（如果启用）。 ICU 清除 SRN 中的服务请求（由索引选择）。 收到“中断路由器中检测到 ECC 错误”信息的 CPU 可以通过错误状态位 (ECRx.STAT= 1) 识别 ICU，读取相关服务请求信息，并通过写入 1 清除 ECRx.STAT 位。CPU 还可以通过错误溢出位 (ECRx.EOV= 1) 确定是否检测到一个或多个 ECC 错误。 16.10 中断系统的使用 以下部分简要介绍了服务提供者与中断路由器 ICU 的接口。\n中断路由器中的所有 ICU 子模块具有相同的功能。\n16.10.1 CPU 到 ICU 接口 中断路由器模块为每个 CPU 和 DMA 模块提供了一个专用的中断控制单元 (ICU)。CPU ICU 接口由一组寄存器组成，CPU 在其中接收 ICU 提供的服务请求信息（SRPN, SRN 索引, ECC）。当 CPU 确认服务请求时，这些信息将被发送回 ICU（参见 16.4.1.8 章节）。\nCPU ICU 接口包含一个中断控制寄存器 (ICR)，该寄存器包含当前 CPU 优先级编号 (CCPN)、全局中断启用/禁用位 (IE) 和挂起中断优先级编号 (PIPN)。CPU ICU 接口的进一步细节以及 CPU 处理中断的方式可以在 CPU 章节中找到。\n16.10.2 DMA 到 ICU 接口 中断路由器模块为每个 DMA 模块提供了专用的中断控制单元 (ICU)。DMA 接管来自 ICU 的服务请求信息，触发相关的 DMA 通道，并立即向 ICU 确认，随后相关的 SRN 被清除。\nDMA 到 ICU 接口由一组寄存器组成，其中它接管 ICU 提供的服务请求信息（SRPN, SRN 索引, ECC）。DMA 在下一个时钟周期内向 ICU 发送确认（参见 16.4.1.8 章节）。\nDMA 通道的优先级方案与 SRPN 优先级方案相同：\nDMA 内的最低优先级：通道 0 最低优先级：SRPN = 0 16.10.3 软件触发的中断 (Software-Initiated Interrupts) 任何服务请求节点 (SRN) 都可以用作软件中断。软件可以通过写入服务请求控制寄存器 (SRC) 中的服务请求位 (SRR)，在任何 SRN 中设置服务请求位，从而触发服务请求。这些服务请求将通过与硬件触发的服务请求相同的机制处理。一旦在 SRN 中设置了 SRR 位，软件触发的服务请求和硬件触发的服务请求将无法区分。因此，软件应该仅使用未用于硬件触发服务请求的 SRNs 和中断优先级编号。\n设备为每个 TriCore CPU 提供了一组通用服务请求 SRNs，每个组包括 8 个 SRNs，这些 SRNs 不连接到内部或外部的硬件触发信号，因此只能用作软件中断或软件触发的服务请求。这些 SRNs 被称为通用服务请求节点 (SRC_GPSRxy, x=组号, y=0-7)。\n此外，任何未使用的 SRN 也可以用于生成软件中断。\n16.10.4 外部中断 (External Interrupts) 有 8 个 SRNs (Int_SCUSRC[7:0]) 保留用于处理外部中断。外部 GPIO 端口输入信号（例如边沿触发或电平触发）的设置，包括中断请求的触发方式，受外部请求单元 (ERU) 控制。ERU 的功能在 SCU 章节中有详细描述。\n16.11 使用案例 (Use Case Examples) 本节展示了中断系统的使用案例和 OTGS 的使用案例。\n16.11.1 中断处理程序的使用案例 (Use Case Example Interrupt Handler) 本节解释了如何组织 TriCore 中断向量表。当 TriCore 接受中断时，中断向量表的入口地址由 TriCore 寄存器 BIV（基中断向量表指针）和该中断的优先级编号 (PIPN) 计算得出。TriCore TC1.6P 和 TC1.6E 架构提供了配置向量表条目间距的可能性，可以设置为 32 字节（参见下图 a（图 179））或 8 字节（参见下图 b（图 179））。第三种选择是通过屏蔽 PIPN 将向量表缩减为单个条目（参见下图 c（图 179））。\nc): 单入口地址，软件区分中断handler\n通过使用32字节配置，小型中断程序可以直接在向量表中实现。它们甚至可以跨多个向量条目实现（参见TriCore架构手册）。如果向量表可以位于 TriCore 程序端内存中，这种快速中断处理就很有用。8字节配置减少了向量表的大小。每个向量条目仅包含一个跳转指令或一个调用和返回作为16位操作码指令。 TriCore编译器通过关键字或函数支持这种类型的中断向量表生成 。如果BIV屏蔽了PIPN，使得任何中断地址计算结果相同，则可以配置最小的向量表。例如：\n__mtcr(BIV,0x80000001 | 0xFF\u003c\u003c3); // 将值写入核心寄存器BIV这将BIV寄存器配置为使用一个通用的单个条目，其中函数 interruptHandler位于此处，通过使用函数指针数组分支到特定的中断例程。如果使用一个指向数组的指针，该数组可以快速切换。\n初始化和安装中断的步骤描述\n定义ISR指针数组：最多可以有255个中断。 定义指向ISR指针数组起始位置的指针。 开始编写 interruptHandlerInstall函数：此函数用于在数组中安装中断。所需信息是中断优先级和ISR入口地址。 将ISR入口地址存储在数组中。 编写 interruptHandler函数：在中断发生后立即调用此函数，并分支到特定的中断例程。 分支到特定的中断例程。 在ISR处理完毕后执行返回命令。 初始化和安装中断的C代码示例\n(1) void (*isr_pointer_array[256])(void); (2) void (**isr)(void) = isr_pointer_array; (3) void interruptHandlerInstall(long int SRprio, long int addr) { (4) *isr_pointer_array[SRprio] = addr; } (5) void interruptHandler(void) { (6) isr[__mfcr(ICR) \u0026 0xFF](); (7) asm (\"rfe\"); // 从事件返回 }在这个例子中，中断入口地址存储在数据数组中，而不是将值编码到指令中。interruptHandlerInstall函数负责组织在该数组中安装中断（参见在STM章节中的模块用例示例）。这种向量表生成方式有时比8字节配置更灵活，并且不需要编译器对中断的特定支持。\n在中断能够发生之前，必须全局启用中断系统。中断控制寄存器（ICR）包含全局中断使能位（ICR.IE），该位启用CPU服务请求系统。大多数编译器支持使用类似以下的属性：__enable(); 来设置此位。详细信息请参见架构手册。\n16.12 模块实现 16.12.1 中断路由器模块的特性 表553显示了不同TC3xx设备中实现的中断路由器配置。共享仲裁按ICUx对实现，从ICU0开始（ICU0/ICU1，ICU2/ICU3，\u0026hellip;\u0026hellip;）。\n16.13 中断路由器系统和模块寄存器 图180显示了设备中与中断路由器模块相关的所有寄存器。中断路由器分配了两个地址范围：\n2 * 256字节地址范围：覆盖中断路由器系统寄存器、ICU控制寄存器和OTGM寄存器。\n8 KB地址范围：覆盖服务请求控制寄存器。\n使用的访问保护寄存器缩写列表 P0 -\u0026gt; ACCEN_SRBx：相关SRBx寄存器的写保护。服务请求广播寄存器（SRB）的数量和相关的ACCEN_SRB寄存器的数量与已实现的TriCore CPU数量相等。 P1 -\u0026gt; ACCEN_CONFIG：写保护所有SRCx[15:0]和ICUx错误捕获寄存器（ECRx）。 P2 -\u0026gt; ACCEN_SRC_TOSx：写保护所有映射到TOSx的SRC的位[31:16]（SCR.TOS=x）。对于每个已实现的中断控制单元，实现一个ACCEN_SRC_TOSx寄存器。 访问保护的违规行为不会被执行（例如，通过具有禁用的主标记ID的SPB访问写入到受 Px/ACCEN保护的寄存器）。在这种情况下，访问保护错误将被信号发送到SMU。除了向SMU发出信号外，不会产生其他错误、中断或陷阱。\nSystem Control Unit (SCU) chapter, External Request Unit (ERU)\nSTM章节 tc397中断 与 arm gic中断区别\n","date":"2025年7月8日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/tricore/tc397_interrupt/","series":[{"title":"Tc397 架构系列","url":"/series/tc397-%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97/"}],"smallImg":"","tags":[{"title":"Tc397中断","url":"/tags/tc397%E4%B8%AD%E6%96%AD/"},{"title":"中断管理","url":"/tags/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"}],"timestamp":1751986567,"title":"Tc397中断子系统"},{"authors":[],"categories":[{"title":"J6M","url":"/categories/j6m/"}],"content":" J6M\nJ6 开发者文档\n","date":"2025年7月7日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/arm/j6m/","series":[{"title":"J6M","url":"/series/j6m/"}],"smallImg":"","tags":[{"title":"J6M","url":"/tags/j6m/"}],"timestamp":1751868731,"title":"J6M"},{"authors":[],"categories":[],"content":"","date":"2025年7月6日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/onlinetools/timestamp/","series":[],"smallImg":"","tags":[],"timestamp":1751760000,"title":"时间戳转换"},{"authors":[],"categories":[{"title":"理财科普","url":"/categories/%E7%90%86%E8%B4%A2%E7%A7%91%E6%99%AE/"}],"content":"货币基金是最基础、最稳健的一类基金产品，也是许多人接触基金投资的第一步。它风险极低，流动性强，堪称“余额宝的亲戚”。\n本文将用通俗语言，带你快速了解货币基金的原理、收益、风险以及适合人群。\n🏦 什么是货币基金？ 货币市场基金（Money Market Fund）是一种投资于短期、高流动性、低风险的金融工具的基金。主要投向包括：\n国债、央行票据 银行定期存单（NCD） 回购协议 短期债券（期限不超过 397 天） 这类基金主要用于保值、流动性管理，风险极低，历史上极少发生亏损。\n类型 投资标的 流动性 预期收益 风险水平 适合场景 货币基金 存款、同业存单、回购 T+0/T+1 1.5%–2.3% 极低 临时闲钱、零钱管理 短债基金 剩余期限 \u0026lt;1年债券 T+1 2%–3.5% 很低 几个月内不用的钱 纯债基金 中长期债券（无股票） T+1/T+2 3%–4.5% 低 中期稳健理财 定开债基 同上，但定期开放 固定周期T+n 3.5%–5% 低 不急用的资金配置 可转债基金 可转债为主 T+1/T+2 5%–10% 中等 看好股市又怕大跌 混合债基 债+股+转债 T+1 6%–12% 中高 想增强收益 📌 简记口诀：货币流动快，短债期限短，纯债更稳健，定开锁一段。\n💰 收益来源 货币基金的收益来自于上述资产的利息收益。例如：\n银行协议存款利息 回购利率（如 7 天回购） 央票利息等 其收益是 浮动的，按“万份收益”和“7 日年化收益率”来展示。\n指标名称 含义 万份收益 每 1 万元每天可获得的收益 7 日年化 最近 7 天平均收益，年化后展示 ⚖️ 与银行活期对比 项目 货币基金 银行活期 收益率 通常在 1.5~2.5% 0.25% 左右 流动性 随存随取，一般 T+1 到账 随存随取 风险等级 极低，但非绝对保本 国家兜底 提现到账速度 普通为 T+1，部分支持快速赎回（2 小时内） 实时 每支货币基金当天可以快速到账1w的话，可以分散购买达到提高每天的提现额度\n🚨 有哪些风险？ 虽然风险非常小，但货币基金并非绝对安全：\n流动性风险：极端市场情况下（如大规模赎回）可能暂停提现 利率波动风险：利率下降，收益率也会随之降低 信用风险：投资标的若出现违约可能影响收益 ✅ 历史上货币基金“负收益”极为罕见，但非不可能。\n✅ 谁适合投资货币基金？ 想让“闲钱”多赚点利息的人 不懂投资、不想承担波动风险的新手 需要流动性强的资金管理工具（替代活期） ✅ 常见用途： 替代活期存款（余额宝即为货币基金） 临时资金过渡（买房、还贷前过渡） 股基/债基中转站（用于分仓打新） 🧠 投资建议 不是保本产品，但安全性很高，可放心持有 选基金看品牌（天弘、华夏、易方达等），更重要的是费率、流动性、历史表现 不建议长期重仓，适合作为理财“底仓”或资金泊位 📌 为何不建议长期重仓货币基金？ 原因 说明 收益太低 年化仅 1.5%–2.3%，跑不赢通胀 无复利优势 收益低、波动小，长期复利效应微弱 资金占用机会 占用可用于更高收益资产的资金 税收优势弱化 货基免税优势对高净值人群作用有限 ✅ 长期投资替代方案（按风险偏好） 风险偏好 推荐资产配置 年化预期 特点 极低风险 定开纯债 + 短债基金 3%–4% 稳健增值，适合保守型投资者 中等风险 60% 指数基金 + 40% 债基 6%–8% 波动适中，收益稳定 较高风险 80% 指数基金 + 20% 短债/货基 8%–12% 长期成长，波动大 全球配置 MSCI全球 + 标普500 + A股ETF 6%–10% 分散风险，应对单国波动 货币基金适合作为流动资金池，不宜重仓长期持有。应将长期资金投入能跑赢通胀、具备复利效应的资产如指数基金或优质债基中。\n指数基金 “美股十年翻倍，A股十年原地踏步”——这不是段子，是一场指数设计哲学的实战对比。\n想要长期投资，买了“上证指数”基金； 看着美股指数节节攀升，自己的账户却亏钱； 明明“押注国家崛起”，结果却成了“韭菜收割”？ 问题不在市场本身，而在指数背后的“设计者思维”。\n主要指数及分支指数基金对比表 指数名称 代表市场 投资标的特点 主要成分特点 历史表现（长期） 风险水平 典型基金示例 适合投资者 上证指数 中国A股主板 大盘股，国企为主 国企权重高，周期和资源类居多 低或负收益 高 易方达上证50ETF 国内价值投资者 深证成指 中国中小盘股 中小市值成长股较多 创新企业、消费及科技较多 中等波动大 中高 华夏成长ETF 看好中国成长股 沪深300 中国大盘蓝筹 蓝筹股集中，市场代表性强 行业分布较均衡 较稳健 中 嘉实沪深300ETF 追求稳健成长投资者 标普500 美国大型股 500大盘蓝筹股 高科技与消费龙头集中 年化约10% 中 VOO、SPY、IVV 全球长期稳健投资者 纳斯达克100 美国科技成长股 科技、互联网成长股为主 主要科技巨头 年化约12-15% 高 QQQ 追求高成长投资者 MSCI全球指数 全球市场 全球发达及部分新兴市场 行业和国家多元化 平衡增长 中 iShares MSCI ACWI ETF 全球配置投资者 恒生指数 香港市场 香港大型蓝筹股 金融、地产占比高 波动较大 中 南方恒生ETF 关注港股及中国海外股 📊 为什么标普500长期上涨？ ✅ 成分公司选择逻辑 标普500 不是“谁市值大谁进”，而是：\n财报盈利连续 4 个季度为正 流动性强，代表行业龙头 审核委员会主观把关，不符合就踢出去 这意味着：\n劣质企业进不了 表现差的会被剔除 指数“自动优化” ✅ 权重设计逻辑 使用自由流通市值加权（即市值×流通比例） 科技龙头占据核心（如苹果、英伟达、微软） 它不是“平均持股”，而是“抱紧赢家”\n📉 为什么上证指数反而让人亏钱？ ❌ 指数成分问题 按“总市值”加权，国企占比极大 龙头是工商银行、中国石油、宝钢、中国建筑等低增长老企业 科技、消费、新能源等优质成长股权重极低 ❌ 剔除机制形同虚设 僵尸企业、亏损国企常年霸榜 没有动态优化 指数就像“老龄化人口结构”，缺乏活力 ❌ 新股扩容稀释收益 新股频繁上市，不断“抽水” 权重重新洗牌，老股不涨，新股抢流 散户投资就像不断被“摊薄”的股东 🔍 举个例子 指数 2008–2024年涨幅 年化收益 最大回撤 标普500 +330% 以上 ~10% -55%（2008） 纳指100 +800% 以上 ~13% -80%（2000科网泡沫） 上证指数 基本持平（或负收益） ~0%–1% 多次腰斩 🧠 怎么做？ ✅ 看好中国发展，请考虑： 沪深300（结构更优） 中证500 / 中证红利（成长性 \u0026amp; 分红） ETF 行业精选：新能源车、医疗、科技等 ✅ 做全球配置，别只靠A股： 有其他券商？买 VOO、QQQ 等美股 ETF 没有？也可以通过买 513500、513100 等跟踪美股的ETF ","date":"2025年7月5日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/misc/investment/funds/","series":[{"title":"投资理财","url":"/series/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/"}],"smallImg":"","tags":[{"title":"货币基金","url":"/tags/%E8%B4%A7%E5%B8%81%E5%9F%BA%E9%87%91/"},{"title":"基金基础","url":"/tags/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80/"},{"title":"零风险理财","url":"/tags/%E9%9B%B6%E9%A3%8E%E9%99%A9%E7%90%86%E8%B4%A2/"},{"title":"收益计算","url":"/tags/%E6%94%B6%E7%9B%8A%E8%AE%A1%E7%AE%97/"},{"title":"指数基金","url":"/tags/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91/"}],"timestamp":1751729103,"title":"货币基金"},{"authors":[],"categories":[{"title":"电动车续航测试","url":"/categories/%E7%94%B5%E5%8A%A8%E8%BD%A6%E7%BB%AD%E8%88%AA%E6%B5%8B%E8%AF%95/"}],"content":" 随着电动车的普及，各家厂商纷纷标榜自家车型“续航 600 公里、700 公里”，但用户实际体验往往达不到标称。为什么？这背后关键在于所采用的测试标准不同。\n本文将带你了解目前全球主流的几种电动车测试标准：CLTC、WLTP、EPA、NEDC，比较它们的特点、优缺点，以及哪种更贴近日常使用。\n🧭 常见测试标准一览 标准 地区 全称 当前状态 启用时间 CLTC 中国 China Light-duty Vehicle Test Cycle ✅ 现行 2021 年起 WLTP 欧洲、日韩 Worldwide Harmonized Light Vehicle Test Procedure ✅ 现行 2017 年起 EPA 美国 Environmental Protection Agency Test Cycle ✅ 现行 1970s 起，持续迭代 NEDC 欧洲、中国（旧） New European Driving Cycle ❌ 已淘汰 1997~2020 🧪 各测试标准简要说明 🇨🇳 CLTC（中国标准） 由中国工信部制定，2021 年起替代 NEDC 以城市低速工况为主，起步/停车频繁 测试环境理想化（不含空调、电器负载） 优点：宣传续航高；缺点：偏差太大 🇪🇺 WLTP（全球统一轻型车测试程序） 由联合国欧洲经济委员会（UNECE）制定 包含低速、中速、高速、超高速四段工况 模拟更广泛的驾驶行为和交通情景 优点：中庸实用；缺点：仍略乐观 🇺🇸 EPA（美国环保署标准） 包含城市、市郊和高速测试，考虑空调负载 所有主流第三方测评网站普遍采用 被认为最贴近日常驾驶 优点：可信度高；缺点：宣传数字不好看 ❌ NEDC（已淘汰） 原为欧盟标准，测试条件极度理想化，后被 CLTC、WLTP 替代 工况过于温和，平均速度低，未考虑现实情况 经常导致续航虚高 实测打 5~7 折非常常见 ⚖️ 不同标准对比表 数据来源不详，仅仅供参考\n特性 CLTC WLTP EPA NEDC 最高车速 114 km/h 131 km/h 129 km/h 120 km/h 平均速度 32 km/h 46.5 km/h 48.3 km/h 34 km/h 是否考虑空调等负载 ❌ 否 部分工况支持 ✅ 是 ❌ 否 城市/高速比例 偏城市 综合 综合 偏城市 实测偏差率 20~30% 10~15% 5~10% 30~40% 🚗 实测案例：特斯拉 Model Y（长续航版） 数据来源不详，仅仅供参考\n测试标准 标称续航 实测高速续航（110 km/h） 偏差率 CLTC 660 km 470~500 km ↓ 25~30% WLTP 565 km 480~500 km ↓ 10~15% EPA 525 km 480~500 km ↓ 5~8% NEDC❌ 700+ km（历史） ~420 km ↓ 35~40% 🔍 注：同款车型在不同市场宣传用不同标准。例如，Model Y 在中国用 CLTC，欧洲用 WLTP，美国用 EPA。\n✅ 总结对比与建议 需求类型 推荐测试标准 日常真实体验、长期表现 ✅ EPA 欧系车数据、城市+郊区 ✅ WLTP 中国车型标称宣传 🟡 CLTC（需结合实测） 历史车型参考 ❌ NEDC（已过时） 建议： 🚫 不盲信续航数字，看清使用的测试标准 ✅ 看第三方实测或用户实用报告更可信 🚘 高速用车需求者优先关注 EPA 和实测表现 🔗 延伸阅读 CLTC EPA 官网 - FuelEconomy.gov WLTP 官方介绍 - UNECE 电动车实测续航大全（EV Database） ","date":"2025年7月5日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/stellate/sd/cltc/","series":[{"title":"国标那些事","url":"/series/%E5%9B%BD%E6%A0%87%E9%82%A3%E4%BA%9B%E4%BA%8B/"}],"smallImg":"","tags":[{"title":"电动车续航测试","url":"/tags/%E7%94%B5%E5%8A%A8%E8%BD%A6%E7%BB%AD%E8%88%AA%E6%B5%8B%E8%AF%95/"},{"title":"CLTC","url":"/tags/cltc/"},{"title":"EPA","url":"/tags/epa/"},{"title":"WLTP","url":"/tags/wltp/"},{"title":"NEDC","url":"/tags/nedc/"}],"timestamp":1751727427,"title":"电动车续航测试标准对比"},{"authors":[],"categories":[],"content":" 作为一个合格的懒人，致力于收集奇技淫巧，不再浪费时间于无聊的搜索\nshell # 查找某个文件夹的前三级文件夹 # 如果查找前三级的文件 可以使用把 d --\u003e f find /path -mindepth 1 -maxdepth 3 -type d tree -L 3 -d /path/ scp -rp -P 22 test@xxxxx:/file . # 错误直接退出 set -o errexit seq -f \"HELLO:%g,\" 1 16 # HELLO1-HELLO16 代理 # 服务器映射到本地端口 ssh -i test.key -D localport -p 22 user@1.1.1.1 export http_proxy=socks5://127.0.0.1:1080 export https_proxy=socks5://127.0.0.1:1080 curl --proxy socks5://127.0.0.1:1080 www.google.com 文本处理 find/sed/xargs 查找批量替换等\n# 文件头尾部空格 find ./ -name \"*.[ch]\" -exec sed -i '/./,$!d' {} + find ./ -name \"*.[ch]\" -exec sed -i -e :a -e '/^\\n*$/{$d;N;ba' -e '}' -e '$a\\' {} \\; # 文件编码改为utf8 find ./ -name \"*.[ch]\" -exec sh -c 'file \"$0\" | grep 8859 \u0026\u0026 iconv -f gbk -t utf-8 \"$0\" | sponge \"$0\"' {} \\; # tab转空格 find ./ -name \"*.[ch]\" ! -type d -exec bash -c 'expand -t 4 \"$0\" | sponge \"$0\"' {} \\; # 回车格式转换为LF find ./ -name \"*.[ch]\" -exec dos2unix {} \\; # 单个 find ./ -name \"*.[ch]\" -exec dos2unix {} + # 批量 find ./ -name \"*.[ch]\" -print0 | xargs -0 dos2unix # 批量 # 同时多个类型 find . \\( -name \"*.[csh]\" -o -name \"*.txt\" -o -name \"*.ld\" \\) -exec dos2unix {} + sed # 某行插入文本 sed -i '8a This is a test' regular_express.txt # 字符替换 str=\"hello world\" echo\\${str//o/P} echo\\${str/o/P} # 区别是str后面两个//可以全局替换 filestr=\\$(echo ${filestr}| sed 's/^/-add_set_file=/g' ) filestr=\\$(sed 's/^/-add_set_file=/g' \u003c\u003c\u003c${filestr}) echo颜色 # 字体颜色 Black='\\033[0;30m' # 黑色 Red='\\033[0;31m' # 红色 Green='\\033[0;32m' # 绿色 Yellow='\\033[0;33m' # 黄色 Blue='\\033[0;34m' # 蓝色 Purple='\\033[0;35m' # 紫色 Cyan='\\033[0;36m' # 青色 White='\\033[0;37m' # 白色 # 背景颜色 On_Black='\\033[40m' # 黑色背景 On_Red='\\033[41m' # 红色背景 On_Green='\\033[42m' # 绿色背景 On_Yellow='\\033[43m' # 黄色背景 On_Blue='\\033[44m' # 蓝色背景 On_Purple='\\033[45m' # 紫色背景 On_Cyan='\\033[46m' # 青色背景 On_White='\\033[47m' # 白色背景 # 特效 NC='\\033[0m' # 无颜色，清除颜色设置 Bold='\\033[1m' # 粗体 Underline='\\033[4m' # 下划线 Blink='\\033[5m' # 闪烁 Inverted='\\033[7m' # 反白显示 echo -e \"$REDS********$ENDS\" 自动补全 alias hi=\u0026rsquo;$HOME/xxx/hi.sh' source hi_complete 在hi.sh中添加参数处理逻辑即可 complete -F _hi_complete hi _hi_complete() { local cur prev opts COMPREPLY=() cur=\"${COMP_WORDS[COMP_CWORD]}\" prev=\"${COMP_WORDS[COMP_CWORD-1]}\" local prev2=\"${COMP_WORDS[COMP_CWORD-2]}\" case ${prev,,} in \"hi\") opts=\"build docker\" COMPREPLY=( $(compgen -W '${opts[@]}' -- $cur) ) ;; \"docker\") local docker_opts=(on off ps in) COMPREPLY=( $(compgen -W '${docker_opts[@]}' -- $cur) ) ;; *) _filedir ;; esac # echo 'cur='$cur,'prev'=$prev,'prev2'=$prev2\u003e\u003e~/11.txt } 添加用户/用户组 # 进入docker以后，新建一个和主机上相同的用户，用户组 sudo useradd bob sudo groupadd autosar sudo usermod -g autosar bob # usermod -aG autosar bob 新增用户组； -g 直接修改 sudo mkdir /home/bob sudo chown bob:autosar /home/bob/ # 把docker中的id修改为主机上相同的id cat /etc/passwd | grep bob # 记录用户id 用户组id bob:x:1006:1001:bob:/home/bob:/bin/sh sudo usermod -u 1006 bob sudo groupmod -g 1001 autosar # 后续共享目录放到自己的用户目录中 挂载网络目录 sshfs cn@172.22.22.230:/mnt/hgfs/test/ test/ # 卸载 fusermount -u /path/to/local/mountpoint wget wget -r -np -nH --cut-dirs=3 -R \"index.html*\" \"http://xxxxx/yy/zzz/dir/\" 命令参数的解释： -r 或 --recursive：递归下载。 -np 或 --no-parent：不下载父目录，避免爬升到父目录中去。 -nH 或 --no-host-directories：禁止创建包含服务器名的目录。 --cut-dirs=3：跳过远程服务器上的前3个目录层级。在这个例子中，yy/zzz/dir/ 被忽略。调整这个数字根据实际的URL路径。 -R \"index.html*\"：拒绝下载所有以index.html开头的文件（这通常是服务器生成的目录索引页面）。 最后是您要下载的URL。 该命令会在当前目录下创建一个包含所有下载文件和目录的结构，忽略上述提到的目录层级。 gerrit 查询当前patch\n#!/bin/sh # Automatically trigger jenkins compilation # */20 10-21 * * * /home/xxx/test.sh # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DO NOT EDIT ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ # exclude_times=(\"12:00\" \"18:00\" \"21:00\") # [[ \" ${exclude_times[*]} \" =~ \" $(date '+%H:%M') \" ]] \u0026\u0026 exit 0 cd /home/xxx current_timestamp=$(date +%s) logfile='/home/xxx/test.log' sed -i \"1i$(date +\"%Y.%m.%d %H:%M:%S\")\" $logfile ssh -p 22 test@gerrit3.xxx.com gerrit query is:open project:code/test/branch/xxx --patch-sets --format json \\ | jq -r 'select(.branch == \"codebase_rtos_dev\") | [.owner.email, (.patchSets | max_by(.number).createdOn), (.patchSets | max_by(.number).ref)] | @tsv' | while IFS=$'\\t' read -r -a array; do userName=$(echo \"${array[0]}\" | cut -d \"@\" -f 1) # echo \"${array[0]} ${array[1]} ${array[2]}\" # email, time, ref # if [[ $userName != \"test\" \u0026\u0026 $userName != \"abc\" ]]; then # continue # fi sed -i \"2i\\ $(printf \"%-16s\" \"$userName\") ${array[2]} $(date -d@${array[1]} +\"%m/%d %H:%M:%S\") $(date -d@${current_timestamp} +\"%m/%d %H:%M:%S\")\" $logfile time_diff=$((current_timestamp - array[1])) if ((time_diff \u003c 20*60)); then # delay require time patchUrl='git pull \"ssh://'$userName'@gerrit3.xxx.com:22/code/test/branch/xxx\" '${array[2]} patchParam='imagepath='$(echo $patchUrl | sed 's/ /%20/g' | sed 's/\"/%22/g')'\u0026build_all=yes\u0026autotest=yes' projectNames=('test_build_1') for projectName in \"${projectNames[@]}\" do curlParam='rtosuser:rtos@user123 xxx:443/job/test_build_1/job/'$projectName'/buildWithParameters?token=123456\u0026'$patchParam curl -u $curlParam sed -i \"3i\\ curl -u $curlParam\" $logfile done fi done查询正在运行jenkins任务，并取消排队的重复任务\nimport subprocess import requests import re from requests.utils import dict_from_cookiejar logfile = \"/home/xxx/test.log\" subprocess.run(f'sed -i \"2i\\ _cancelItem_:\" {logfile}' , shell=True) jenkins_url = \"http://xxx:443/\" username = \"test\" password = \"xxx123\" response = requests.get(f'{jenkins_url}queue/api/json', auth=(username, password)) data = response.json() # get block job list g_patchUrlList = [] for item in data['items']: if item['task']['name'] == 'test_build_1': item_id = item[\"id\"] causes_action = next((action for action in item['actions'] if action['_class'] == 'hudson.model.CauseAction'), None) startType = causes_action['causes'][0]['_class'] if causes_action else None if item[\"blocked\"] and not item[\"buildable\"]: if startType == 'hudson.model.Cause$RemoteCause' or 1: parameters = next((action['parameters'] for action in item['actions'] if action['_class'] == 'hudson.model.ParametersAction'), []) patchUrl = next((param['value'] for param in parameters if param['name'] == 'imagepath')).split()[-1] g_patchUrlList.append([item_id, patchUrl]) g_patchSet = set(re.search(r\"(.*)/\\d+$\", y).group(1) for x, y in g_patchUrlList) # cancel multi job if len(g_patchSet) \u003e 0: response = requests.get(f\"{jenkins_url}crumbIssuer/api/xml?xpath=concat(//crumbRequestField,\\\":\\\",//crumb)\", auth=(username, password)) crumb = response.text.split(\":\") cookies = dict_from_cookiejar(response.cookies) headers = { \"Jenkins-Crumb\": crumb[1], \"Cookie\": \"; \".join([f\"{name}={value}\" for name, value in cookies.items()]) } for patch in g_patchSet: tmpList = [x for x, y in g_patchUrlList if patch in y ] tmpList.remove(max(tmpList)) for id in tmpList: cancelUrl = f\"{jenkins_url}queue/cancelItem?id={id}\" response = requests.post(cancelUrl, auth=(username, password), headers=headers) subprocess.run(f'sed -i \"3i\\ {next(y for x, y in g_patchUrlList if x == id)} {response.status_code} {response.reason}\" {logfile}' , shell=True) gerrit 与 jenkins 集成互通 Gerit:\n管理员登录gerrit, http:/xxxxx/admin/repos/All-Projects,access Global Capabilities-\u0026gt;Stream Events 添加用户 jenkins Reference: refs/heads/* Label Code-Review: -1, +1 jenkins Label Verified: -1, +1 jenkins Jenkins: 安装插件： Gerrit Trigger 新建gerrit trigger 服务 添加jenkins节点：https://www.cnblogs.com/sky-cheng/p/14931503.html\ntab 忽略大小写 vim ~/.inputrc\n# do not show hidden files in the list set match-hidden-files off # auto complete ignoring case set show-all-if-ambiguous on set completion-ignore-case on # 保存重启终端 minicom win下minicom，ctrl a + q 要快 不能回车输入的话，minicom -s 把流控关闭\n#!/bin/sh ls /dev/ttyS* if [ -z \"$1\" ]; then read -p \"please input a num:\" num else num=$1 fi minicom -b 115200 -D /dev/ttyS$numssh win之后使用 minicom，1.mobaxterm能用，2.通过gitbash套用，然后改一下.bashrc配置\n\"c:\\Program Files\\git\\bin\\bash.exe\" -c \"/c/Users/xxx/AppData/Roaming/Mobaxterm/slash/bin/bash.exe -i\" c:\\Users\\xxx\\AppData\\Roaming\\MobaXterm\\slash\\bin\\bash.exe -i bat :: 短路径， 如 PROGRA~1 Program Files dir /x C:\\ :: 进入脚本所在目前 cd /d \"%~dp0\" :: 当前命令提示符的目录 cd %cd% :: 日期时间 echo %date% %time% :: 延时启动 timeout /T 10 /NOBREAK start cmd /C x.bat :: 删除文件夹 rmdir /s /q build del filename :: mklink /D link target :: powershell 端口检测 test-netconnection domain.com -p port 设置ip地址 netsh interface ip set address name=\"以太网 2\" static 192.168.1.10 255.255.255.0 netsh interface ip set address name=\"以太网 2\" dhcp bat 计算时分秒 set /a n=0 for /f \"tokens=1-8 delims=.: \" %%a in (\"%etime%:%stime%\") do ( set /a n+=10%%a%%100*360000+10%%b%%100*6000+10%%c%%100*100+10%%d%%100 set /a n-=10%%e%%100*360000+10%%f%%100*6000+10%%g%%100*100+10%%h%%100) set /a s=n/360000,n=n%%360000,f=n/6000,n=n%%6000,m=n/100,n=n%%100 echo time:%s%:%f%:%m% 计划任务/杀掉任务/停止服务 @echo off setlocal enabledelayedexpansion %1 mshta vbscript:createobject(\"shell.application\").shellexecute(\"\"\"%~0\"\"\",\"::\",,\"runas\",1)(window.close)\u0026\u0026exit /b CD /D \"%~dp0\" :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: echo %cd% @REM schtasks /Delete /TN \"xx1\" /F schtasks /Change /TN \"xx1\" /DISABLE schtasks /query /TN \"xx1\" taskkill /F /IM xx1.exe :: 停止服务 net stop \"xx\" pause exit 0 win自动上报ip地址 @echo off setlocal enabledelayedexpansion :: 初始化变量 set \"ip_str=test_123 %DATE% %TIME% ip: \" :: 使用 for /f 命令循环解析 ipconfig 输出，只取IPv4地址行的第二个字段（即IP地址） for /f \"tokens=2 delims=:\" %%a in ('ipconfig ^| findstr /i \"IPv4\"') do ( set \"ip=%%a\" :: 删除前导和尾随空格 set \"ip=!ip:~1!\" :: 将找到的IP地址添加到ip_str，以空格分隔 if defined ip_str ( set \"ip_str=!ip_str! !ip!\" ) else ( set \"ip_str=!ip!\" ) ) :: 输出所有拼接的IPv4地址 echo !ip_str! ssh -p 22 user@xxxx \"echo !ip_str! \u003e /home/test/ip.txt\" 普通用户通过管理员提权 @echo off :: 提权执行脚本，比如下面的脚本设置访问权限 runas /user:Administrator \"cmd /c %CD%\\test.bat\" :: 提权安装软件 :: runas /user:Administrator \"cmd /c %CD%\\setup.exe /S\"@echo off setlocal :: 设置目标目录 set \"folder_path=C:\\a2c\" :: 创建目录 mkdir \"%folder_path%\" if %errorlevel% neq 0 ( echo 创建目录失败：%folder_path% exit /b %errorlevel% ) :: 授予所有用户（Everyone）完全控制权限 icacls \"%folder_path%\" /grant \"Everyone:(OI)(CI)F\" /T if %errorlevel% neq 0 ( echo 设置权限失败：%folder_path% exit /b %errorlevel% ) echo 目录创建成功并已授予所有用户完全控制权限：%folder_path% pause 右键打开命令窗口 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\shell\\OpenCmdHere] @=\"在此处打开命令窗口\" \"Icon\"=\"cmd.exe\" [HKEY_CLASSES_ROOT\\Directory\\shell\\OpenCmdHere\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere] @=\"在此处打开命令窗口\" \"Icon\"=\"cmd.exe\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" [HKEY_CLASSES_ROOT\\Drive\\shell\\OpenCmdHere] @=\"在此处打开命令窗口\" \"Icon\"=\"cmd.exe\" [HKEY_CLASSES_ROOT\\Drive\\shell\\OpenCmdHere\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" [HKEY_CLASSES_ROOT\\LibraryFolder\\background\\shell\\OpenCmdHere] @=\"在此处打开命令窗口\" \"Icon\"=\"cmd.exe\" [HKEY_CLASSES_ROOT\\LibraryFolder\\background\\shell\\OpenCmdHere\\command] @=\"cmd.exe /s /k pushd \\\"%V\\\"\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas] @=\"以管理员身份运行CMD\" \"Icon\"=\"D:\\\\app\\\\ico\\\\t.ico\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command] \"ShowBasedOnVelocityId\"=dword:00639bc8 @=\"cmd.exe /s /k pushd \\\"%V\\\"\" 防火墙阻止出入站 @echo off :: setlocal ENABLEDELAYEDEXPANSION :: mode con: cols=65 lines=25 :: color 0a :: rem 批处理获取管理员权限 :: :------------------------------------- :: %1 mshta vbscript:createobject(\"shell.application\").shellexecute(\"\"\"%~0\"\"\",\"::\",,\"runas\",1)(window.close)\u0026\u0026exit /b :: CD /D \"%~dp0\" :: :------------------------------------- :begin rem 接收输入 set name= set Fpath= set /p name=Input software name: set /p Fpath=software path (C:Program FilesWinRAR): rem 输出得到的输入信息 echo Input software name: %name% echo software path: %Fpath% echo \"Please cancel: Ctrl+C\" pause setlocal enabledelayedexpansion set /a n=0 for /r \"%Fpath%\" %%i in (*.exe) do ( set /a n+=1 echo \"%name%_!n!\",\"%%i\" netsh advfirewall firewall del rule name=\"a_user_%name%_!n!\"\u003enul 2\u003enul netsh advfirewall firewall add rule name=\"a_user_%name%_!n!\" program=\"%%i\" action=block dir=out\u003enull netsh advfirewall firewall add rule name=\"a_user_%name%_!n!\" program=\"%%i\" action=block dir=in\u003enull echo block %name%_!n! ok ~~~ ) rem pause\u003enull echo. rem 从begin标签出，再次运行 goto begin ::如果要禁止入站规则，将 action=block dir=out\u003enull，中的out改为in，其他照旧 正则表达式 正则表达式基本点： 符号 用法 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，\u0026rsquo;n\u0026rsquo; 匹配字符 \u0026ldquo;n\u0026rdquo;。\u0026rsquo;\\n\u0026rsquo; 匹配一个换行符。序列 \u0026lsquo;\\\\\u0026rsquo; 匹配 \u0026ldquo;\\\u0026rdquo; 而 \u0026ldquo;\\(\u0026rdquo; 则匹配 \u0026ldquo;(\u0026quot;。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 \u0026lsquo;\\n\u0026rsquo; 或 \u0026lsquo;\\r\u0026rsquo; 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 \u0026lsquo;\\n\u0026rsquo; 或 \u0026lsquo;\\r\u0026rsquo; 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \u0026ldquo;z\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，\u0026lsquo;zo+\u0026rsquo; 能匹配 \u0026ldquo;zo\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;，但不能匹配 \u0026ldquo;z\u0026rdquo;。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，\u0026ldquo;do(es)?\u0026rdquo; 可以匹配 \u0026ldquo;do\u0026rdquo; 或 \u0026ldquo;does\u0026rdquo; 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，\u0026lsquo;o{2}\u0026rsquo; 不能匹配 \u0026ldquo;Bob\u0026rdquo; 中的 \u0026lsquo;o\u0026rsquo;，但是能匹配 \u0026ldquo;food\u0026rdquo; 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，\u0026lsquo;o{2,}\u0026rsquo; 不能匹配 \u0026ldquo;Bob\u0026rdquo; 中的 \u0026lsquo;o\u0026rsquo;，但能匹配 \u0026ldquo;foooood\u0026rdquo; 中的所有 o。\u0026lsquo;o{1,}\u0026rsquo; 等价于 \u0026lsquo;o+\u0026rsquo;。\u0026lsquo;o{0,}\u0026rsquo; 则等价于 \u0026lsquo;o*\u0026rsquo;。 {n,m} m 和 n 均为非负整数，其中n \u0026lt;= m。最少匹配 n 次且最多匹配 m 次。例如，\u0026ldquo;o{1,3}\u0026rdquo; 将匹配 \u0026ldquo;fooooood\u0026rdquo; 中的前三个 o。\u0026lsquo;o{0,1}\u0026rsquo; 等价于 \u0026lsquo;o?\u0026rsquo;。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \u0026ldquo;oooo\u0026rdquo;，\u0026lsquo;o+?\u0026rsquo; 将匹配单个 \u0026ldquo;o\u0026rdquo;，而 \u0026lsquo;o+\u0026rsquo; 将匹配所有 \u0026lsquo;o\u0026rsquo;。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 \u0026lsquo;\\n\u0026rsquo; 在内的任何字符，请使用像\u0026rdquo;(.|\\n)\u0026ldquo;的模式。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [\\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^\\f\\n\\r\\t\\v]。 \\w 匹配字母、数字、下划线。等价于\u0026rsquo;[A-Za-z0-9_]\u0026rsquo;。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 \u0026lsquo;\\(\u0026rsquo; 或 \u0026lsquo;\\)\u0026rsquo;。 x|y 匹配 x 或 y。例如，\u0026lsquo;z|food\u0026rsquo; 能匹配 \u0026ldquo;z\u0026rdquo; 或 \u0026ldquo;food\u0026rdquo;。\u0026rsquo;(z|f)ood\u0026rsquo; 则匹配 \u0026ldquo;zood\u0026rdquo; 或 \u0026ldquo;food\u0026rdquo;。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， \u0026lsquo;[abc]\u0026rsquo; 可以匹配 \u0026ldquo;plain\u0026rdquo; 中的 \u0026lsquo;a\u0026rsquo;。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， \u0026lsquo;[^abc]\u0026rsquo; 可以匹配 \u0026ldquo;plain\u0026rdquo; 中的\u0026rsquo;p\u0026rsquo;、\u0026rsquo;l\u0026rsquo;、\u0026lsquo;i\u0026rsquo;、\u0026rsquo;n\u0026rsquo;。 \\x20 匹配空格字符 [\\u4e00-\\u9fa5] 中文 (?!\u0026hellip;) 负前瞻, 断言后面的位置不匹配括号内的内容 \\b(?!cat)\\w+ 匹配不以 cat 开头的单词,\\b：单词边界 详细可参考：正则表达式 – 教程 | 菜鸟教程\nCmake debug信息 message(FATAL_ERROR xxxxxx ) // FATAL_ERROR SEND_ERROR WARNING AUTHOR_WARNING STATUS DEBUG TRACE 生成中间文件 set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -save-temps=obj\")将保存中间文件，以对象文件（.obj）的形式 分析源文件宏展开之后的代码，生成的中间文件example.c.i\nGit ssh-keygen -t ed25519 -f ./id_ed25519 -C \u0026ldquo;@.com\u0026rdquo;\n本地仓库同步 git config receive.denyCurrentBranch ignore #实际.git/config 文件中添加 #[receive] # denyCurrentBranch =ignore Git命令自动补全 参考：https://www.cnblogs.com/kinwing/p/11670577.html\n# 下载配置文件 git clone git://git.kernel.org/pub/scm/git/git.git # linux可能自带无需下载，搜索文件 git-completion.bash cp git/contrib/completion/git-completion.bash ~/.git-completion.bash # 在.bashrc中添加 source ~/.git-completion.bash source ~/.bashrc .gitconfig git config --global core.filemode false git config --global core.autocrlf false git config --unset-all core.filemode git config --global --list git config --local --list # git config --global alias.gc 'auto = 256' [core] autocrlf = false filemode = true preloadindex = true fscache = true [alias] co = checkout br = branch ci = commit st = status lg = log df = diff dfst = diff --stat dfcst = diff --cached --stat dfc = diff --cached ss = stash sl = stash list sp = stash pop cino = commit --amend --no-edit # pushx = \"!f() { git push \\\"$@\\\" \u0026\u0026 .git/hooks/post-push; }; f\" [color] ui = auto .ssh/config 若是win安装git后不能使用pull，可以先进行如下配置 在秘钥路径中 如 C:\\Users\\xxx.ssh 添加 config 文件，如下配置\nHost xxxx.com HostkeyAlgorithms +ssh-rsa PubkeyAcceptedAlgorithms +ssh-rsa # StrictHostKeyChecking no # UserKnownHostsFile /dev/null # 特定key配置，没有配置默认使用 id_rsa Host xxx1.com IdentityFile ~/.ssh/id_rsa IdentityFile ~/.ssh/id_rsa_1 Host xxx2.com IdentityFile ~/.ssh/id_rsa_2 github多用户 # 测试链接 ssh -T -vvv git@github.com # 配置 config 文件 # 添加 Host github.com IdentityFile ~/.ssh/id_ed25519 # 测试 git clone 日志debug GIT_SSH_COMMAND=\"ssh -v\" git clone git@github.com:Genymobile/scrcpy.git# ~/.ssh/config 文件新增如下内容 Host user1.github.com HostName github.com IdentityFile ~/.ssh/user1_ed25519 Host user2.github.com HostName github.com IdentityFile ~/.ssh/user2_ed25519 # 上面的配置可能由于22断开被封，出现错误：Connection closed by remote host # 参考 https://paugram.com/tech/github-ssh-connection-closed-problem-with-proxy.html Host user1.github.com HostName ssh.github.com User git Port 443 PreferredAuthentications publickey IdentityFile ~/.ssh/user1_ed25519 Host user2.github.com HostName ssh.github.com User git Port 443 PreferredAuthentications publickey IdentityFile ~/.ssh/user2_ed25519 # 用法 # git clone git@github.com:Genymobile/scrcpy.git 替换为如下即可 git clone git@user1.github.com:Genymobile/scrcpy.git # 多个用户可能会配置多个用户名和邮箱，在每个仓库单独配置即可 git config --local user.name \"your_name\" git config --local user.email \"your_eamil\" github查看仓库大小 直达链接：https://github.com/settings/repositories\n修改分支名 # 先切换所在分支 git checkout -b oldname origin/oldname # 修改分支名 git branch -m newname # 删除远程分支 git push origin --delete oldname # 推送新分支，如果不进行这一步，相当于删除远程分支 git push origin newname # 强制更新修改网页提交记录 # 本地修改 git log 之后，git push -f origin master # 主线master直接提交feature分支 git push origin dev:feature # 提交MR之后，在master分支 git pull --rebase 即可，偷懒一直在主线开发 git log git log --grep=\"xxx\" # 搜索特定作者 git log --author=\"作者名字\" --grep=\"关键字\" # 限定时间段 git log --after=\"YYYY-MM-DD\" --before=\"YYYY-MM-DD\" --grep=\"关键字\" # 查看对应的文件变化 git show commitId git whatchanged commitId # 切换到某次 commitId git checkout commitId # 根据 commitId 定位前后的提交记录， --oneline 简短显示log # 前面的一次记录 git log -1 commitId # 后面一次的提交记录 git log --reverse --oneline commitId..HEAD | head -n 1 # 查看HEAD git rev-parse HEAD # HEAD~1 HEAD~n HEAD^n vscode https://code.visualstudio.com/api/references/contribution-points\ngtags -i 搜索索引\ntab四个空格 code-\u0026gt;首选项-\u0026gt; 设置。\n搜索 tab size\u0026rsquo;即将值改为「4」\n注意：\n将 Detect Indentation 设置去掉，否则 vscode 会跟进文件内容自动推测tab 的空格数。就是说计算结果可能不是你设置的值。\ntab与空格相互转换 ctrl+shift+p 输入： convert indentation to spaces tab转空格 convert indentation to tab 空格转tab 文本换行 Ctrl+Shift+P 输入：Toggle World Wrap, 可配置快捷键\n代码折叠 要操作光标所在文件中的所有代码块：\n折叠所有 Ctrl+K+0 展开所有 Ctrl+K+J 仅仅操作光标所处代码块内的代码：\n折叠 Ctrl+Shift+[ 展开 Ctrl+Shift+] 更多操作：Ctrl+Shift+P搜索fold和unfold\nVSCode 的 #ifdef 区域变灰 ctrl+, 搜索 C_Cpp.dimInactiveRegions 勾选即可 或者 setting 中添加：\u0026ldquo;C_Cpp.dimInactiveRegions\u0026rdquo;: true\nsettings.json /home/bob/.vscode-server/data/Machine/settings.json\n{ \"C_Cpp.intelliSenseCacheSize\": 512, \"C_Cpp.intelliSenseMemoryLimit\": 512, \"C_Cpp.files.exclude\": { \"**/build\": true, }, \"debug.allowBreakpointsEverywhere\": true, \"git.ignoredRepositories\": [ \"/home/xxx/\" ], \"git.scanRepositories\": [ ], \"todo-tree.filtering.excludeGlobs\": [ ], \"python.analysis.exclude\": [ ] } .vscode/settings.json\n{ \"files.associations\": { \"CMakeLists.txt\": \"cmake\", }, \"files.exclude\": { \"**/.cache\": true }, \"search.exclude\": { \"**/build/*\": true }, // \"C_Cpp.intelliSenseEngine\": \"disabled\", \"C_Cpp.intelliSenseCacheSize\": 512, \"C_Cpp.intelliSenseMemoryLimit\": 512, // \"C_Cpp.workspaceSymbols\": \"Just My Code\", \"search.followSymlinks\": false, \"C_Cpp.errorSquiggles\": \"disabled\", } c_cpp_properties.json { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/xx/**\" ], \"defines\": [ \"TEST_MARCO=1\" ], \"compilerPath\": \"C:\\\\MinGW\\\\bin\\\\gcc.exe\", \"cStandard\": \"gnu17\", \"cppStandard\": \"gnu++14\", \"intelliSenseMode\": \"windows-gcc-x86\", \"configurationProvider\": \"ms-vscode.makefile-tools\" } ], \"version\": 4 } { \"configurations\": [ { \"name\": \"Linux\", \"includePath\": [ \"${workspaceFolder}/**\" ], \"defines\": [ \"TEST_MARCO=1\" ], \"compilerPath\": \"/usr/bin/gcc\", \"cStandard\": \"gnu11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"gcc-x64\" } ], \"version\": 4 } tasks.json { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build\", \"type\": \"shell\", \"isBackground\": true, \"command\": \"${workspaceFolder}/xxx/test.sh test1\", \"args\": [], \"problemMatcher\": [ { \"pattern\": [ { \"regexp\": \".\", \"file\": 1, \"location\": 2, \"message\": 3 } ], \"background\": { // \"activeOnStart\": false, \"beginsPattern\": \".*start qemu debug.*\", // 要对应编译成功后,一句echo的内容. 此处对应 Makefile Line:170 https://zhuanlan.zhihu.com/p/501901665 \"endsPattern\": \"build debug elf done.\" } }, ], \"presentation\": { // \"echo\": true, // \"showReuseMessage\": false, // \"clear\": true, \"close\": true, // \"group\": \"vm\" }, }, { \"label\": \"test\", \"type\": \"shell\", // \"dependsOn\": \"autosar64build\", \"command\": \"qemu-system-aarch64 -m 1024 -machine virt,gic-version=2,virtualization=on -cpu cortex-a53 -smp 2 -nographic -kernel ${workspaceFolder}/test -S -s -gdb\", \"args\":[], \"isBackground\": true, }, { \"label\": \"singlebuild\", \"type\": \"shell\", \"command\": \"gcc\", \"args\": [\"-g\", \"${fileDirname}/${fileBasename}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}\"] }, ] } launch.json { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"debug_1\", //\"preLaunchTask\": \"build\", \"type\": \"cppdbg\", \"request\": \"launch\", //\"miDebuggerServerAddress\": \"127.0.0.1\", \"program\": \"${workspaceFolder}/test.elf\", \"args\": [], \"stopAtEntry\": true, \"cwd\": \"${workspaceFolder}/\", \"environment\": [], \"externalConsole\": false, \"logging\": { \"engineLogging\": false }, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"aarch64-none-elf-gdb\", \"setupCommands\": [ //为了安装基础调试程序而执行的一个或多个GDB/LLDB命令 { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true }, { \"text\": \"set output-radix 16\" } // 16进制显示变量 ] }, { \"name\": \"c-debug\", //配置名称，显示在配置下拉菜单中 \"type\": \"cppdbg\", //配置类型 \"request\": \"launch\", //请求配置类型，可以是启动或者是附加 \"program\": \"${workspaceFolder}/test\", //程序可执行文件的完整路径，${workspaceFolder}表示远程连接的初始路径 \"args\": [], //传递给程序的命令行参数 \"stopAtEntry\": true,//可选参数，如果为true,调试程序应该在入口（main）处停止 \"cwd\": \"${workspaceFolder}/\", //目标的工作目录 \"environment\": [], //表示要预设的环境变量 \"externalConsole\": false,//如果为true，则为调试对象启动控制台 \"MIMode\": \"gdb\",//要连接到的控制台启动程序 \"setupCommands\": [ //为了安装基础调试程序而执行的一个或多个GDB/LLDB命令 { \"description\": \"为 gdb 启用整齐打印\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ] } ] } // ${workspaceFolder} - 当前工作目录(根目录) // ${workspaceFolderBasename} - 当前文件的父目录 // ${file} - 当前打开的文件名(完整路径) // ${relativeFile} - 当前根目录到当前打开文件的相对路径(包括文件名) // ${relativeFileDirname} - 当前根目录到当前打开文件的相对路径(不包括文件名) // ${fileBasename} - 当前打开的文件名(包括扩展名) // ${fileBasenameNoExtension} - 当前打开的文件名(不包括扩展名) // ${fileDirname} - 当前打开文件的目录 // ${fileExtname} - 当前打开文件的扩展名 // ${cwd} - 启动时task工作的目录 Current Working Directory // ${lineNumber} - 当前激活文件所选行 // ${selectedText} - 当前激活文件中所选择的文本 // ${execPath} - vscode执行文件所在的目录 // ${defaultBuildTask} - 默认编译任务(build task)的名字 服务器连接异常 可能是更新vscode 需要安装新的vscode-server，ps-ef | grep wget 抓取，或者下面的方法下载 help-\u0026gt;about 中可查看 commit号\nwget --tries=1 --connect-timeout=7 --dns-timeout=7 -O vscode-server.tar.gz https://update.code.visualstudio.com/commit:0ee08df0cf4527e40edc9aa28f4b5bd38bbff2b2/server-linux-x64/stable vscode-server手动\n替换需要的 commitID https://vscode.download.prss.microsoft.com/dbazure/download/stable/${commitID}/vscode-server-linux-x64.tar.gz\n解压到的路径 ${HOME}/.vscode-server/cli/servers/Stable-${commitID}/server\n${HOME}/.vscode-server/cli/servers/Stable-384ff7382de624fb94dbaf6da11977bba1ecd427/server ├── bin ├── extensions ├── LICENSE ├── node ├── node_modules ├── out ├── package.json └── product.json gtags 查找跳转 参考：https://blog.japinli.top/2021/06/gtags-exclude-some-directories/\ndefault:\\ :tc=gtags:tc=htags: common:\\ :skip=GPATH,GTAGS,GRTAGS,dir1/: gtags:\\ :tc=common:\\ :langmap=c\\:.c.h,yacc\\:.y,asm\\:.s.S,java\\:.java,cpp\\:.c++.cc.cpp.cxx.hxx.hpp.C.H,php\\:.php.php3.phtml: htags:\\ :body_begin=:body_end=:\\ :table_begin=:table_end=:\\ :title_begin=:title_end=:\\ :comment_begin=:comment_end=:\\ :sharp_begin=:sharp_end=:\\ :brace_begin=:brace_end=:\\ :warned_line_begin=:warned_line_end=:\\ :reserved_begin=:reserved_end=:script_alias=/cgi-bin/:\\ :ncol#4:tabs#8:normal_suffix=html:gzipped_suffix=ghtml:\\ :definition_header=no: // .globalrc_cfg GPATH GTAGS GRTAGS dir/ */dir2/ // 使用： if [ -f $(pwd)/.globalrc ];then # readarray -t lines \u003c $(pwd)/.globalrc_cfg skip=\" :skip=$(IFS=,; echo \"${lines[*]}\"):\" sed -i \"5s|.*|${skip}|\" $(pwd)/.globalrc # rm GPATH GRTAGS GTAGS echo \" $(pwd)/.globalrc \" export GTAGSCONF=$(pwd)/.globalrc gtags -v \u0026\u003e .globalrc_txt fi 异常：C++ Intellisense 升级到 C/C++，而两个同时安装，所以点击的时候有个相同的跳转地址\n快捷键 聚焦窗口 ctrl 0，ctrl 9，alt 0, ctrl alt p 删除一行 ctrl shift k 选中一行 ctrl l 替换小窗口ctrl h 快捷键 ctrl k ctrl s 删除前后 ctrl back ，ctrl del 插件同步 找到当前server中的 ~/.vscode-server/extensions/extensions.json 记录 \"id\":\"twxs.cmake\" , 找到需要的插件的id vscode 的终端中 whereis code code --install-extension twxs.cmake 下载想要同步的插件 连接私钥配置 C:\\Users\\bob.ssh\\config_vscode 是vscode链接服务器的配置文件,内容如下 Host test HostName 192.168.68.2 User test Port 22 IdentityFile D:\\dir1\\dir2\\id_rsa 关键需要设置D:\\dir1\\dir2\\id_rsa文件的属性（私钥id_rsa 不在 C:\\Users\\bob.ssh） 1. 右键属性-\u003e安全-\u003e编辑-\u003e能删除的直接删除其他所有用户，只保留自己的用户名 2. 如果不能编辑的-\u003e高级-\u003e禁用继承-\u003e从此对象删除所有已继承的权限-\u003e确定-\u003e编辑-\u003e添加-\u003e高级-\u003e立即查找-\u003e找到自己的用户名双击-\u003e然后确定返回即可 3. 就能用vscode访问远程的服务器了 方案二： 如下管理员权限建立软连接，即可 mklink /D C:\\Users\\bob.ssh\\config_vscode E:\\xxxx\\myconfig\n汇编调试断点 设置里面勾选 \u0026ldquo;debug.allowBreakpointsEverywhere\u0026rdquo;: true , 前提是编译的时候加入 -g 调试信息\n文件窗口查找 快捷键：Ctrl+Alt+F ，定位查找文件 面包屑导航 \u0026ldquo;breadcrumbs.enabled\u0026rdquo;: true\nvim 选择复制 进入字符模式\n按 v (小写)键进入字符模式，可以逐字符地选择文本 进入行模式\n按 V (大写) 键进入行模式，可以逐行地选择文本。\n进入块模式\n按 Ctrl + v 进入块模式，可以选择一个矩形区域。\n复制选中的文本\n选择文本后，按 y 键（表示 \u0026ldquo;yank\u0026rdquo;）将选中的文本复制到剪贴板。\n粘贴文本\n可以在所需位置按 p 键（小写 p）粘贴文本。如果想粘贴在光标之前，可以按 P 键（大写 P）。\n插入 光标之前：i\n光标之后：a\n下一行插入：o\n上一行插入：shift + o\ndocker 安装使用 docker 获取镜像，创建容器，配合shell章节的自动补全，环境配置好只需要使用就行了，无感操作 详细可参考：https://www.runoob.com/docker/docker-container-usage.html\n# 安装docker，终端输入 docker，ubuntu24.04会提示安装命令 sudo apt install docker.io # 安装完成之后 docker 执行需要root权限， 把需要操作的用户加入docker即可 sudo usermod -aG docker bob # 重启即可生效，其他方式如果ssh链接的，断开重连也会生效 # 会显示用户在docker组 id bob groups bob # 获取镜像 docker pull ubuntu # 查看镜像 docker images # 启动一个容器，镜像可以理解模版，容器是配置的不同的环境，可以一个镜像启动多个容器 # 可以先用起来，一些概念用着用着就熟悉了解了 docker run --privileged -it -d -v /home/bob:/home/bob --name my_nodejs ubuntu /bin/bash # 这里启动一个my_nodejs的容器（里面用户和主机用户一样，方便后续操作，默认用root用户进入，然后创建和主机一样的用户） # 前期可以直接 docker run --privileged -it -d --name my_nodejs ubuntu /bin/bash，直接用root操作 docker exec -it my_nodejs /bin/bash # 如果主机 id bob 为 1000，进入docker cat /etc/passwd，如果有1000的用户，直接修改用户名 # usermod -l bob -d /home/bob -m ubuntu # groupadd bob # usermod -g bob -G bob bob # 启动容器 docker start my_nodejs # 关闭容器 docker stop my_nodejs # 进入容器 docker exec -it -u bob -w /home/bob my_nodejs /bin/bash 动态添加端口 https://blog.csdn.net/weixin_41148525/article/details/135675015\nhttps://www.baeldung.com/ops/assign-port-docker-container\nsystemctl stop docker docker info | grep Root # dir docker inspect xxx | grep Id # idxxxxxxxx cd /dir/idxxxxxxxx # 修改如下{ // hostconfig.json ... \"PortBindings\": {\"80/tcp\":[{\"HostIp\":\"\",\"HostPort\":\"20082\"}]}, ... } { // config.v2.json \"Config\": { ... \"ExposedPorts\": { \"80/tcp\":{} }, ... } }systemctl start docker docker start xxxx docker port xxxx # 80/tcp -\u003e 0.0.0.0:20082 # 80/tcp -\u003e [::]:20082 ubuntu软件安装 tmux分屏 https://zhuanlan.zhihu.com/p/58668651\nexport TMUX_TMPDIR=~/.tmux/tmp\n应用修改图标 cd /usr/share/applications vi xxx 中的 icon = xx.icon\nchrome谷歌浏览器 wget \u0026ndash;no-check-certificate https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\nvscode wget \u0026ndash;no-check-certificate https://code.visualstudio.com/sha/download?build=stable\u0026os=linux-deb-x64\nsougou 下载页面：https://shurufa.sogou.com/linux 安装指导：https://shurufa.sogou.com/linux/guide\nsudo apt -f install 系统设置-\u0026gt;区域和语言-\u0026gt;管理已安装的语言-\u0026gt;在“语言”tab下-\u0026gt;点击“添加或删除语言” -\u0026gt; fcitx 设置fcitx开机自启动 sudo cp /usr/share/applications/fcitx.desktop /etc/xdg/autostart/ 卸载系统ibus输入法框架 sudo apt purge ibus\n关闭繁简切换： vi ~/.config/sogoupinyin/conf/env.ini ShortCutFanJian=1 # 修改为 0 vi ~/.config/fcitx/conf/fcitx-chttrans.config #Hotkey=CTRL_SHIFT_F # 修改为 Hotkey=CTRL_SHIFT_] 皮肤位置 /opt/sogoupinyin/files/share/resources/skin/ nas挂载 sudo apt-get install cifs-utils sudo mount -t cifs //192.168.1.1/share /home/bob/mydir -o username=bob,password=bob,iocharset=utf8 # sudo mount -t cifs //192.168.1.1/share /home/bob/mydir -o username=bob,password=bob,iocharset=utf8,uid=1000,gid=1000,file_mode=0777,dir_mode=0777 截图工具 Snipaste : Snipaste-2.9.2-Beta-x86_64 电脑重启登录的时候，右下角设置图标选择 ubuntu on Xorg PixPin 功能更丰富，暂不支持linux, 通过wine曲线救国 鼠标手势 easystroke：功能上和windows上的 WGestures，还是差不少 手势设置：https://tianws.github.io/skill/2019/10/31/short-cut-ubuntu/\npdf阅读器 Okular：主要为了配置 back forward 快捷键 alt+left，alt+right Settings-\u0026gt;Configure Okular-\u0026gt;General-\u0026gt;Program Features-\u0026gt;Open new files in tabs\ngedit自定义快捷键 https://github.com/foolo/gedit_custom_keys/\n设置 gedit -\u0026gt; Preferences-\u0026gt; Plugins -\u0026gt; Custom Keyboard Shortcuts\n日历 显示周数\ngsettings set org.gnome.desktop.calendar show-weekdate true\n显示农历\nhttps://extensions.gnome.org/extension/675/lunar-calendar/\n安装扩展，chrome扩展配置，apt 连接器\n触摸板 https://extensions.gnome.org/extension/4033/x11-gestures/\nhttps://github.com/JoseExposito/touchegg\n支持自定义手势\nsudo apt install touchegg flatpak\nflatpak install flathub com.github.joseexposito.touche\nWine 管理安装配置 wine sudo apt install winetricks\n# 下载：https://wiki.winehq.org/Download_zhcn # 安装 VeryCapture：https://verycapture.com/download.html # 安装快捷键转发 sudo apt install xdotool # 配置 #!/bin/bash if [ \"${1}\" == \"PixPin\" ];then xdotool key --window $( xdotool search --limit 1 --all --pid $( pgrep PixPin.exe ) --name PixPin ) \"F1\" elif [ \"${1}\" == \"VeryCapture\" ];then xdotool key --window $( xdotool search --limit 1 --all --pid $( pgrep VeryCapture.exe ) --name VeryCapture ) \"shift+F1\" fi # settings-\u003e Keyboard -\u003e Keyboard Shortcuts -\u003e View and Customize Shortcuts -\u003e Custom Shortcuts 安装 pixpin，需要下面两个运行库 winetricks vcrun2015 winetricks vcrun2017\npython pip安装\n# python3 curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py # python2 https://bootstrap.pypa.io/pip/2.7/get-pip.py python get-pip.py pip配置：\npython3 -m pip install pyelftools # http://mirrors.aliyun.com/pypi/simple/ # python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyelftools # 永久配置 ~/.pip/pip.conf [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple trusted-host = pypi.tuna.tsinghua.edu.cn # 可信主机，要不然可能报错 disable-pip-version-check = true # 取消pip版本检查，排除每次都报最新的pip timeout = 120 # ignore-installed = true # 忽略任何已经安装的系统包，强制安装指定的包，即使它可能与系统包冲突 # ➡️ pyenv 进行多版本的python管理 windows软件配置 chrome浏览器离线安装包 https://www.google.com/intl/zh-CN/chrome/next-steps.html?platform=win64\u0026standalone=1\u0026statcb=0\u0026installdataindex=empty\u0026defaultbrowser=0 https://dl.google.com/tag/s/appguid%3D%7B8A69D345-D564-463C-AFF1-A69D9E530F96%7D%26iid%3D%7BBD6E01DD-2315-DD04-9D6B-5A409199B5FF%7D%26lang%3Dzh-CN%26browser%3D4%26usagestats%3D0%26appname%3DGoogle%2520Chrome%26needsadmin%3Dprefers%26ap%3Dx64-stable-statsdef_1%26installdataindex%3Dempty/chrome/install/ChromeStandaloneSetup64.exe Beyond Compare魔法 reg delete \"HKEY_CURRENT_USER\\Software\\Scooter Software\\Beyond Compare 4\" /v CacheID /f 关闭自启动 关闭应用自动启动 关闭任务计划程序无用的启动配置 关闭windows defender实时保护 关闭实时保护(通过策略组修改关闭） 1.按win+R，输入gpedit.msc -\u0026gt; 2.选择计算机配置–\u0026gt;管理模板–\u0026gt;Windows组件–\u0026gt;Microsoft Defender防病毒–\u0026gt;实时保护 -\u0026gt; 3.双击关闭实时保护，选择已启用 1.进入“Window安全中心” -\u0026gt;2. 进入“病毒和威胁防护” -\u0026gt;3. 进入“管理设置” -\u0026gt; 4.点击关闭即可\n关闭自动提交样本 关闭篡改防护 https://blog.csdn.net/azxc98765/article/details/120094030\nssh server 设置中可选功能可安装openssh server\nhttps://github.com/PowerShell/Win32-OpenSSH/releases 下载安装OpenSSH-Win64-v9.5.0.0.msi\n:: 测试系统目录结构 ssh bob@10.1.1.100 \"pwd\" ssh bob@10.1.1.100 \"dir\" :: 进入执行bash :: ssh bob@10.1.1.100 \"/cygdrive/c/Program\\ Files/Git/bin/bash.exe -i\" ssh -t bob@10.1.1.100 \"C:/Progra~1/Git/bin/bash.exe\" ssh -t bob@10.1.1.100 \"\\\"C:/Program Files/Git/bin/bash.exe\\\"\" ssh bob@10.1.1.100 \"\\\"C:/Progra~1/Git/bin/bash.exe\\\" -c \\\"cd /d/mytest \u0026\u0026 git st \u0026\u0026 git gr \u0026\u0026 git lg -1\\\"\" ssh bob@10.1.1.100 \"\\\"C:/Program Files/Git/bin/bash.exe\\\" -c \\\"cd /d/mytest \u0026\u0026 git st \u0026\u0026 git gr \u0026\u0026 git lg -1\\\"\" :: 文件复制 :: scp test.txt bob@10.1.1.100:/cygdrive/d/mytest/ scp 'bob@10.1.1.100:D:/mytest/test.txt' . scp test.txt 'bob@10.1.1.100:D:/mytest/test.txt'sshpass -p password ssh name@ip # \"set path=C:\\Program Files\\Git\\bin;%path% \u0026\u0026 bash.exe -i\" sc stop sshd sc start sshd win获取ip地址 Python获取本机 IP/MAC（多网卡） – 二进制\nimport psutil def GetLocalIP(t=None): ips = [] iptype = \"AF_INET\" if t == 6: iptype = \"AF_INET6\" dic = psutil.net_if_addrs() for adapter in dic: snicList = dic[adapter] for snic in snicList: if iptype in snic.family.name: if t == 4 and \":\" in snic.address: continue ips.append(snic.address) return ips import socket def GetLocalIP(t=None): ips = [] addrs = socket.getaddrinfo(socket.gethostname(),None) for item in addrs: if t == 4 and ':' in item[4][0]: continue if t == 6 and ':' not in item[4][0]: continue ips.append(item[4][0]) return ips import json import requests import time import socket import schedule import datetime import jenkins import psutil KEYSMILE='.' def get_nodes_summary(username, password): # https://blog.csdn.net/Sudley/article/details/103848127 #获取nodes节点的name、label、ip、status（连接状态） try: server = jenkins.Jenkins('http://%s:%s@xxxx:8080', username, password) nodes = server.get_nodes() win_slave = [x for x in nodes if x['name'] == 'win_Slave'] # node_name = win_slave[0]['name'] isonline = not win_slave[0]['offline'] except Exception as e: isonline = False return isonline def GetLocalIPNew(t=None): unwanted_interface = ['Eth_eth0', 'Loopback Pseudo-Interface 1'] # 不想要的网卡名 ips = [] interfaces = psutil.net_if_addrs() for name, net_addresses in interfaces.items(): for net_address in net_addresses: if (net_address.family == socket.AF_INET or net_address.family == socket.AF_INET6) and name not in unwanted_interface: ips.append(net_address.address) return ips def GetLocalIP(t=None): ips = [] addrs = socket.getaddrinfo(socket.gethostname(),None) for item in addrs: if t == 4 and ':' in item[4][0]: continue if t == 6 and ':' not in item[4][0]: continue ips.append(item[4][0]) return ips def SendMessage(keyword, msg): url = 'bark.com' HEADERS = { \"Content-Type\": \"application/json; charset=utf-8\" } isonline = get_nodes_summary('user', 'test123') if isonline is False: msg += \" , offine ~~~\" sendMsg = { \"msgtype\": \"text\", \"text\": { \"content\": keyword + ' ' + msg } } try: requests.post(url, data=json.dumps(sendMsg), headers=HEADERS) ret = True except Exception as e: ret = False return ret def job(): SendMessage(KEYSMILE, \"Good Morning\") if __name__ == '__main__': print(datetime.datetime.now(), \"start run now ...\") schedule.every().day.at(\"00:00\").do(job) ips = [] ipchanged = False while True: schedule.run_pending() time.sleep(20) if ips != GetLocalIPNew(): ipchanged = True ips = GetLocalIPNew() print(datetime.datetime.now(), \"warning ip changed: \", ips) if ipchanged == True and \\ SendMessage(KEYSMILE, ', '.join(ips)) == True: ipchanged = False jlink下载 @echo off :: Calculate the number of parameters set argC=0 for %%x in (%*) do Set /A argC+=1 if %argC% geq 3 ( echo error, too many parameters echo one param: %0 test1 echo two param: %0 [jlink.exe]_path test1 exit /b 1 ) else if %argC% == 2 ( set jlinkpath=%1 set project=%2 ) else ( set jlinkpath=\"C:\\Program Files\\SEGGER\\JLink\\JLink.exe\" set project=%1 ) if [%project%] == [] ( set project=test1 ) for /R \".\\build\\%project%\\obj\\bin\\\" %%F in (*.hex) do set \"hexfile=.\\build\\%project%\\obj\\bin\\%%~nxF\" if not exist %jlinkpath% ( echo jlinkpath error : %jlinkpath% \u0026 exit /b 2 ) if not exist %hexfile% ( echo project error : %project% \u0026 exit /b 2 ) set commandfile=jinkConfig.txt @echo speed 4000 \u003e %commandfile% @echo r \u003e\u003e %commandfile% @echo h \u003e\u003e %commandfile% @echo erase \u003e\u003e %commandfile% @echo loadfile %hexfile% \u003e\u003e %commandfile% @echo q \u003e\u003e %commandfile% %jlinkpath% -device STM32H743II -si swd -autoconnect 1 -nogui 1 -exitonerror 1 -commandfile %commandfile% set err=%errorlevel% if exist %commandfile% ( del %commandfile% ) if %err% neq 0 ( echo download error : %project% \u0026 exit /b %err% ) exit /b 0 process-explorer Process Explorer - Sysinternals\npslist PsList - Sysinternals\nHandle关联的句柄 Handle - Sysinternals\nproxy clash verge\n基于 Sing-box 通用代理工具: hiddify\nSumatraPDF 小巧免费PDF查看器：SumatraPDF\n# 执行路径：SumatraPDF-settings.txt # https://www.sumatrapdfreader.org/docs/Commands Shortcuts [ [ Cmd = CmdNextTab Key = Alt + e ] [ Cmd = CmdPrevTab Key = Alt + w ] ] 桌面置顶 PinWin\n小工具 画笔工具 glnk\nxml查看工具\n删除Pdf密码 import fitz # pip install PyMuPDF input_pdf_path = 'xxx.pdf' output_pdf_path = 'xxx_1.pdf' pdf_password = 'test123' # 打开受密码保护的PDF文件 pdf_document = fitz.open(input_pdf_path) # 检查PDF是否加密 if pdf_document.is_encrypted: # 尝试使用密码解密 if not pdf_document.authenticate(pdf_password): print(\"Invalid password. Cannot remove password from PDF.\") pdf_document.close() exit(1) # 保存一个新的无密码PDF文件 pdf_document.save(output_pdf_path, encryption=fitz.PDF_ENCRYPT_NONE) pdf_document.close() print('PDF password has been removed.') PDF加书签 https://github.com/ifnoelse/pdf-bookmark.git\n由于网上download的ISO14229文档没有书签，故找了个小工具可以添加书签，留此记录。\nGitHub - chroming/pdfdir: PDF导航（大纲/目录）添加工具\n目录需要正则表达式匹配：\n二层 ^\\d\\d?.\\d\\d?\\s 三层 ^\\d\\d?.\\d\\d?.\\d\\d?\nxyz=''' Annex I (normative) Security access state chart 450 Annex J (informative) Recommended implementation for multiple client environments 458 Bibliography 464 ''' lines = xyz.split('\\n') #print(lines) for line in lines: matchObj = re.search( r'\\w+$', line, re.M|re.I) if matchObj: x=int(matchObj.group())+12 print(re.sub(r'\\w+$', str(x), line)) # else: # print( \"No match!!\") #re.search( r'\\w+$', line, re.M|re.I) python加解密 # pip3 install pycryptodome pillow from Crypto.Cipher import AES, PKCS1_OAEP from Crypto.PublicKey import RSA import zipfile from PIL import Image from Crypto.Cipher import AES from Crypto.Random import get_random_bytes import os import argparse def unpad(data): pad_len = data[-1] return data[:-pad_len] def decrypt_file(input_file, output_folder, private_key_file): with open(private_key_file, 'rb') as f: rsa_key = RSA.import_key(f.read()) rsa_cipher = PKCS1_OAEP.new(rsa_key) # ✅ 动态计算 key 长度（单位：字节） rsa_key_len_bytes = rsa_key.size_in_bits() // 8 # e.g. 4096 bits → 512 bytes with open(input_file, 'rb') as f: encrypted_key = f.read(rsa_key_len_bytes) # ⬅️ 动态读取对应长度 iv = f.read(16) encrypted_data = f.read() aes_key = rsa_cipher.decrypt(encrypted_key) aes_cipher = AES.new(aes_key, AES.MODE_CBC, iv) decrypted_data = unpad(aes_cipher.decrypt(encrypted_data)) if not os.path.exists(output_folder): os.makedirs(output_folder) # 临时解压 zip_path = os.path.join(output_folder, \"decrypted_temp.zip\") with open(zip_path, 'wb') as f: f.write(decrypted_data) with zipfile.ZipFile(zip_path, 'r') as zipf: zipf.extractall(output_folder) os.remove(zip_path) def decrypt_bin(input_bin, output_dir, private_key): decrypt_file(input_bin, output_dir, private_key) def zip_folder(folder_path, zip_path): with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf: for root, _, files in os.walk(folder_path): for file in files: full_path = os.path.join(root, file) arcname = os.path.relpath(full_path, folder_path) zipf.write(full_path, arcname) def pad(data): pad_len = 16 - len(data) % 16 return data + bytes([pad_len] * pad_len) def encrypt_zip(zip_file, output_file, public_key_file): # 加载RSA公钥 with open(public_key_file, 'rb') as f: rsa_key = RSA.import_key(f.read()) rsa_cipher = PKCS1_OAEP.new(rsa_key) # 生成AES密钥和IV aes_key = get_random_bytes(16) iv = get_random_bytes(16) # zip内容 with open(zip_file, 'rb') as f: data = f.read() padded = pad(data) aes_cipher = AES.new(aes_key, AES.MODE_CBC, iv) encrypted_data = aes_cipher.encrypt(padded) # 用RSAAES密钥 encrypted_key = rsa_cipher.encrypt(aes_key) # 写入输出：RSAkey + IV + 数据 with open(output_file, 'wb') as f: f.write(encrypted_key) f.write(iv) f.write(encrypted_data) def encrypt_bin(input_dir, output_bin, public_key): zip_folder(input_dir, '.tmp') encrypt_zip('.tmp', output_bin, public_key) os.remove('.tmp') def unpad(data): pad_len = data[-1] return data[:-pad_len] def extract_data_from_image(stego_path, output_bin_path, key, payload_len): img = Image.open(stego_path).convert(\"RGB\") pixels = list(img.getdata()) total_bits = payload_len * 8 bits = '' for pixel in pixels: for color in pixel: bits += str(color \u0026 1) if len(bits) \u003e= total_bits: break if len(bits) \u003e= total_bits: break data_bytes = bytes(int(bits[i:i+8], 2) for i in range(0, total_bits, 8)) iv = data_bytes[:16] encrypted = data_bytes[16:] cipher = AES.new(key, AES.MODE_CBC, iv) decrypted = unpad(cipher.decrypt(encrypted)) with open(output_bin_path, 'wb') as f: f.write(decrypted) print(f\"🔓 ：{output_bin_path}\") def decrypt_png(input_png, output_bin, key_dlen_str): key_hex, dlen_str = key_dlen_str.split(\":\") extract_data_from_image(input_png, output_bin, bytes.fromhex(key_hex), int(dlen_str)) def pad(data): pad_len = 16 - len(data) % 16 return data + bytes([pad_len] * pad_len) def encrypt_data(data, key, iv): cipher = AES.new(key, AES.MODE_CBC, iv) return cipher.encrypt(pad(data)) def embed_data_to_image(image_path, bin_path, output_path, key): iv = get_random_bytes(16) with open(bin_path, 'rb') as f: data = f.read() encrypted = encrypt_data(data, key, iv) payload = iv + encrypted img = Image.open(image_path).convert(\"RGB\") pixels = list(img.getdata()) bits = ''.join(f'{byte:08b}' for byte in payload) if len(bits) \u003e len(pixels) * 3: raise ValueError(\"数据太大，无法嵌入这张图片。\") new_pixels = [] bit_idx = 0 for pixel in pixels: r, g, b = pixel if bit_idx \u003c len(bits): r = (r \u0026 0xFE) | int(bits[bit_idx]) bit_idx += 1 if bit_idx \u003c len(bits): g = (g \u0026 0xFE) | int(bits[bit_idx]) bit_idx += 1 if bit_idx \u003c len(bits): b = (b \u0026 0xFE) | int(bits[bit_idx]) bit_idx += 1 new_pixels.append((r, g, b)) img.putdata(new_pixels) img.save(output_path) # print(f\"✅ ：{output_path}\") return len(payload) def encrypt_png(input_png, input_bin, keylen): key = get_random_bytes(keylen) # 必须保存这个 key print(\"KEY(hex):\", key.hex()) payload_len = embed_data_to_image(input_png, input_bin, f'new_{input_png}', key) print(f\"数据长度: {payload_len} 字节\") def generate(len): key = RSA.generate(len) private_key = key.export_key() public_key = key.publickey().export_key() with open(\"private.pem\", \"wb\") as f: f.write(private_key) with open(\"public.pem\", \"wb\") as f: f.write(public_key) print(\"🔑 密钥对已生成：private.pem / public.pem\") def main(): parser = argparse.ArgumentParser(description=\"🔐 多功能工具\") subparsers = parser.add_subparsers(dest=\"command\") # 1. generate g = subparsers.add_parser(\"generate\", help=\"生成 RSA 密钥对\") g.add_argument(\"--bits\", type=int, default=8192, help=\"RSA 密钥位数（默认2048）\") # 2. encrypt-bin ebin = subparsers.add_parser(\"encrypt-bin\", help=\"encrypt-bin\") ebin.add_argument(\"--input\", required=True, help=\"input dir\") ebin.add_argument(\"--output\", required=True, help=\"out bin\") ebin.add_argument(\"--pub\", required=True, help=\"RSA pub\") # 3. decrypt-bin dbin = subparsers.add_parser(\"decrypt-bin\", help=\"decrypt-bin\") dbin.add_argument(\"--input\", required=True, help=\"input bin\") dbin.add_argument(\"--output\", required=True, help=\"out dir\") dbin.add_argument(\"--priv\", required=True, help=\"RSA pri\") # 4. encrypt-png epng = subparsers.add_parser(\"encrypt-png\", help=\"encrypt-png\") epng.add_argument(\"--png\", required=True, help=\"input png\") epng.add_argument(\"--bin\", required=True, help=\"input bin\") epng.add_argument(\"--keylen\", type=int, default=32, help=\"keylen(16)\") # 5. decrypt-png dpng = subparsers.add_parser(\"decrypt-png\", help=\"decrypt-png\") dpng.add_argument(\"--image\", required=True, help=\"input png\") dpng.add_argument(\"--output\", required=True, help=\"out bin\") dpng.add_argument(\"--key\", type=str, required=True, help=\"key (hex)\") args = parser.parse_args() if args.command == \"generate\": generate(args.bits) elif args.command == \"encrypt-bin\": encrypt_bin(args.input, args.output, args.pub) elif args.command == \"decrypt-bin\": decrypt_bin(args.input, args.output, args.priv) elif args.command == \"encrypt-png\": encrypt_png(args.png, args.bin, args.keylen) elif args.command == \"decrypt-png\": decrypt_png(args.image, args.output, args.key) else: parser.print_help() # python 1.py generate --bits 8192 # python 1.py encrypt-bin --input a --output a.bin --pub public.pem # python 1.py decrypt-bin --input a.bin --output a2 --priv private.pem # python 1.py encrypt-png --png cover.png --bin a.bin --keylen 32 # python 1.py decrypt-png --image new_cover.png --output a.bin --key 31baed5c2e04541897384406828a8dd7:2032 if __name__ == '__main__': main() # generate(8192) # encrypt_bin('a','a.bin', 'public.pem') # decrypt_bin('a.bin', 'a2', 'private.pem') # encrypt_png('cover.png' ,'a.bin', 32) # decrypt_png('new_cover.png', 'a2.bin', bytes.fromhex('之前生成的KEY'):dlen) 青龙 faker2\njdpro\nandroid auto.js Android System WebView\n包名查看器 https://www.coolapk.com/apk/com.csdroid.pkg\n反编译: jadx\nlog查看:\nlognote CatSpy set path=C:\\Android\\openjdk\\jdk-17.0.8.101-hotspot\\bin;%path% java -jar CatSpy.jar 可启动U盘 可启动U盘: Ventoy\ngithub仓库 垃圾站点过滤：chinese-internet-is-dead\n一些技术pdf：develop-reference-data\nfreertos源码：FreeRTOS_Template\n小程序反汇编：wxapkg\nPDF编辑工具：Stirling-PDF\nOCR通用验证码离线本地识别：ddddocr\n通用的Ｃ基础库：gear-lib\nAutosar配置界面：Autosar-Configurator\n校园二手商城微信小程序云开发：used-book-secondhand\n开源网络流量监控工具：sniffnet\n防多次错误认证：fail2ban\nohmyzsh\n文件类型识别：Detect-It-Easy\n编程相关书籍 free-programming-books-zh\nhttps://github.com/p-moon/develop-reference-data\n","date":"2025年7月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/doraemon/","series":[],"smallImg":"","tags":[{"title":"工具箱","url":"/tags/%E5%B7%A5%E5%85%B7%E7%AE%B1/"},{"title":"Linux","url":"/tags/linux/"},{"title":"Win","url":"/tags/win/"}],"timestamp":1751383982,"title":"懒人技术手册"},{"authors":[],"categories":[{"title":"懒人快捷键","url":"/categories/%E6%87%92%E4%BA%BA%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"content":"一、说明 Ctrl – k: 先按住 Ctrl 键，然后再按 k 键； Alt – k: 先按住 Alt 键，然后再按 k 键； M – k：先单击 Esc 键，然后再按 k 键。\n二、移动光标 Ctrl – a ：移到行首 Ctrl – e ：移到行尾 Ctrl – b ：往回(左)移动一个字符 Ctrl – f ：往后(右)移动一个字符 Alt – b ：往回(左)移动一个单词 Alt – f ：往后(右)移动一个单词 Ctrl – xx ：在命令行尾和光标之间移动 M-b ：往回(左)移动一个单词 M-f ：往后(右)移动一个单词\n三、编辑命令 Ctrl – h ：删除光标左方位置的字符 Ctrl – d ：删除光标右方位置的字符（注意：当前命令行没有任何字符时，会注销系统或结束终端） Ctrl – w ：由光标位置开始，往左删除单词。往行首删 Alt – d ：由光标位置开始，往右删除单词。往行尾删 M – d ：由光标位置开始，删除单词，直到该单词结束。 Ctrl – k ：由光标所在位置开始，删除右方所有的字符，直到该行结束。 Ctrl – u ：由光标所在位置开始，删除左方所有的字符，直到该行开始。 Ctrl – y ：粘贴之前删除的内容到光标后。 Alt + t ：交换光标处和之前两个字符的位置。 Alt + . ：使用上一条命令的最后一个参数。 Ctrl – _ ：回复之前的状态。撤销操作。 Ctrl -a + Ctrl -k 或 Ctrl -e + Ctrl -u 或 Ctrl -k + Ctrl -u 组合可删除整行。\n四、Bang(!)命令 !! ：执行上一条命令。 foobar ：把上一条命令里的foo替换为bar，并执行。 !wget ：执行最近的以wget开头的命令。 !wget:p ：仅打印最近的以wget开头的命令，不执行。 !$ ：上一条命令的最后一个参数， 与 Alt - . 和 $_ 相同。 !* ：上一条命令的所有参数 !*:p ：打印上一条命令是所有参数，也即 !*的内容。 ^abc ：删除上一条命令中的abc。 foobar ：将上一条命令中的 foo 替换为 bar foobar^ ：将上一条命令中的 foo 替换为 bar !-n ：执行前n条命令，执行上一条命令： !-1， 执行前5条命令的格式是： !-5 五、查找历史命令 Ctrl – p ：显示当前命令的上一条历史命令 Ctrl – n ：显示当前命令的下一条历史命令 Ctrl – r ：搜索历史命令，随着输入会显示历史命令中的一条匹配命令，Enter键执行匹配命令；ESC键在命令行显示而不执行匹配命令。 Ctrl – g ：从历史搜索模式（Ctrl – r）退出。 六、控制命令 Ctrl – l ：清除屏幕，然后，在最上面重新显示目前光标所在的这一行的内容。 Ctrl – o ：执行当前命令，并选择上一条命令。 Ctrl – s ：阻止屏幕输出 Ctrl – q ：允许屏幕输出 Ctrl – c ：终止命令 Ctrl – z ：挂起命令 七、重复执行操作动作 M – 操作次数 操作动作 ： 指定操作次数，重复执行指定的操作。\n参考 linux 命令行 光标移动技巧\n","date":"2025年7月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/linux/shell/terminalshortcutkeys/","series":[{"title":"懒人教程系列","url":"/series/%E6%87%92%E4%BA%BA%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97/"}],"smallImg":"","tags":[{"title":"Terminal","url":"/tags/terminal/"},{"title":"Shell","url":"/tags/shell/"},{"title":"快捷键","url":"/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"timestamp":1751380576,"title":"终端快捷键"},{"authors":[],"categories":[{"title":"Trace32使用说明","url":"/categories/trace32%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"}],"content":"TC397xp下载脚本 默认Flash刷写*.cmm脚本路径：安装路径\\demo\\tricore\\flash\ntc397.bat, 方便第一次启动trace32软件\n@echo off rem 设置 Trace32 安装路径（根据你的实际安装目录修改） set TRACE32_PATH=C:\\T32 rem 设置配置文件和启动脚本路径（根据实际路径修改） set CONFIG_FILE=%TRACE32_PATH%\\config.t32 set CMM_SCRIPT=D:\\mycodedev\\project-tc397\\elf\\my-tc39x.cmm rem 启动 TRACE32 并加载脚本 @REM start \"\" \"%TRACE32_PATH%\\bin\\t32.exe\" -c \"%CONFIG_FILE%\" -s \"%CMM_SCRIPT%\" start \"\" \"%TRACE32_PATH%\\bin\\windows64\\t32mtc.exe\" -c \"%CONFIG_FILE%\" -s \"%CMM_SCRIPT%\" win.cmm，可以在trace32软件上调整布局需要的窗口之后store windows，根据需求修改即可\n// T32 Fri May 28 10:03:39 2023 B:: TOOLBAR ON STATUSBAR ON FramePOS 39.432,15.216,,,Maximized WinPAGE.RESet WinPAGE.Create P000 WinCLEAR WinPOS 33.729 35.83 51. 16. 0. 0. W004 SYStem WinPOS 47.134 24.627 123. 21. 23. 1. W001 WinTABS 13. 0. 0. 0. 0. 0. 0. 0. 0. 72. Break.List WinPOS 63.308 26.476 113. 26. 13. 1. W003 WinTABS 10. 10. 25. List P:0x8021A074 WinPOS 56.154 11.714 140. 37. 5. 0. W002 Frame WinPOS 0.0 0.0 158. 64. 0. 0. W000 Var.Watch ; 根据需要添加变量 Var.AddWatch testcnt WinPOS 93.375 25.786 96. 46. 13. 1. W004 Data.dump Var.ADDRESS(\"test_buf\") /DIALOG // b.set func_test b.set Mcu_PerformReset WinPAGE.select P000 ENDDO my-tc39x.cmm\n; y.spath.srd D:\\mycodedev\\project-tc397 ; 注释标识符 system.CPU.TC397Xp SYStem.DOWN SYStem.RESeT ; 烧录下载 do tc39x.cmm ; 方便调试相关 do win.cmm SYStem.Option.DUALPORT on SYStem.mode.down SYStem.mode.up SYStem.mode.go OS.LoadORTI \"RTAOS.orti\" // core.assign 1 2 3 4 5 6 TC397多核debug 帮助文档 C:\\T32\\pdf\\debugger_tricore.pdf\n烧录完成之后启动时core0，如果需要调试core1，此操作的断点只会在core1上生效\nsystem.mode.NoDebug system.config.core 2 system.mode.attach ; break ; go此操作的断点会在所有设置的核上生效\nsystem.mode.NoDebug ; 调试所有的6个核 core.number 6 ; 只调试部分核 core.assign 1 2 3 当前Core 0 和Core 1各自的寄存器信息 Register /Core 0 Register /Core 1 多窗口调试 Power Debug USB右键 add PowerView Instance，需要同时调试core0和core1 在core0窗口正常烧录下载，到core1窗口配置符号表调试\nData.LOAD.Elf test.elf /NoCODE 注：NoCODE ： Suppresses the code download. Only loads symbolic information. 参考：https://www2.lauterbach.com/pdf/general_ref_d.pdf\n配置core为1-\u0026gt;核0，core为2-\u0026gt;核1\nFormat: SYStem.CONFIG.CORE : 1 … i : 1 … k 参考：https://www2.lauterbach.com/pdf/debugger_mcore.pdf\n其他 GHS-TC397编译器 帮助文档资料：通过helpview.exe进行查询\n如反汇编脚本：\n@echo off set TARGET_DIR=build if exist \"%TARGET_DIR%\" ( echo Deleting dir...: %TARGET_DIR% @REM rmdir /s /q \"%TARGET_DIR%\" ) set \"currentDir=%CD%\" set PATH=%currentDir%\\bin;C:\\ghs\\bin;%path% @REM enter build dir pushd build @REM build elf cctri.exe test.c -cpu=tc1v162 -half_precision_type -g -dual_debug -X5853 -Omax -Xtricore_opts_20181 -ansi_alias -delete -data_delete -Onoalign_functions -no_align_standalone_objects --no_vla -discard_zero_initializers --no_commons --gnu_asm -tricore_avoid_mem_trap -version_info -w -errmax=10 -passsource --c++14 --no_rtti --restrict --new_outside_of_constructor -globalcheck=normal -globalcheck_qualifiers --diag_warning=undefined_preproc_id --diag_warning=missing_type_specifier --no_wrap_diagnostics -nostartfiles -Mu -Mx -Ml -Mn -keepmap --preprocess_linker_directive_full -Wl,-no_append -nostartfiles -Mu -Mx -Ml -Mn -keepmap --preprocess_linker_directive_full -Wl,-no_append -o tc397.elf @REM Disassembly gdump.exe -asm -yd -yl -ylaball tc397.elf \u003e relocations.txt popd 部分反汇编代码示例：\nmovh.a\ta2, 0xa000 mov16\td15, 1 st.b\t[a2]89, d15 ret16 tttx1: __ghs_eofn_t234x1: movh.a\ta2, 0xa000 mov16\td15, 1 st.b\t[a2]89, d15 ret16 func1: __ghs_eofn_tttx1: movh.a\ta2, 0xa000 mov16\td15, 1 st.b\t[a2]89, d15 call\t.-22 (0xa000000c) ret16 func2: __ghs_eofn_func1: mov16\td8, d4 movh.a\ta2, 0xa000 st.b\t[a2]90, d8 ret16 __ghs_eofn_func2: func3: movh.a\ta2, 0xa000 ld.bu\td15, [a2]91 extr.u\td2, d15, 0, 8 ret16 __ghs_eofn_func3: main: call\t.-66 (0xa0000000) call\t.-46 (0xa0000018) mov16\td4, 2 call\t.-36 (0xa0000028) call\t.-28 (0xa0000034) mov16\td2, 0 ret16 da\t. DW_TAG_subprogram DW_AT_name(\"func1\") DW_AT_decl_line(15) DW_AT_decl_column(6) DW_AT_decl_file(1) DW_AT_low_pc(0xa0000018) DW_AT_high_pc(0xa0000028) DW_AT_frame_base: reg26 DW_AT_ghs_rsm(0) DW_AT_ghs_rso(0) DW_AT_ghs_frsm(4294967295) DW_AT_ghs_frames(0) DW_AT_ghs_subcpu(0) DW_AT_declaration(false) DW_AT_inline(DW_INL_not_inlined) DW_AT_external(true) DW_AT_accessibility(DW_ACCESS_public) DW_AT_virtuality(DW_VIRTUALITY_none) DW_AT_prototyped(false) fb\t. . TAG_lexical_block DW_AT_low_pc(0xa0000018) DW_AT_high_pc(0xa0000026) 参考 J-Link Multi-core debugging\nTc397freertos_lwip\narm栈回溯\n","date":"2025年7月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/trace32/","series":[{"title":"嵌入式调试","url":"/series/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%B0%83%E8%AF%95/"}],"smallImg":"","tags":[{"title":"Trace32","url":"/tags/trace32/"},{"title":"Debug","url":"/tags/debug/"}],"timestamp":1751379132,"title":"TRACE32使用教程"},{"authors":[],"categories":[{"title":"Markdown-Tutorial","url":"/categories/markdown-tutorial/"}],"content":"vscode远程粘贴图片 插件 Paste Image from local pc，项目地址：https://github.com/mushanshitiancai/vscode-paste-image\nwin: ctrl+alt+v # 如需修改粘贴目录 \"pasteImage.path\": \"images/${fileBasenameNoExtension}\" 目录标题 直接输入1次#，并按下space后，将生成1级标题。 输入2次#，并按下space后，将生成2级标题。 以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。\n文本格式 强调文本 强调文本\n加粗文本 加粗文本\n==标记文本==\n删除文本\n引用文本\nH2O 是液体。 这是下标文本\n2^10^ 运算结果是 1024. 这是上标文本\n这是带下划线的文本\n链接与图片 链接: link.\n图片: 带尺寸的图片(HTML \u0026lt;img\u0026gt; 标签):30x30 只居中图片: 居中的图片且设置尺寸: 代码片 同样高亮的 代码片.\n// An highlighted block var foo = 'bar'; 列表 可通过在一行或多行文本前面加上 -、* 或 + 来创建一个无序列表\n项目 项目 项目 要对列表排序，请在每行前面添加一个编号\n项目1 项目2 项目3 First item Second item Third item Fourth item 任务列表, 请在列表项前加连字符和空格，后接 [ ]。 要将任务标记为完成，请使用 [x]\n计划任务 完成任务 表情符号 你可以通过键入 :EMOJICODE:（冒号后跟表情符号的名称）将表情符号添加到写作中。\n@octocat \u0026#x1f44d; This PR looks great - it\u0026rsquo;s ready to merge! \u0026#x1f600;\n有关可用表情符号和代码的完整列表，请参阅 Emoji-Cheat-Sheet\n脚注 Here is a simple footnote1.\n一个具有注脚的文本。2\n锚点 TEST\n00: 01: TEST脚注\n折叠块 展开表格 Field Bits Type Description C 31 rw Carry 默认展开 Field Bits Type Description C 31 rw Carry 表格 一个简单的表格是这么创建的：\n项目 Value 电脑 $1600 手机 $12 导管 $1 居中、居左、居右 使用:---------:居中 使用:----------居左 使用----------:居右\n第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 test test test SmartyPants SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：\nTYPE ASCII HTML Single backticks 'Isn't this fun?' \u0026lsquo;Isn\u0026rsquo;t this fun?\u0026rsquo; Quotes \u0026quot;Isn't this fun?\u0026quot; \u0026ldquo;Isn\u0026rsquo;t this fun?\u0026rdquo; Dashes -- is en-dash, --- is em-dash \u0026ndash; is en-dash, \u0026mdash; is em-dash 创建一个自定义列表 Markdown Text-to-HTML conversion tool Authors John Luke KaTeX数学公式 您可以使用渲染LaTeX数学表达式 KaTeX:\nGamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 是通过欧拉积分\n$$ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt,. $$\n你可以找到更多关于的信息 LaTeX 数学表达式here.\n甘特图 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表 可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：\nsequenceDiagram 张三 -\u0026gt;\u0026gt; 李四: 你好！李四, 最近怎么样? 李四--\u0026gt;\u0026gt;王五: 你最近怎么样，王五？ 李四--x 张三: 我很好，谢谢! 李四-x 王五: 我很好，谢谢! Note right of 王五: 李四想了很长时间, 文字太长了\u0026lt;br/\u0026gt;不适合放在一行. 李四--\u0026gt;\u0026gt;张三: 打量着王五... 张三-\u0026gt;\u0026gt;王五: 很好... 王五, 你怎么样? 这将产生一个流程图。:\ngraph LR A[长方形] -- 链接 --\u0026gt; B((圆)) A --\u0026gt; C(圆角长方形) B --\u0026gt; D{菱形} C --\u0026gt; D 关于 Mermaid 语法，参考 这儿, FLowchart流程图 我们依旧会支持flowchart的流程图：\nflowchart TD st([开始]) op[我的操作] cond{确认？} e([结束]) st --\u0026gt; op --\u0026gt; cond cond -- 是 --\u0026gt; e cond -- 否 --\u0026gt; op 关于 Flowchart流程图 语法，参考 这儿. 注释 My reference.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n示例，注脚的解释\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025年6月29日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/markdown/markdown/","series":[{"title":"Markdown教程","url":"/series/markdown%E6%95%99%E7%A8%8B/"}],"smallImg":"","tags":[{"title":"Markdown","url":"/tags/markdown/"},{"title":"编辑器","url":"/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"title":"写作","url":"/tags/%E5%86%99%E4%BD%9C/"}],"timestamp":1751209871,"title":"Markdown"},{"authors":[],"categories":[{"title":"嵌入式架构","url":"/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9E%B6%E6%9E%84/"}],"content":"参考链接 Arm® Cortex®-R52 Processor Technical Reference Manual\n","date":"2025年6月29日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/cpu/arm/cortex-r/cortex-r52/cortex-r52/","series":[{"title":"ARM 架构系列","url":"/series/arm-%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97/"}],"smallImg":"","tags":[{"title":"ARM","url":"/tags/arm/"},{"title":"Cortex-R52","url":"/tags/cortex-r52/"}],"timestamp":1751207233,"title":"Cortex-R52"},{"authors":[],"categories":[{"title":"网络通信","url":"/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"content":" 名词解释 缩略词 W全称 详细解释 应用场景 WLP Writer Liveliness Protocol 用于检测发布者（Writer）存活状态的协议，通过定期发送心跳信号实现 故障检测、QoS中的LIVELINESS策略配置 CDR Common Data Representation DDS标准定义的数据编码格式，支持跨平台数据序列化（大端序/小端序自适应） 网络传输、持久化存储、跨语言（C++/Java等）数据交换 RTPS Real-Time Publish-Subscribe DDS底层通信协议，基于UDP实现实时发布订阅模式 设备发现、数据路由 QoS Quality of Service 服务质量策略集合（如可靠性、延迟约束等） 配置数据传输的可靠性(RELIABLE/BEST_EFFORT)、持久性(DURABILITY)等 GUID Global Unique Identifier 全局唯一标识符，格式：Prefix[12字节] + EntityId[4字节] 唯一标识DDS域中的参与者和终结点 DCPS Data-Centric Publish-Subscribe DDS核心API层，提供主题(Topic)、数据写入(DataWriter)/读取(DataReader)等抽象 应用程序开发接口 DDSI-RTPS DDS Interoperability Wire Protocol 保证不同DDS实现间互操作的网络协议规范 多厂商DDS系统集成（如RTI Connext与Fast DDS通信） socket Discovery traffic type multicast unicast User traffic type multicast unicast mvbs中配置了三个socket：(不同的配置，对应不同的逻辑，比如组播socket只接收)\n发现组播socket: 发送/接收组播数据 发现单播socket: 接收发现单播数据 数据单播socket: 发送/接收单播数据 接收 main Rte_Dds_Ptcp_Recv_Handler ptcp_recv_handler udp_trans_recv_handle ptcp_recv_cb ptcp_process_new_message msg_recv_process msg_recv_process_submsg 消息分类 msg_recv_process_submsg_data (DATA) ptcp_dpde_on_data ptcp_pdp_reader_on_data ptcp_proxy_parse cdr_deserialize_ptcp_proxy (返回值判断是否new ptcp) ptcp_pdp_reader_data_process （上面返回ok，才会继续） ptcp_spdp_create_ptcp_proxy (Add new ptcp) 发送 Rte_Dds_TxData writer_submit_sample writer_submit_instance_sample writer_new_change writer_send_data writer_send_wcc （没有对ptcp_send_buffer_to返回值处理，上层失败返回也是ok） SPDP ptcp_spdp_writer_send_pdp 组包，发送组播信息\nliveliness_lost ptcp_proxy_liveliness_lost writer_remove_proxy writer_remove_proxies_with_ptcp\nSEDP main Rte_Dds_Ptcp_Recv_Handler ptcp_recv_handler udp_trans_recv_handle msg_recv_process msg_recv_process_submsg (收到 ACKNACK 报文) msg_recv_process_submsg_acknack ptcp_dpde_on_acknack sub_writer_on_acknack udp_trans_sendto udp_trans_send mvbs_udp_socket_sendto mvbs_udp_send 序列化与压缩算法 异常 参考资料 Fast DDS v3.2.2\neclipse-cyclonedds/cyclonedds\nomg/dds\nomg/DDSI-RTPS\n车载消息中间件FastDDS 源码解析（一）FastDDS 介绍和使用 c++版本源码分析\n","date":"2025年6月29日","img":"https://6668688.xyz/images/DDS/2025-07-03-22-24-27.png","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/dds/dds/","series":[{"title":"DDS 学习系列","url":"/series/dds-%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"}],"smallImg":"","tags":[{"title":"DDS","url":"/tags/dds/"}],"timestamp":1751206443,"title":"DDS"},{"authors":[],"categories":[],"content":"Welcome to my world\n","date":"2025年6月29日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/hello/","series":[],"smallImg":"","tags":[{"title":"Hello","url":"/tags/hello/"}],"timestamp":1751203462,"title":"Hello"},{"authors":[],"categories":[],"content":"我是谁，我从哪里来，我到哪里去.\n","date":"2025年6月28日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/about/","series":[],"smallImg":"","tags":[],"timestamp":1751068800,"title":"关于我"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/onlinetools/json/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":""},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/onlinetools/qrcode/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"二维码生成"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"联系我们"}]
